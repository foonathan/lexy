<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>lexy/dsl.hpp — lexy</title><style>:root{--white:white;--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#202020;--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1250px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px;display:flex;justify-content:center}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a,a svg,button svg{color:var(--link-color);fill:var(--link-color);stroke:var(--link-color);transition:color ease .3s}a:hover,button:hover{color:var(--highlight-color)}a:hover svg,button:hover svg{color:var(--highlight-color);fill:var(--highlight-color);stroke:var(--highlight-color)}a:focus,button:focus{outline:none}br{margin:1em}article{flex:1;min-width:0}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a svg{height:1em}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home .title{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1100px){aside.toc{display:initial;position:sticky;top:0;min-width:200px;max-width:350px;padding-right:1em;align-self:flex-start;hyphens:auto}aside.toc header{margin-top:1em;font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.2em}aside.toc ul li{padding-bottom:.2em}aside.toc a{text-decoration:none}}article form svg,article a svg,article i svg{height:1em;position:relative;top:2px;padding-right:3px}article p svg:not(:first-child){padding-left:.25em}article header{margin-top:1em;margin-bottom:1em}article header nav{display:flex;flex-wrap:wrap}article header nav a{text-decoration:none;padding-right:7px}@media(min-width:700px){article header nav form.search{margin-left:auto}}article header nav form.search input[type=search]{padding:2px;width:250px}article header nav form.search input[type=search]:focus{border-color:var(--highlight-color);outline:solid var(--highlight-color)1px}article header nav form.search button[type=submit]{margin-left:-25px;border:none;background:initial}article .lead p{font-weight:500;font-size:1.1em}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{font-weight:700}article .admonitionblock td.content div:first-child p{margin-top:0}article .admonitionblock td.content div:last-child p{margin-bottom:0}@media(max-width:600px){article .admonitionblock tr{display:block;float:left;padding-left:.5em;padding-right:.5em}article .admonitionblock tr td{display:block}}@media(min-width:600px){article .admonitionblock td.icon{width:75px;text-align:center;border-right:1px solid var(--gray-highlight-color)}article .admonitionblock td.content{padding-left:.5em}}article .exampleblock{margin-top:1em;margin-bottom:1em}article .exampleblock .title{font-style:italic}article a.github-example{text-decoration:none}article a.github-example svg{height:.8em;position:relative;top:2px}article .playground-example .title,article .godbolt-example .title{position:relative}article .playground-example .title a,article .godbolt-example .title a{position:absolute;top:7px;right:7px}article .playground-example .title a svg,article .godbolt-example .title a svg{height:1em}article details{margin-bottom:1em}article details summary{font-style:italic}article ul p,article ol p{margin:.2em}article div ul:not(:first-child),article div ol:not(:first-child){margin-top:0}article dl dt{margin-top:.5em;font-weight:700}article dl dd p,article dl dd div:only-child ul{margin:0;padding:0}article div dl:not(:first-child){margin-top:0}article table.tableblock{background:var(--white);margin:0 auto;border-collapse:collapse}article table.tableblock td,article table.tableblock th{border:1px solid var(--gray-highlight-color);padding:5px;text-align:left}article table.tableblock td p,article table.tableblock th p{margin:0}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article code{font-family:Inconsolata,monospace,sans-serif}article pre{margin-top:0;overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}.highlight .c,.highlight .cm,.highlight .cp,.highlight .c1,.highlight .cs,.ace_editor .c,.ace_editor .cm,.ace_editor .cp,.ace_editor .c1,.ace_editor .cs{color:#998;font-style:italic;font-weight:initial}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kp,.highlight .kr,.highlight .kt,.highlight .ace_storage,.highlight .ace_keyword,.ace_editor .k,.ace_editor .kc,.ace_editor .kd,.ace_editor .kp,.ace_editor .kr,.ace_editor .kt,.ace_editor .ace_storage,.ace_editor .ace_keyword{color:#458;font-style:initial;font-weight:700}.highlight .o,.highlight .p,.highlight .ace_keyword.ace_operator,.highlight .ace_paren,.highlight .ace_punctuation,.ace_editor .o,.ace_editor .p,.ace_editor .ace_keyword.ace_operator,.ace_editor .ace_paren,.ace_editor .ace_punctuation{color:red;font-style:initial;font-weight:initial}.highlight .ace_dsl,.ace_editor .ace_dsl{pointer-events:auto}.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .ace_constant,.ace_editor .m,.ace_editor .mf,.ace_editor .mh,.ace_editor .mi,.ace_editor .mo,.ace_editor .ace_constant{color:#ff8000;font-style:initial;font-weight:initial}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .s3,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss,.highlight .se,.highlight .ace_string,.ace_editor .s,.ace_editor .sb,.ace_editor .sc,.ace_editor .sd,.ace_editor .s2,.ace_editor .s3,.ace_editor .sh,.ace_editor .si,.ace_editor .sx,.ace_editor .sr,.ace_editor .s1,.ace_editor .ss,.ace_editor .se,.ace_editor .ace_string{color:green;font-style:initial;font-weight:initial}.highlight .cp,.highlight .cpf,.ace_editor .cp,.ace_editor .cpf{color:green;font-style:initial;font-weight:700}.highlight .err,.highlight .ace_invalid,.ace_editor .err,.ace_editor .ace_invalid{color:red;font-style:initial;font-weight:initial}.highlight strong,.ace_editor strong{font-weight:initial}.highlight strong:not(:empty)::before,.ace_editor strong:not(:empty)::before{content:"*";color:red}.highlight strong:not(:empty)::after,.ace_editor strong:not(:empty)::after{content:"*";color:red}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/><span class=title>lexy:</span> C++ parsing DSL</a></li></ul><ul id=main><li><a href=/learn/>Learn</a></li><li><a href=/reference/>Reference</a></li><li><a href=/playground/>Playground</a></li><li><a href=/download/>Download</a></li><li><a href=https://github.com/foonathan/lexy title=GitHub><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li></ul></div></nav><main><aside class=toc><header><a href=#>Table of Contents</a></header></aside><article id=doc><header><h1>Header <code>lexy/dsl.hpp</code></h1><nav><a href=https://github.com/foonathan/lexy/blob/main/include/lexy/dsl.hpp><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> View source
</a><a href="https://github.com/foonathan/lexy/issues/new?title=lexy%2fdsl.hpp"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bug" class="svg-inline--fa fa-bug fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M511.988 288.9c-.478 17.43-15.217 31.1-32.653 31.1H424v16c0 21.864-4.882 42.584-13.6 61.145l60.228 60.228c12.496 12.497 12.496 32.758.0 45.255-12.498 12.497-32.759 12.496-45.256.0l-54.736-54.736C345.886 467.965 314.351 480 280 480V236c0-6.627-5.373-12-12-12h-24c-6.627.0-12 5.373-12 12v244c-34.351.0-65.886-12.035-90.636-32.108l-54.736 54.736c-12.498 12.497-32.759 12.496-45.256.0-12.496-12.497-12.496-32.758.0-45.255l60.228-60.228C92.882 378.584 88 357.864 88 336v-16H32.666C15.23 320 .491 306.33.013 288.9-.484 270.816 14.028 256 32 256h56v-58.745l-46.628-46.628c-12.496-12.497-12.496-32.758.0-45.255 12.498-12.497 32.758-12.497 45.256.0L141.255 160h229.489l54.627-54.627c12.498-12.497 32.758-12.497 45.256.0 12.496 12.497 12.496 32.758.0 45.255L424 197.255V256h56c17.972.0 32.484 14.816 31.988 32.9zM257 0c-61.856.0-112 50.144-112 112h224C369 50.144 318.856.0 257 0z"/></svg> Report an issue
</a><a href=https://github.com/foonathan/lexy/edit/main/docs/content/reference/dsl/_index.adoc><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="edit" class="svg-inline--fa fa-edit fa-w-18" role="img" viewBox="0 0 576 512"><path fill="currentcolor" d="M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8.0zm162-22.9-48.8-48.8c-15.2-15.2-39.9-15.2-55.2.0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8.0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2.0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5.0 112v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"/></svg> Edit this page</a><form class=search id=dsl-goto-form><input type=search id=dsl-goto-search placeholder="Go to..." list=dsl-goto-data autocomplete=off>
<button type=submit title=Go><svg viewBox="0 0 448 512"><path d="M438.6 278.6c12.5-12.5 12.5-32.8.0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3.0s-12.5 32.8.0 45.3L338.8 224H32c-17.7.0-32 14.3-32 32s14.3 32 32 32h306.7L233.4 393.4c-12.5 12.5-12.5 32.8.0 45.3s32.8 12.5 45.3.0l160-160z"/></svg></button></form></nav></header><section><div class="paragraph lead"><p>The rule DSL for specifying the grammar.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=nc>T</span><span class=p>&gt;</span>
<span class=k>concept</span> <span class=n><em>rule</em></span> <span class=o>=</span> <span class=err>…</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>The grammar in lexy is specified in several productions, where each one defines an associated <em>rule</em>.
This rule is an object built from the objects and functions of namespace <code>lexy::dsl</code> that defines some (implementation-defined) parsing function.
Parsing a rule takes the reader, which remembers the current position of the input, and the context, which stores information about the current production and whitespace rules, and is responsible for handling errors and values.</p></div><div class=paragraph><p>Parsing can have one of the following results:</p></div><div class=ulist><ul><li><p>Parsing can succeed.
Then it consumes some input by advancing the reader position and produces zero or more values.</p></li><li><p>Parsing can fail.
Then it reports an error, potentially after having consumed some input but without producing values.
The parent rule can react to the failure by recovering from it or they fail itself.</p></li><li><p>Parsing can fail, but then recover.
Then it has reported an error, but now it has consumed enough input to be in a known good state and parsing continues normally.
See <a href=/reference/dsl/recover/#doc><code>error recovery</code> </a> for details.</p></li></ul></div><div class=paragraph><p>A <a href=/reference/dsl/branch/#doc>branch rule</a> is a special kind of rule that has an easy to check condition.
They are used to guide decisions in the parsing algorithm.
Every branch rule defines some (implementation defined) branch parsing function.
It mostly behaves the same as the normal parse rule, but can have one additional result:
branch parsing can <em>backtrack</em>.
If it backtracks, it hasn’t consumed any input, raised errors or produced values.
The parsing algorithm is then free to try another branch.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The idea is that a branch rule can relatively quickly decide whether or not it should backtrack.
If a branch rule does not backtrack, but fails instead, this failure is propagated and the parsing algorithm does not try another branch.</td></tr></tbody></table></div><div class=paragraph><p>A <a href=/reference/dsl/token/#doc>token rule</a> is a special kind of rule that describes the atomic elements.
Parsing them never produces any values and can happen easily,
as such they’re also branch rules where the entire rule is used as the condition.
Because they’re atomic elements of the input, they also participate in <a href=/reference/dsl/whitespace/#doc>automatic whitespace skipping </a>:
after every token, lexy will automatically skip whitespace, if one has been defined.</p></div><div class=paragraph><p>The parse context stores state that can be accessed during parsing.
This includes things like the current recursion depth, see <a href=/reference/dsl/production/#recurse><code>lexy::dsl::recurse</code> </a>,
whether or not automatic whitespace skipping is currently enabled, see <a href=/reference/dsl/whitespace/#doc>whitespace skipping </a>,
but also arbitrary user-defined variables, see <a href=/reference/dsl/context_flag/#context_flag><code>lexy::dsl::context_flag</code> </a>, <a href=/reference/dsl/context_counter/#context_counter><code>lexy::dsl::context_counter</code> </a>, and <a href=/reference/dsl/context_identifier/#context_identifier><code>lexy::dsl::context_identifier</code> </a>.</p></div><div class=paragraph><p>When a rule modifies the context during parsing, by adding an additional context variable for example,
this modification is available for all following rules in the current production and all child productions.
In particular, the modification is no longer visible in any parent production.
If a rule is parsed in a loop, e.g. by <a href=/reference/dsl/loop/#loop><code>lexy::dsl::loop</code> </a> or <a href=/reference/dsl/list/#list><code>lexy::dsl::list</code> </a>,
any context modification does not persist between loop iterations, and is also not available outside the loop.</p></div><div class=sect1><h2 id=_how_to_read_the_dsl_documentation_1>How to read the DSL documentation <sup class=footnote>[<a id=_footnoteref_1 class=footnote href=#_footnotedef_1 title="View footnote.">1</a>]</sup></h2><div class=sectionbody><div class=paragraph><p>The behavior of a rule is described by the following sections.</p></div><div class=dlist><dl><dt class=hdlist1>Matching/parsing</dt><dd><p>This section describes what input is matched for the rule to succeed, and what is consumed.
For token rules it is called "matching", otherwise "parsing".</p><div class=paragraph><p>It often delegates to the behavior of other rules:
Here, the term "parsing" refers to the parsing operation of a rule,
"branch parsing" or "try to parse" refers to the special parsing operation of a branch rule, which can backtrack,
"matching" refers to the parsing operation of a token rule, which cannot produce values,
and "try matching" refers to the branch parsing operation of a token rule, which cannot produce values or raise errors.</p></div></dd><dt class=hdlist1>Branch parsing</dt><dd><p>This section describes what input is matched, consumed, and leads to a backtracking for a branch rule.
Note that a rule can parse something different here than during non-branch parsing.</p></dd><dt class=hdlist1>Errors</dt><dd><p>This section describes what errors are raised, when, and where.
It also describes whether the rule can recover after the error.</p></dd><dt class=hdlist1>Values</dt><dd><p>This section describes what values are produced during a successful parsing operation.
It is omitted for token rules, which never produce values.</p></dd><dt class=hdlist1>Parse tree</dt><dd><p>This section describes what nodes are created in the <code>lexy::parse_tree</code>.
If omitted, a token rule creates a single token node covering everything consumed,
and a rule produces no extra nodes besides the ones created by the other rules it parses.</p></dd></dl></div><div class=paragraph><p>If a rule parses another rule in a new context (e.g. <a href=/reference/dsl/peek/#peek><code>lexy::dsl::peek</code> </a>),
the other rule does not have access to context variables, and any context modification is not visible outside of the rule.</p></div></div></div><div class=sect1><h2 id=_the_rule_dsl>The rule DSL</h2><div class=sectionbody><details><summary class=title>Primitive rules</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/any/#any><code>lexy::dsl::any</code> </a></dt><dd><p>match anything</p></dd><dt class=hdlist1><a href=/reference/dsl/eof/#eof><code>lexy::dsl::eof</code> </a></dt><dd><p>match EOF</p></dd><dt class=hdlist1><a href=/reference/dsl/newline/#newline><code>lexy::dsl::newline</code> </a> and <a href=/reference/dsl/newline/#eol><code>lexy::dsl::eol</code> </a></dt><dd><p>match the end of a line</p></dd></dl></div></div></details><details><summary class=title>Literal rules</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/literal/#lit_c><code>lexy::dsl::lit_c</code> </a></dt><dd><p>match a single character</p></dd><dt class=hdlist1><a href=/reference/dsl/literal/#lit><code>lexy::dsl::lit</code> </a> and <a href=/reference/dsl/literal/#lit><code>LEXY_LIT</code> </a></dt><dd><p>match character sequences</p></dd><dt class=hdlist1><a href=/reference/dsl/literal/#lit_b><code>lexy::dsl::lit_b</code> </a></dt><dd><p>match a sequence of bytes</p></dd><dt class=hdlist1><a href=/reference/dsl/literal/#lit_cp><code>lexy::dsl::lit_cp</code> </a></dt><dd><p>match a code point with the specified value</p></dd><dt class=hdlist1><a href=/reference/dsl/punctuator/#doc><code>punctuators</code> </a></dt><dd><p>match common punctuation</p></dd><dt class=hdlist1><a href=/reference/dsl/literal/#literal_set><code>lexy::dsl::literal_set</code> </a> and <a href=/reference/dsl/literal/#literal_set><code>LEXY_LITERAL_SET</code> </a></dt><dd><p>match one of the specified literals</p></dd><dt class=hdlist1><a href=/reference/dsl/follow/#followed_by><code>lexy::dsl::followed_by</code> </a> and <a href=/reference/dsl/follow/#not_followed_by><code>lexy::dsl::not_followed_by</code> </a></dt><dd><p>ensure a literal is (not) followed by a char class</p></dd><dt class=hdlist1><a href=/reference/dsl/case_folding/#ascii><code>lexy::dsl::ascii::case_folding</code> </a> and <a href=/reference/dsl/case_folding/#simple><code>lexy::dsl::unicode::simple_case_folding</code> </a></dt><dd><p>match a literal case-insensitively</p></dd></dl></div></div></details><details><summary class=title>Char classes</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/code_point/#code_point><code>lexy::dsl::code_point</code> </a></dt><dd><p>match specific Unicode code points</p></dd><dt class=hdlist1><a href=/reference/dsl/ascii/#doc><code>lexy::dsl::ascii</code> </a></dt><dd><p>match ASCII char classes</p></dd><dt class=hdlist1><a href=/reference/dsl/unicode/#doc><code>lexy::dsl::unicode</code> </a></dt><dd><p>match Unicode char classes</p></dd><dt class=hdlist1><a href=/reference/dsl/char_class/#union><code>lexy::dsl::operator/ (char class)</code> </a>, <a href=/reference/dsl/char_class/#complement><code>lexy::dsl::operator- (unary)</code> </a>, <a href=/reference/dsl/char_class/#minus><code>lexy::dsl::operator-</code> </a>, <a href=/reference/dsl/char_class/#intersection><code>lexy::dsl::operator&</code> </a></dt><dd><p>combine char classes</p></dd><dt class=hdlist1><a href=/reference/dsl/char_class/#macro><code>LEXY_CHAR_CLASS</code> </a></dt><dd><p>create a named char class</p></dd></dl></div></div></details><details><summary class=title>Branch conditions</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/branch/#branch><code>lexy::dsl::operator>></code> </a></dt><dd><p>add a branch condition to a rule</p></dd><dt class=hdlist1><a href=/reference/dsl/branch/#else_><code>lexy::dsl::else_</code> </a></dt><dd><p>branch condition that is always taken</p></dd><dt class=hdlist1><a href=/reference/dsl/peek/#peek><code>lexy::dsl::peek</code> </a> and <a href=/reference/dsl/peek/#peek_not><code>lexy::dsl::peek_not</code> </a></dt><dd><p>check whether something matches without consuming it</p></dd><dt class=hdlist1><a href=/reference/dsl/lookahead/#lookahead><code>lexy::dsl::lookahead</code> </a></dt><dd><p>check whether something matches somewhere in the input without consuming it</p></dd></dl></div></div></details><details><summary class=title>Combinators</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/token/#token><code>lexy::dsl::token</code> </a></dt><dd><p>turn a rule into a token</p></dd><dt class=hdlist1><a href=/reference/dsl/sequence/#sequence><code>lexy::dsl::operator+</code> </a></dt><dd><p>parse a sequence of rules</p></dd><dt class=hdlist1><a href=/reference/dsl/choice/#choice><code>lexy::dsl::operator|</code> </a></dt><dd><p>parse one of the specified (branch) rules</p></dd><dt class=hdlist1><a href=/reference/dsl/combination/#combination><code>lexy::dsl::combination</code> </a> and <a href=/reference/dsl/combination/#partial_combination><code>lexy::dsl::partial_combination</code> </a></dt><dd><p>parse all (some) of the (branch) rules in arbitrary order</p></dd><dt class=hdlist1><a href=/reference/dsl/if/#if_><code>lexy::dsl::if_</code> </a> and <a href=/reference/dsl/option/#opt><code>lexy::dsl::opt</code> </a></dt><dd><p>parse a branch rule if its condition matches</p></dd><dt class=hdlist1><a href=/reference/dsl/loop/#loop><code>lexy::dsl::loop</code> </a></dt><dd><p>parse a rule repeatedly</p></dd><dt class=hdlist1><a href=/reference/dsl/loop/#while_><code>lexy::dsl::while_</code> </a> and <a href=/reference/dsl/loop/#while_one><code>lexy::dsl::while_one</code> </a></dt><dd><p>parse a branch rule while its condition matches</p></dd><dt class=hdlist1><a href=/reference/dsl/list/#list><code>lexy::dsl::list</code> </a></dt><dd><p>parse a list of things</p></dd><dt class=hdlist1><a href=/reference/dsl/times/#times><code>lexy::dsl::times</code> </a> and <a href=/reference/dsl/repeat/#repeat><code>lexy::dsl::repeat</code> </a></dt><dd><p>parse a rule <code>N</code> times</p></dd><dt class=hdlist1><a href=/reference/dsl/until/#until><code>lexy::dsl::until</code> </a></dt><dd><p>skip everything until a rule matches</p></dd></dl></div></div></details><details><summary class=title>Brackets and delimited</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/terminator/#terminator><code>lexy::dsl::terminator</code> </a></dt><dd><p>parse something that ends with a terminator</p></dd><dt class=hdlist1><a href=/reference/dsl/brackets/#brackets><code>lexy::dsl::brackets</code> </a></dt><dd><p>parse something surrounded by brackets</p></dd><dt class=hdlist1><a href=/reference/dsl/delimited/#delimited><code>lexy::dsl::delimited</code> </a> and <a href=/reference/dsl/delimited/#escape><code>lexy::dsl::escape</code> </a></dt><dd><p>parse everything between two delimiters, with optional escape sequences</p></dd></dl></div></div></details><details><summary class=title>Productions</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/production/#p><code>lexy::dsl::p</code> </a> and <a href=/reference/dsl/production/#recurse><code>lexy::dsl::recurse</code> </a></dt><dd><p>parse another production</p></dd><dt class=hdlist1><a href=/reference/dsl/production/#inline_><code>lexy::dsl::inline_</code> </a></dt><dd><p>parse another production’s rule inline</p></dd><dt class=hdlist1><a href=/reference/dsl/return/#return_><code>lexy::dsl::return_</code> </a></dt><dd><p>exit early from parsing a production</p></dd><dt class=hdlist1><a href=/reference/dsl/subgrammar/#rule><code>lexy::dsl::subgrammar</code> </a></dt><dd><p>parse a production defined in a different source file</p></dd></dl></div></div></details><details><summary class=title>Values</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/capture/#capture><code>lexy::dsl::capture</code> </a></dt><dd><p>capture everything consumed by a token rule</p></dd><dt class=hdlist1><a href=/reference/dsl/position/#position><code>lexy::dsl::position</code> </a></dt><dd><p>produce the current input position</p></dd><dt class=hdlist1><a href=/reference/dsl/option/#nullopt><code>lexy::dsl::nullopt</code> </a></dt><dd><p>produce an empty placeholder value</p></dd><dt class=hdlist1><a href=/reference/dsl/member/#member><code>lexy::dsl::member</code> </a></dt><dd><p>parse something into a member variable</p></dd><dt class=hdlist1><a href=/reference/dsl/scan/#scan><code>lexy::dsl::scan</code> </a></dt><dd><p>parse a completely user-defined rule</p></dd><dt class=hdlist1><a href=/reference/dsl/parse_as/#parse_as><code>lexy::dsl::parse_as</code> </a></dt><dd><p>parses a rule ensuring it always produces a specific value</p></dd></dl></div></div></details><details><summary class=title>Errors and error recovery</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/error/#error><code>lexy::dsl::error</code> </a></dt><dd><p>explicitly raise an error</p></dd><dt class=hdlist1><a href=/reference/dsl/error/#must><code>lexy::dsl::must</code> </a></dt><dd><p>raise an error if a branch backtracks</p></dd><dt class=hdlist1><a href=/reference/dsl/recover/#try_><code>lexy::dsl::try_</code> </a></dt><dd><p>recover from a failed rule</p></dd><dt class=hdlist1><a href=/reference/dsl/recover/#recover><code>lexy::dsl::recover</code> </a></dt><dd><p>recover by looking and then continuing with some other rule</p></dd><dt class=hdlist1><a href=/reference/dsl/recover/#find><code>lexy::dsl::find</code> </a></dt><dd><p>recover by looking for synchronization tokens</p></dd></dl></div></div></details><details><summary class=title>Whitespace</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/whitespace/#whitespace><code>lexy::dsl::whitespace</code> </a></dt><dd><p>explicitly skip whitespace</p></dd><dt class=hdlist1><a href=/reference/dsl/whitespace/#no_whitespace><code>lexy::dsl::no_whitespace</code> </a></dt><dd><p>do not skip whitespace</p></dd></dl></div></div></details><details><summary class=title>Identifiers</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/identifier/#identifier><code>lexy::dsl::identifier</code> </a></dt><dd><p>parse an identifier</p></dd><dt class=hdlist1><a href=/reference/dsl/identifier/#keyword><code>lexy::dsl::keyword</code> </a></dt><dd><p>parse a keyword</p></dd><dt class=hdlist1><a href=/reference/dsl/symbol/#symbol><code>lexy::dsl::symbol</code> </a></dt><dd><p>parse one of the specified symbols and produce their value</p></dd><dt class=hdlist1><a href=/reference/dsl/flags/#flag><code>lexy::dsl::flag</code> </a> and <a href=/reference/dsl/flags/#flags><code>lexy::dsl::flags</code> </a></dt><dd><p>parses (multiple) symbols representing enum flags in any order</p></dd></dl></div></div></details><details><summary class=title>Numbers</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/digit/#zero><code>lexy::dsl::zero</code> </a></dt><dd><p>parse zero</p></dd><dt class=hdlist1><a href=/reference/dsl/digit/#digit><code>lexy::dsl::digit</code> </a></dt><dd><p>parse a digit</p></dd><dt class=hdlist1><a href=/reference/dsl/digit/#digits><code>lexy::dsl::digits</code> </a></dt><dd><p>parse one or more digits</p></dd><dt class=hdlist1><a href=/reference/dsl/digit/#n_digits><code>lexy::dsl::n_digits</code> </a></dt><dd><p>parse N digits</p></dd><dt class=hdlist1><a href=/reference/dsl/integer/#integer><code>lexy::dsl::integer</code> </a></dt><dd><p>convert digits to an integer</p></dd><dt class=hdlist1><a href=/reference/dsl/sign/#sign><code>lexy::dsl::sign</code> </a>, <a href=/reference/dsl/sign/#plus_sign><code>lexy::dsl::plus_sign</code> </a> and <a href=/reference/dsl/sign/#minus_sign><code>lexy::dsl::minus_sign</code> </a></dt><dd><p>parse a sign</p></dd><dt class=hdlist1><a href=/reference/dsl/integer/#code_point_id><code>lexy::dsl::code_point_id</code> </a></dt><dd><p>convert N digits into a code point</p></dd></dl></div></div></details><details><summary class=title>Operator precedence parsing</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/operator/#op><code>lexy::dsl::op</code> </a></dt><dd><p>parse an operator</p></dd><dt class=hdlist1><a href=/reference/dsl/operator/#choice><code>lexy::dsl::operator/ (operator)</code> </a></dt><dd><p>parse one of multiple operators</p></dd><dt class=hdlist1><a href=/reference/dsl/expression/#doc><code>expression</code> </a></dt><dd><p>parse an expression consisting of multiple operators</p></dd></dl></div></div></details><details><summary class=title>Context-sensitive parsing</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/context_flag/#context_flag><code>lexy::dsl::context_flag</code> </a></dt><dd><p>a boolean flag</p></dd><dt class=hdlist1><a href=/reference/dsl/context_counter/#context_counter><code>lexy::dsl::context_counter</code> </a></dt><dd><p>an integer counter</p></dd><dt class=hdlist1><a href=/reference/dsl/context_identifier/#context_identifier><code>lexy::dsl::context_identifier</code> </a></dt><dd><p>an identifier variable</p></dd></dl></div></div></details><details><summary class=title>Byte input</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/dsl/byte/#bytes><code>lexy::dsl::bytes</code> </a> and <a href=/reference/dsl/byte/#bytes><code>lexy::dsl::padding_bytes</code> </a></dt><dd><p>parse <code>N</code> bytes</p></dd><dt class=hdlist1><a href=/reference/dsl/byte/#int><code>lexy::dsl::bint8</code> </a>, <a href=/reference/dsl/byte/#int><code>lexy::dsl::bint16</code> </a>, …​</dt><dd><p>parse a little/big endian integer</p></dd><dt class=hdlist1><a href=/reference/dsl/bits/#bits><code>lexy::dsl::bits</code> </a></dt><dd><p>parse a byte with specific bit patterns</p></dd><dt class=hdlist1><a href=/reference/dsl/bom/#bom><code>lexy::dsl::bom</code> </a></dt><dd><p>parse a byte-order mark (BOM)</p></dd></dl></div></div></details><details><summary class=title>Input and action specific rules</summary><div class=content><div class=dlist><dl><dt class=hdlist1><a href=/reference/input/argv_input/#argv_separator><code>lexy::dsl::argv_separator</code> </a></dt><dd><p>match the argument separator of a <a href=/reference/input/argv_input/#argv_input><code>lexy::argv_input</code> </a>
<a href=/reference/dsl/parse_tree_node/#tnode><code>lexy::dsl::tnode</code> <svg viewBox="0 0 448 512"><title>Experimental</title><path d="M437.2 403.5 319.1 215V64h7.1c13.25.0 23.1-10.75 23.1-24l-2e-4-16c0-13.25-10.75-24-23.1-24H120C106.8.0 96.01 10.75 96.01 24l-2e-4 16c0 13.25 10.75 24 23.1 24h7.1L128 215 10.8 403.5C-18.48 450.6 15.27 512 70.89 512h306.2c55.61.0 89.41-61.5 60.11-108.5zM137.1 320l48.15-77.63C189.8 237.3 191.9 230.8 191.9 224l.0651-160h63.99l-.06 160c0 6.875 2.25 13.25 5.875 18.38L309.9 320H137.1z"/></svg>
</a>and link:/reference/dsl/parse_tree_node/#pnode[<code>lexy::dsl::pnode</code> +&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">&lt;!--! Font Awesome Pro 6.1.1 by @fontawesome - <a href=https://fontawesome.com class=bare>https://fontawesome.com</a> License - <a href=https://fontawesome.com/license class=bare>https://fontawesome.com/license</a> (Commercial License) Copyright 2022 Fonticons, Inc. -→
&lt;title>Experimental&lt;/title>
&lt;path d="M437.2 403.5L319.1 215L319.1 64h7.1c13.25 0 23.1-10.75 23.1-24l-.0002-16c0-13.25-10.75-24-23.1-24H120C106.8 0 96.01 10.75 96.01 24l-.0002 16c0 13.25 10.75 24 23.1 24h7.1L128 215l-117.2 188.5C-18.48 450.6 15.27 512 70.89 512h306.2C432.7 512 466.5 450.5 437.2 403.5zM137.1 320l48.15-77.63C189.8 237.3 191.9 230.8 191.9 224l.0651-160h63.99l-.06 160c0 6.875 2.25 13.25 5.875 18.38L309.9 320H137.1z"/>&lt;/svg></p></dd><dt class=hdlist1>+]</dt><dd><p>match a node of a <a href=/reference/input/parse_tree_input/#parse_tree_input><code>lexy::parse_tree_input</code> <svg viewBox="0 0 448 512"><title>Experimental</title><path d="M437.2 403.5 319.1 215V64h7.1c13.25.0 23.1-10.75 23.1-24l-2e-4-16c0-13.25-10.75-24-23.1-24H120C106.8.0 96.01 10.75 96.01 24l-2e-4 16c0 13.25 10.75 24 23.1 24h7.1L128 215 10.8 403.5C-18.48 450.6 15.27 512 70.89 512h306.2c55.61.0 89.41-61.5 60.11-108.5zM137.1 320l48.15-77.63C189.8 237.3 191.9 230.8 191.9 224l.0651-160h63.99l-.06 160c0 6.875 2.25 13.25 5.875 18.38L309.9 320H137.1z"/></svg></a></p></dd><dt class=hdlist1><a href=/reference/action/trace/#debug><code>lexy::dsl::debug</code> </a></dt><dd><p>generate a debug event that is visualized by <a href=/reference/action/trace/#trace><code>lexy::trace</code> </a></p></dd></dl></div></div></details></div></div><div id=footnotes><hr><div class=footnote id=_footnotedef_1><a href=#_footnoteref_1>1</a>. <a href=https://xkcd.com/1343>obligatory XKCD</a></div></div></section></article><datalist id=dsl-goto-data></datalist>
<script>window.addEventListener("load",async function(){var e=await(await fetch("/reference/index.json")).json(),n=document.getElementById("dsl-goto-data"),s=document.getElementById("dsl-goto-form"),t=document.getElementById("dsl-goto-search");for(let t in e){let s=document.createElement("option");t.startsWith("lexy_")?s.value=t.toUpperCase():s.value=t,n.appendChild(s)}s.addEventListener("submit",function(n){n.preventDefault();let s=e[t.value.toLowerCase()];return s?window.location.href=s:t.value="",!1})})</script></main><footer id=page-footer><section class=copyright>&copy; <a target=_blank href=https://github.com/foonathan/lexy/blob/main/LICENSE title=License>2020-2025 Jonathan Müller and lexy contributors</a></section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://fontawesome.com/license>Font Awesome</a>.</section></footer></body></html>