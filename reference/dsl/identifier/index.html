<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>lexy/dsl/identifier.hpp — lexy</title><style>:root{--white:white;--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#202020;--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1250px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px;display:flex;justify-content:center}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a,a svg,button svg{color:var(--link-color);fill:var(--link-color);stroke:var(--link-color);transition:color ease .3s}a:hover,button:hover{color:var(--highlight-color)}a:hover svg,button:hover svg{color:var(--highlight-color);fill:var(--highlight-color);stroke:var(--highlight-color)}a:focus,button:focus{outline:none}br{margin:1em}article{flex:1;min-width:0}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a svg{height:1em}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home .title{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1100px){aside.toc{display:initial;position:sticky;top:0;min-width:200px;max-width:350px;padding-right:1em;align-self:flex-start;hyphens:auto}aside.toc header{margin-top:1em;font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.2em}aside.toc ul li{padding-bottom:.2em}aside.toc a{text-decoration:none}}article form svg,article a svg,article i svg{height:1em;position:relative;top:2px;padding-right:3px}article p svg:not(:first-child){padding-left:.25em}article header{margin-top:1em;margin-bottom:1em}article header nav{display:flex;flex-wrap:wrap}article header nav a{text-decoration:none;padding-right:7px}@media(min-width:700px){article header nav form.search{margin-left:auto}}article header nav form.search input[type=search]{padding:2px;width:250px}article header nav form.search input[type=search]:focus{border-color:var(--highlight-color);outline:solid var(--highlight-color)1px}article header nav form.search button[type=submit]{margin-left:-25px;border:none;background:initial}article .lead p{font-weight:500;font-size:1.1em}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{font-weight:700}article .admonitionblock td.content div:first-child p{margin-top:0}article .admonitionblock td.content div:last-child p{margin-bottom:0}@media(max-width:600px){article .admonitionblock tr{display:block;float:left;padding-left:.5em;padding-right:.5em}article .admonitionblock tr td{display:block}}@media(min-width:600px){article .admonitionblock td.icon{width:75px;text-align:center;border-right:1px solid var(--gray-highlight-color)}article .admonitionblock td.content{padding-left:.5em}}article .exampleblock{margin-top:1em;margin-bottom:1em}article .exampleblock .title{font-style:italic}article a.github-example{text-decoration:none}article a.github-example svg{height:.8em;position:relative;top:2px}article .playground-example .title,article .godbolt-example .title{position:relative}article .playground-example .title a,article .godbolt-example .title a{position:absolute;top:7px;right:7px}article .playground-example .title a svg,article .godbolt-example .title a svg{height:1em}article details{margin-bottom:1em}article details summary{font-style:italic}article ul p,article ol p{margin:.2em}article div ul:not(:first-child),article div ol:not(:first-child){margin-top:0}article dl dt{margin-top:.5em;font-weight:700}article dl dd p,article dl dd div:only-child ul{margin:0;padding:0}article div dl:not(:first-child){margin-top:0}article table.tableblock{background:var(--white);margin:0 auto;border-collapse:collapse}article table.tableblock td,article table.tableblock th{border:1px solid var(--gray-highlight-color);padding:5px;text-align:left}article table.tableblock td p,article table.tableblock th p{margin:0}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article code{font-family:Inconsolata,monospace,sans-serif}article pre{margin-top:0;overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}.highlight .c,.highlight .cm,.highlight .cp,.highlight .c1,.highlight .cs,.ace_editor .c,.ace_editor .cm,.ace_editor .cp,.ace_editor .c1,.ace_editor .cs{color:#998;font-style:italic;font-weight:initial}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kp,.highlight .kr,.highlight .kt,.highlight .ace_storage,.highlight .ace_keyword,.ace_editor .k,.ace_editor .kc,.ace_editor .kd,.ace_editor .kp,.ace_editor .kr,.ace_editor .kt,.ace_editor .ace_storage,.ace_editor .ace_keyword{color:#458;font-style:initial;font-weight:700}.highlight .o,.highlight .p,.highlight .ace_keyword.ace_operator,.highlight .ace_paren,.highlight .ace_punctuation,.ace_editor .o,.ace_editor .p,.ace_editor .ace_keyword.ace_operator,.ace_editor .ace_paren,.ace_editor .ace_punctuation{color:red;font-style:initial;font-weight:initial}.highlight .ace_dsl,.ace_editor .ace_dsl{pointer-events:auto}.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .ace_constant,.ace_editor .m,.ace_editor .mf,.ace_editor .mh,.ace_editor .mi,.ace_editor .mo,.ace_editor .ace_constant{color:#ff8000;font-style:initial;font-weight:initial}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .s3,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss,.highlight .se,.highlight .ace_string,.ace_editor .s,.ace_editor .sb,.ace_editor .sc,.ace_editor .sd,.ace_editor .s2,.ace_editor .s3,.ace_editor .sh,.ace_editor .si,.ace_editor .sx,.ace_editor .sr,.ace_editor .s1,.ace_editor .ss,.ace_editor .se,.ace_editor .ace_string{color:green;font-style:initial;font-weight:initial}.highlight .cp,.highlight .cpf,.ace_editor .cp,.ace_editor .cpf{color:green;font-style:initial;font-weight:700}.highlight .err,.highlight .ace_invalid,.ace_editor .err,.ace_editor .ace_invalid{color:red;font-style:initial;font-weight:initial}.highlight strong,.ace_editor strong{font-weight:initial}.highlight strong:not(:empty)::before,.ace_editor strong:not(:empty)::before{content:"*";color:red}.highlight strong:not(:empty)::after,.ace_editor strong:not(:empty)::after{content:"*";color:red}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/><span class=title>lexy:</span> C++ parsing DSL</a></li></ul><ul id=main><li><a href=/learn/>Learn</a></li><li><a href=/reference/>Reference</a></li><li><a href=/playground/>Playground</a></li><li><a href=/download/>Download</a></li><li><a href=https://github.com/foonathan/lexy title=GitHub><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li></ul></div></nav><main><aside class=toc><header><a href=#>Table of Contents</a></header></aside><article id=doc><header><h1>Header <code>lexy/dsl/identifier.hpp</code></h1><nav><a href=https://github.com/foonathan/lexy/blob/main/include/lexy/dsl/identifier.hpp><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> View source
</a><a href="https://github.com/foonathan/lexy/issues/new?title=lexy%2fdsl%2fidentifier.hpp"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bug" class="svg-inline--fa fa-bug fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M511.988 288.9c-.478 17.43-15.217 31.1-32.653 31.1H424v16c0 21.864-4.882 42.584-13.6 61.145l60.228 60.228c12.496 12.497 12.496 32.758.0 45.255-12.498 12.497-32.759 12.496-45.256.0l-54.736-54.736C345.886 467.965 314.351 480 280 480V236c0-6.627-5.373-12-12-12h-24c-6.627.0-12 5.373-12 12v244c-34.351.0-65.886-12.035-90.636-32.108l-54.736 54.736c-12.498 12.497-32.759 12.496-45.256.0-12.496-12.497-12.496-32.758.0-45.255l60.228-60.228C92.882 378.584 88 357.864 88 336v-16H32.666C15.23 320 .491 306.33.013 288.9-.484 270.816 14.028 256 32 256h56v-58.745l-46.628-46.628c-12.496-12.497-12.496-32.758.0-45.255 12.498-12.497 32.758-12.497 45.256.0L141.255 160h229.489l54.627-54.627c12.498-12.497 32.758-12.497 45.256.0 12.496 12.497 12.496 32.758.0 45.255L424 197.255V256h56c17.972.0 32.484 14.816 31.988 32.9zM257 0c-61.856.0-112 50.144-112 112h224C369 50.144 318.856.0 257 0z"/></svg> Report an issue
</a><a href=https://github.com/foonathan/lexy/edit/main/docs/content/reference/dsl/identifier.adoc><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="edit" class="svg-inline--fa fa-edit fa-w-18" role="img" viewBox="0 0 576 512"><path fill="currentcolor" d="M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8.0zm162-22.9-48.8-48.8c-15.2-15.2-39.9-15.2-55.2.0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8.0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2.0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5.0 112v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"/></svg> Edit this page</a><form class=search id=dsl-goto-form><input type=search id=dsl-goto-search placeholder="Go to..." list=dsl-goto-data autocomplete=off>
<button type=submit title=Go><svg viewBox="0 0 448 512"><path d="M438.6 278.6c12.5-12.5 12.5-32.8.0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3.0s-12.5 32.8.0 45.3L338.8 224H32c-17.7.0-32 14.3-32 32s14.3 32 32 32h306.7L233.4 393.4c-12.5 12.5-12.5 32.8.0 45.3s32.8 12.5 45.3.0l160-160z"/></svg></button></form></nav></header><section><div class="paragraph lead"><p>The <code>identifier</code> and <code>keyword</code> rules.</p></div><div class=sect1><h2 id=identifier>Rule <code>lexy::dsl::identifier</code></h2><div class=sectionbody><div class=listingblock><div class=title><code>lexy/dsl/identifier.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>namespace</span> <span class=n>lexy</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>reserved_identifier</span> <span class=p>{};</span>
<span class=p>}</span>

<span class=k>namespace</span> <span class=n>lexy</span><span class=o>::</span><span class=n>dsl</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=c1>// models <em>branch-rule</em></span>
    <span class=p>{</span>
        <span class=c1>//=== modifiers ===//</span>
        <span class=k>constexpr</span> <span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>reserve</span><span class=p>(</span><span class=k>auto</span> <span class=p>...</span> <span class=n>rules</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
        <span class=k>constexpr</span> <span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>reserve_prefix</span><span class=p>(</span><span class=k>auto</span> <span class=p>...</span> <span class=n>rules</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
        <span class=k>constexpr</span> <span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>reserve_containing</span><span class=p>(</span><span class=k>auto</span> <span class=p>...</span> <span class=n>rules</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
        <span class=k>constexpr</span> <span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>reserve_suffix</span><span class=p>(</span><span class=k>auto</span> <span class=p>...</span> <span class=n>rules</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>

        <span class=c1>//=== sub-rules ===//</span>
        <span class=k>constexpr</span> <span class=n><em>token</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>pattern</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>

        <span class=k>constexpr</span> <span class=n><em>token</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>leading_pattern</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
        <span class=k>constexpr</span> <span class=n><em>token</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>trailing_pattern</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
    <span class=p>};</span>

    <span class=k>constexpr</span> <span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>identifier</span><span class=p>(</span><span class=n><em>char</em></span><em><span class=o>-</span><span class=k>class</span><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>leading</span><span class=p>,</span>
                                        <span class=n><em>char</em></span><em><span class=o>-</span><span class=k>class</span><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>trailing</span><span class=p>);</span>

    <span class=k>constexpr</span> <span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>identifier</span><span class=p>(</span><span class=n><em>char</em></span><em><span class=o>-</span><span class=k>class</span><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>c</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=n>identifier</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
    <span class=p>}</span>

<span class=p>}</span></code></pre></div></div><div class="paragraph lead"><p><code>identifier</code> is a rule that parses an identifier.</p></div><div class=paragraph><p>It can be created using two overloads.
The first overload takes a <a href=/reference/dsl/char_class/#doc>char class rule</a> that matches the <code>leading</code> character of the identifier,
and one that matches all <code>trailing</code> characters after the first.
The second overload takes just one <a href=/reference/dsl/char_class/#doc>char class rule</a> and uses it both as <code>leading</code> and <code>trailing</code> characters.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>The <a href=/reference/encoding/#doc>encoding</a> of the input is a char encoding.</p></dd><dt class=hdlist1>Parsing</dt><dd><p>Matches and consumes the token <code>.pattern()</code> (see below).
Then verifies that the lexeme formed from <code>.pattern()</code> (excluding any trailing whitespace), is not reserved (see below).</p></dd><dt class=hdlist1>Branch parsing</dt><dd><p>Tries to match and consume the token <code>.pattern()</code> (see below), backtracking if that fails.
Otherwise it checks for reserved identifiers and backtracks if it was reserved.
As such, branch parsing only raises errors due to the implicit whitespace skipping.</p></dd><dt class=hdlist1>Errors</dt><dd><div class=ulist><ul><li><p>All errors raised by <code>.pattern()</code>. The rule then fails if not during branch parsing.</p></li><li><p><code>lexy::reserved_identifier</code>: if the identifier is reserved; its range covers the identifier.
The rule then recovers.</p></li></ul></div></dd><dt class=hdlist1>Values</dt><dd><p>A single <a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code> </a> that is the parsed identifier (excluding any trailing whitespace).</p></dd><dt class=hdlist1>Parse tree</dt><dd><p>The single token node created by <code>.pattern()</code> (see below).
Its kind cannot be overridden.</p></dd></dl></div><div class=exampleblock><div class=title>Example 1. Parse a C-like identifier</div><div class=content><div class="listingblock playground-example"><div class=title><a href="/playground?example=identifier&amp;mode=tree" title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>production</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=k>auto</span> <span class=n>head</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha_underscore</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>tail</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha_digit_underscore</span><span class=p>;</span>
        <span class=k>return</span> <span class=n>dsl</span><span class=o>::</span><span class=n>identifier</span><span class=p>(</span><span class=n>head</span><span class=p>,</span> <span class=n>tail</span><span class=p>);</span>
    <span class=p>}();</span>
<span class=p>};</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Example 2. Parse a Unicode-aware C-like identifier</div><div class=content><div class="listingblock playground-example"><div class=title><a href="/playground?example=identifier-unicode&amp;mode=tree" title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>production</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span>
        <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>identifier</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>unicode</span><span class=o>::</span><span class=n>xid_start_underscore</span><span class=p>,</span> <span class=c1>// want &#39;_&#39; as well</span>
                          <span class=n>dsl</span><span class=o>::</span><span class=n>unicode</span><span class=o>::</span><span class=n>xid_continue</span><span class=p>);</span>
<span class=p>};</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Example 3. Parse a case-insensitive identifier</div><div class=content><div class="listingblock godbolt-example"><div class=title><a href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbXSwiZXhlY3V0b3JzIjpbeyJjb21waWxlciI6eyJpZCI6ImNsYW5nX3RydW5rIiwibGlicyI6W3siaWQiOiJsZXh5IiwidmVyc2lvbiI6InRydW5rIn1dLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9LCJzdGRpbiI6IkhlTGxPIiwic3RkaW5WaXNpYmxlIjp0cnVlfV0sImlkIjoxLCJsYW5ndWFnZSI6ImMrKyIsInNvdXJjZSI6IiNpbmNsdWRlIFx1MDAzY3N0cmluZ1x1MDAzZVxuXG4jaW5jbHVkZSBcdTAwM2NsZXh5L2FjdGlvbi9wYXJzZS5ocHBcdTAwM2VcbiNpbmNsdWRlIFx1MDAzY2xleHkvY2FsbGJhY2suaHBwXHUwMDNlXG4jaW5jbHVkZSBcdTAwM2NsZXh5L2RzbC5ocHBcdTAwM2VcbiNpbmNsdWRlIFx1MDAzY2xleHlfZXh0L2NvbXBpbGVyX2V4cGxvcmVyLmhwcFx1MDAzZVxuI2luY2x1ZGUgXHUwMDNjbGV4eV9leHQvcmVwb3J0X2Vycm9yLmhwcFx1MDAzZVxuXG5uYW1lc3BhY2UgZHNsID0gbGV4eTo6ZHNsO1xuXG5zdHJ1Y3QgcHJvZHVjdGlvblxue1xuICAgIHN0YXRpYyBjb25zdGV4cHIgYXV0byBydWxlID0gZHNsOjppZGVudGlmaWVyKGRzbDo6YXNjaWk6OmFscGhhKTtcblxuICAgIHN0YXRpYyBjb25zdGV4cHIgYXV0byB2YWx1ZVxuICAgICAgICA9IGxleHk6OmFzX3N0cmluZ1x1MDAzY3N0ZDo6c3RyaW5nLCBsZXh5Ojphc2NpaV9lbmNvZGluZ1x1MDAzZS5jYXNlX2ZvbGRpbmcoZHNsOjphc2NpaTo6Y2FzZV9mb2xkaW5nKTtcbn07XG5cbmludCBtYWluKClcbntcbiAgICBhdXRvIGlucHV0ICA9IGxleHlfZXh0Ojpjb21waWxlcl9leHBsb3Jlcl9pbnB1dCgpO1xuICAgIGF1dG8gcmVzdWx0ID0gbGV4eTo6cGFyc2VcdTAwM2Nwcm9kdWN0aW9uXHUwMDNlKGlucHV0LCBsZXh5X2V4dDo6cmVwb3J0X2Vycm9yKTtcbiAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgcmV0dXJuIDE7XG5cbiAgICBzdGQ6OnByaW50ZihcIkNvZGVwb2ludDogJXMgKCV6dSBjb2RlIHVuaXRzKVxcblwiLCByZXN1bHQudmFsdWUoKS5jX3N0cigpLCByZXN1bHQudmFsdWUoKS5zaXplKCkpO1xufSJ9XX0=" , title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>production</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>identifier</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha</span><span class=p>);</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span>
        <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>as_string</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>lexy</span><span class=o>::</span><span class=n>ascii_encoding</span><span class=o>&gt;</span><span class=p>.</span><span class=n>case_folding</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>case_folding</span><span class=p>);</span>
<span class=p>};</span></code></pre></div></div></div></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use the character classes from <a href=/reference/dsl/ascii/#doc><code>lexy::dsl::ascii</code> </a> for simple identifier matching as seen in the example.</td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use the callback <a href=/reference/callback/string/#as_string><code>lexy::as_string</code> </a> to convert the <a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code> </a> to a string.</td></tr></tbody></table></div><div class=sect2><h3 id=_reserving_identifiers>Reserving identifiers</h3><div class=listingblock><div class=title><code>lexy/dsl/identifier.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>reserve</span><span class=p>(</span><span class=k>auto</span> <span class=p>...</span> <span class=n>rules</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span> <b class=conum>(1)</b>
<span class=k>constexpr</span> <span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>reserve_prefix</span><span class=p>(</span><span class=k>auto</span> <span class=p>...</span> <span class=n>rules</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span> <b class=conum>(2)</b>
<span class=k>constexpr</span> <span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>reserve_containing</span><span class=p>(</span><span class=k>auto</span> <span class=p>...</span> <span class=n>rules</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span> <b class=conum>(3)</b>
<span class=k>constexpr</span> <span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>reserve_suffix</span><span class=p>(</span><span class=k>auto</span> <span class=p>...</span> <span class=n>rules</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span> <b class=conum>(4)</b></code></pre></div></div><div class="paragraph lead"><p>Reserves an identifier.</p></div><div class=paragraph><p>Initially, no identifier is reserved.
Identifiers are reserved by calling <code>.reserve()</code> or its variants passing it a <a href=/reference/dsl/literal/#doc>literal rule</a> or <a href=/reference/dsl/literal/#literal_set><code>lexy::dsl::literal_set</code> </a>.
If this has happened, parsing the <code>identifier</code> rule creates a partial input from the lexeme and matches it against the specified rules as follows:</p></div><div class=ulist><ul><li><p>(1) <code>.reserve()</code>: All rules specified here are matched against the partial input.
If they match the entire partial input, the identifier is reserved.</p></li><li><p>(2) <code>.reserve_prefix()</code>: All rules specified here are matched against the partial input.
If they match a prefix of the partial input, the identifier is reserved.</p></li><li><p>(3) <code>.reserve_containing()</code>: All rules specified here are matched against the partial input.
If they match somewhere in the partial input, the identifier is reserved.</p></li><li><p>(4) <code>.reserve_suffix()</code>: All rules specified here are matched against the partial input.
If they match a suffix of the partial input, the identifier is reserved.</p></li></ul></div><div class=paragraph><p>If one <code>rule</code> passed to a <code>.reserve()</code> call or variant uses case folding (e.g. <a href=/reference/dsl/case_folding/#ascii><code>lexy::dsl::ascii::case_folding</code> </a>), all other rules in the same call also use that case folding, but not rules in a different call.
This is because internally each call creates a fresh <a href=/reference/dsl/literal/#literal_set><code>lexy::dsl::literal_set</code> </a>, which has that behavior.</p></div><div class=exampleblock><div class=title>Example 4. Parse a C like identifier that is not reserved</div><div class=content><div class="listingblock playground-example"><div class=title><a href="/playground?example=reserved_identifier&amp;mode=tree" title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>production</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=c1>// Define the general identifier syntax.</span>
        <span class=k>auto</span> <span class=n>head</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha_underscore</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>tail</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha_digit_underscore</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>id</span>   <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>identifier</span><span class=p>(</span><span class=n>head</span><span class=p>,</span> <span class=n>tail</span><span class=p>);</span>

        <span class=c1>// Define some keywords.</span>
        <span class=k>auto</span> <span class=n>kw_int</span>    <span class=o>=</span> <span class=n>LEXY_KEYWORD</span><span class=p>(</span><span class=s>&#34;int&#34;</span><span class=p>,</span> <span class=n>id</span><span class=p>);</span>
        <span class=k>auto</span> <span class=n>kw_struct</span> <span class=o>=</span> <span class=n>LEXY_KEYWORD</span><span class=p>(</span><span class=s>&#34;struct&#34;</span><span class=p>,</span> <span class=n>id</span><span class=p>);</span>
        <span class=c1>// ...</span>

        <span class=c1>// Parse an identifier</span>
        <span class=k>return</span> <span class=n>id</span>
            <span class=c1>// ... that is not a keyword,</span>
            <span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=n>kw_int</span><span class=p>,</span> <span class=n>kw_struct</span><span class=p>)</span>
            <span class=c1>// ... doesn&#39;t start with an underscore,</span>
            <span class=p>.</span><span class=n>reserve_prefix</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;_&#39;</span><span class=o>&gt;</span><span class=p>)</span>
            <span class=c1>// ... or contains a double underscore.</span>
            <span class=p>.</span><span class=n>reserve_containing</span><span class=p>(</span><span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;__&#34;</span><span class=p>));</span>
    <span class=p>}();</span>
<span class=p>};</span></code></pre></div></div></div></div><div class=exampleblock><div class=title>Example 5. Parse a C like identifier with case-insensitive keywords</div><div class=content><div class="listingblock playground-example"><div class=title><a href="/playground?example=reserved_identifier_case_folding&amp;mode=tree" title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>production</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=c1>// Define the general identifier syntax.</span>
        <span class=k>auto</span> <span class=n>head</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha_underscore</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>tail</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha_digit_underscore</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>id</span>   <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>identifier</span><span class=p>(</span><span class=n>head</span><span class=p>,</span> <span class=n>tail</span><span class=p>);</span>

        <span class=c1>// Define some case insensitive keywords.</span>
        <span class=k>auto</span> <span class=n>kw_int</span>    <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>case_folding</span><span class=p>(</span><span class=n>LEXY_KEYWORD</span><span class=p>(</span><span class=s>&#34;int&#34;</span><span class=p>,</span> <span class=n>id</span><span class=p>));</span>
        <span class=k>auto</span> <span class=n>kw_struct</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>case_folding</span><span class=p>(</span><span class=n>LEXY_KEYWORD</span><span class=p>(</span><span class=s>&#34;struct&#34;</span><span class=p>,</span> <span class=n>id</span><span class=p>));</span>
        <span class=c1>// ...</span>

        <span class=c1>// Parse an identifier that is not a keyword.</span>
        <span class=k>return</span> <span class=n>id</span><span class=p>.</span><span class=n>reserve</span><span class=p>(</span><span class=n>kw_int</span><span class=p>,</span> <span class=n>kw_struct</span><span class=p>);</span>
    <span class=p>}();</span>
<span class=p>};</span></code></pre></div></div></div></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>The <code>identifier</code> rule doesn’t magically learn about the keywords you have created.
They are only reserved if you actually pass them to <code>.reserve()</code>.
This design allows you to use a different set of reserved identifiers in different places in the grammar.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_token_rule_pattern>Token rule <code>.pattern()</code></h3><div class=listingblock><div class=title><code>lexy/dsl/identifier.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=n><em>token</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>pattern</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span></code></pre></div></div><div class="paragraph lead"><p><code>.pattern()</code> is a <a href=/reference/dsl/token/#doc>token rule</a> that matches the basic form of the identifier without checking for reserved identifiers.</p></div><div class=dlist><dl><dt class=hdlist1>Matching</dt><dd><p>Matches and consumes <code>leading</code>,
then matches and consumes <a href=/reference/dsl/loop/#while_><code>lexy::dsl::while_</code> </a><code>(trailing)</code>,
where <code>leading</code> and <code>trailing</code> are the arguments passed to <code>identifier()</code>.
Whitespace skipping is disabled inside the <code>pattern()</code>,
but it will be skipped after <code>pattern()</code>.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by matching <code>leading</code>.
The rule then fails.</p></dd><dt class=hdlist1>Parse tree</dt><dd><p>A single token node whose range covers everything consumed.
Its <a href=/reference/token/#predefined_token_kind><code>lexy::predefined_token_kind</code> </a> is <code>lexy::identifier_token_kind</code>.</p></dd></dl></div></div><div class=sect2><h3 id=_token_rules_leading_pattern_trailing_pattern>Token rules <code>.leading_pattern()</code>, <code>.trailing_pattern()</code></h3><div class=listingblock><div class=title><code>lexy/dsl/identifier.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=n><em>token</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>leading_pattern</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
<span class=k>constexpr</span> <span class=n><em>token</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>trailing_pattern</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span></code></pre></div></div><div class="paragraph lead"><p>They simply return <code>leading</code>/<code>trailing</code> from the arguments passed to <code>identifier()</code>.</p></div></div></div></div><div class=sect1><h2 id=keyword>Literal rule <code>lexy::dsl::keyword</code></h2><div class=sectionbody><div class=listingblock><div class=title><code>lexy/dsl/identifier.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>namespace</span> <span class=n>lexy</span><span class=o>::</span><span class=n>dsl</span>
<span class=p>{</span>
    <span class=k>template</span> <span class=o>&lt;</span><span class=k>auto</span> <span class=n>Char</span><span class=p>&gt;</span>
    <span class=k>constexpr</span> <span class=n><em>literal</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>keyword</span><span class=p>(</span><span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>identifier</span><span class=p>);</span>
    <span class=k>template</span> <span class=o>&lt;</span><span class=k>auto</span> <span class=n>Str</span><span class=p>&gt;</span>
    <span class=k>constexpr</span> <span class=n><em>literal</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>keyword</span><span class=p>(</span><span class=n><em>identifier</em></span><em><span class=o>-</span><span class=n>dsl</span></em> <span class=n>identifier</span><span class=p>);</span>
<span class=p>}</span>

<span class=cp>#define LEXY_KEYWORD(Str, Identifier) lexy::dsl::keyword&lt;Str&gt;(Identifier)</span></code></pre></div></div><div class="paragraph lead"><p><code>keyword</code> is a <a href=/reference/dsl/literal/#doc>literal rule</a> that matches a keyword.</p></div><div class=dlist><dl><dt class=hdlist1>Matching</dt><dd><p>Tries to match and consume <code>identifier.pattern()</code>,
i.e. the basic pattern of an identifier ignoring any reserved identifiers.
Then creates a partial input that covers everything just consumed (without the trailing whitespace)
and matches <a href=/reference/dsl/literal/#lit><code>lexy::dsl::lit</code> </a><code>&lt;Str></code> on that input.
Succeeds only if that consumes the entire partial input.</p></dd><dt class=hdlist1>Errors</dt><dd><p><a href=/reference/error/#expected_keyword><code>lexy::expected_keyword</code> </a>: if either <code>identifier.pattern()</code> or the <code>lit</code> rule failed.
Its range covers the everything consumed by <code>identifier.pattern()</code> and its <code>.string()</code> is <code>Str</code>.</p></dd><dt class=hdlist1>Parse tree</dt><dd><p>Single token node with the <a href=/reference/token/#predefined_token_kind><code>lexy::predefined_token_kind</code> </a> <code>lexy::literal_token_kind</code>.</p></dd></dl></div><div class=paragraph><p>The macro <code>LEXY_KEYWORD(Str, Identifier)</code> is equivalent to <code>keyword&lt;Str>(Identifier)</code>,
except that it also works on older compilers that do not support C++20’s extended NTTPs.
Use this instead of <code>keyword&lt;Str>(identifier)</code> if you need to support them.</p></div><div class=exampleblock><div class=title>Example 6. Parse a keyword</div><div class=content><div class="listingblock playground-example"><div class=title><a href="/playground?example=keyword&amp;mode=tree" title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>production</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=c1>// Define the general identifier syntax.</span>
        <span class=k>auto</span> <span class=n>head</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha_underscore</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>tail</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha_digit_underscore</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>id</span>   <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>identifier</span><span class=p>(</span><span class=n>head</span><span class=p>,</span> <span class=n>tail</span><span class=p>);</span>

        <span class=c1>// Parse a keyword.</span>
        <span class=k>return</span> <span class=n>LEXY_KEYWORD</span><span class=p>(</span><span class=s>&#34;int&#34;</span><span class=p>,</span> <span class=n>id</span><span class=p>);</span>
    <span class=p>}();</span>
<span class=p>};</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>While <a href=/reference/dsl/literal/#lit><code>lexy::dsl::lit</code> </a><code>&lt;"int"></code> would happily consume a prefix of <code>"integer"</code>, <code>keyword&lt;"int">(id)</code>, for a matching <code>id</code>, would not.</td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>A keyword does not necessarily need to be a reserved identifier or vice-versa.</td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The <a href=/reference/encoding/#doc>encoding</a> caveats of <a href=/reference/dsl/literal/#doc>literal rule</a>s apply here as well.</td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use <a href=/reference/dsl/case_folding/#ascii><code>lexy::dsl::ascii::case_folding</code> </a> or its Unicode variants to parse a case insensitive keyword.</td></tr></tbody></table></div></div></div></section><section id=see-also><h2>See also</h2><ul><li><a href=/reference/dsl/char_class/#doc>char class rules</a></li><li><a href=/reference/callback/string/#as_string><code>lexy::as_string</code></a></li><li><a href=/reference/dsl/ascii/#doc><code>lexy::dsl::ascii</code></a></li><li><a href=/reference/dsl/case_folding/#ascii><code>lexy::dsl::ascii::case_folding</code></a></li><li><a href=/reference/dsl/literal/#lit><code>lexy::dsl::lit</code></a></li><li><a href=/reference/dsl/literal/#literal_set><code>lexy::dsl::literal_set</code></a></li><li><a href=/reference/dsl/loop/#while_><code>lexy::dsl::while_</code></a></li><li><a href=/reference/error/#expected_keyword><code>lexy::expected_keyword</code></a></li><li><a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code></a></li><li><a href=/reference/token/#predefined_token_kind><code>lexy::predefined_token_kind</code></a></li><li><a href=/reference/dsl/literal/#doc>literal rules</a></li><li><a href=/reference/encoding/#doc>input encodings</a></li><li><a href=/reference/dsl/token/#doc>token rules</a></li></ul></section></article><datalist id=dsl-goto-data></datalist>
<script>window.addEventListener("load",async function(){var e=await(await fetch("/reference/index.json")).json(),n=document.getElementById("dsl-goto-data"),s=document.getElementById("dsl-goto-form"),t=document.getElementById("dsl-goto-search");for(let t in e){let s=document.createElement("option");t.startsWith("lexy_")?s.value=t.toUpperCase():s.value=t,n.appendChild(s)}s.addEventListener("submit",function(n){n.preventDefault();let s=e[t.value.toLowerCase()];return s?window.location.href=s:t.value="",!1})})</script></main><footer id=page-footer><section class=copyright>&copy; <a target=_blank href=https://github.com/foonathan/lexy/blob/main/LICENSE title=License>2020-2025 Jonathan Müller and lexy contributors</a></section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://fontawesome.com/license>Font Awesome</a>.</section></footer></body></html>