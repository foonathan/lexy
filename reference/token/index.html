<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>lexy/token.hpp â€” lexy</title><style>:root{--white:white;--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#202020;--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1250px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px;display:flex;justify-content:center}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a,a svg,button svg{color:var(--link-color);fill:var(--link-color);stroke:var(--link-color);transition:color ease .3s}a:hover,button:hover{color:var(--highlight-color)}a:hover svg,button:hover svg{color:var(--highlight-color);fill:var(--highlight-color);stroke:var(--highlight-color)}a:focus,button:focus{outline:none}br{margin:1em}article{flex:1;min-width:0}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a svg{height:1em}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home .title{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1100px){aside.toc{display:initial;position:sticky;top:0;min-width:200px;max-width:350px;padding-right:1em;align-self:flex-start;hyphens:auto}aside.toc header{margin-top:1em;font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.2em}aside.toc ul li{padding-bottom:.2em}aside.toc a{text-decoration:none}}article form svg,article a svg,article i svg{height:1em;position:relative;top:2px;padding-right:3px}article p svg:not(:first-child){padding-left:.25em}article header{margin-top:1em;margin-bottom:1em}article header nav{display:flex;flex-wrap:wrap}article header nav a{text-decoration:none;padding-right:7px}@media(min-width:700px){article header nav form.search{margin-left:auto}}article header nav form.search input[type=search]{padding:2px;width:250px}article header nav form.search input[type=search]:focus{border-color:var(--highlight-color);outline:solid var(--highlight-color)1px}article header nav form.search button[type=submit]{margin-left:-25px;border:none;background:initial}article .lead p{font-weight:500;font-size:1.1em}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{font-weight:700}article .admonitionblock td.content div:first-child p{margin-top:0}article .admonitionblock td.content div:last-child p{margin-bottom:0}@media(max-width:600px){article .admonitionblock tr{display:block;float:left;padding-left:.5em;padding-right:.5em}article .admonitionblock tr td{display:block}}@media(min-width:600px){article .admonitionblock td.icon{width:75px;text-align:center;border-right:1px solid var(--gray-highlight-color)}article .admonitionblock td.content{padding-left:.5em}}article .exampleblock{margin-top:1em;margin-bottom:1em}article .exampleblock .title{font-style:italic}article a.github-example{text-decoration:none}article a.github-example svg{height:.8em;position:relative;top:2px}article .playground-example .title,article .godbolt-example .title{position:relative}article .playground-example .title a,article .godbolt-example .title a{position:absolute;top:7px;right:7px}article .playground-example .title a svg,article .godbolt-example .title a svg{height:1em}article details{margin-bottom:1em}article details summary{font-style:italic}article ul p,article ol p{margin:.2em}article div ul:not(:first-child),article div ol:not(:first-child){margin-top:0}article dl dt{margin-top:.5em;font-weight:700}article dl dd p,article dl dd div:only-child ul{margin:0;padding:0}article div dl:not(:first-child){margin-top:0}article table.tableblock{background:var(--white);margin:0 auto;border-collapse:collapse}article table.tableblock td,article table.tableblock th{border:1px solid var(--gray-highlight-color);padding:5px;text-align:left}article table.tableblock td p,article table.tableblock th p{margin:0}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article code{font-family:Inconsolata,monospace,sans-serif}article pre{margin-top:0;overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}.highlight .c,.highlight .cm,.highlight .cp,.highlight .c1,.highlight .cs,.ace_editor .c,.ace_editor .cm,.ace_editor .cp,.ace_editor .c1,.ace_editor .cs{color:#998;font-style:italic;font-weight:initial}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kp,.highlight .kr,.highlight .kt,.highlight .ace_storage,.highlight .ace_keyword,.ace_editor .k,.ace_editor .kc,.ace_editor .kd,.ace_editor .kp,.ace_editor .kr,.ace_editor .kt,.ace_editor .ace_storage,.ace_editor .ace_keyword{color:#458;font-style:initial;font-weight:700}.highlight .o,.highlight .p,.highlight .ace_keyword.ace_operator,.highlight .ace_paren,.highlight .ace_punctuation,.ace_editor .o,.ace_editor .p,.ace_editor .ace_keyword.ace_operator,.ace_editor .ace_paren,.ace_editor .ace_punctuation{color:red;font-style:initial;font-weight:initial}.highlight .ace_dsl,.ace_editor .ace_dsl{pointer-events:auto}.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .ace_constant,.ace_editor .m,.ace_editor .mf,.ace_editor .mh,.ace_editor .mi,.ace_editor .mo,.ace_editor .ace_constant{color:#ff8000;font-style:initial;font-weight:initial}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .s3,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss,.highlight .se,.highlight .ace_string,.ace_editor .s,.ace_editor .sb,.ace_editor .sc,.ace_editor .sd,.ace_editor .s2,.ace_editor .s3,.ace_editor .sh,.ace_editor .si,.ace_editor .sx,.ace_editor .sr,.ace_editor .s1,.ace_editor .ss,.ace_editor .se,.ace_editor .ace_string{color:green;font-style:initial;font-weight:initial}.highlight .cp,.highlight .cpf,.ace_editor .cp,.ace_editor .cpf{color:green;font-style:initial;font-weight:700}.highlight .err,.highlight .ace_invalid,.ace_editor .err,.ace_editor .ace_invalid{color:red;font-style:initial;font-weight:initial}.highlight strong,.ace_editor strong{font-weight:initial}.highlight strong:not(:empty)::before,.ace_editor strong:not(:empty)::before{content:"*";color:red}.highlight strong:not(:empty)::after,.ace_editor strong:not(:empty)::after{content:"*";color:red}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/><span class=title>lexy:</span> C++ parsing DSL</a></li></ul><ul id=main><li><a href=/learn/>Learn</a></li><li><a href=/reference/>Reference</a></li><li><a href=/playground/>Playground</a></li><li><a href=/download/>Download</a></li><li><a href=https://github.com/foonathan/lexy title=GitHub><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li></ul></div></nav><main><aside class=toc><header><a href=#>Table of Contents</a></header></aside><article id=doc><header><h1>Header <code>lexy/token.hpp</code></h1><nav><a href=https://github.com/foonathan/lexy/blob/main/include/lexy/token.hpp><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> View source
</a><a href="https://github.com/foonathan/lexy/issues/new?title=lexy%2ftoken.hpp"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bug" class="svg-inline--fa fa-bug fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M511.988 288.9c-.478 17.43-15.217 31.1-32.653 31.1H424v16c0 21.864-4.882 42.584-13.6 61.145l60.228 60.228c12.496 12.497 12.496 32.758.0 45.255-12.498 12.497-32.759 12.496-45.256.0l-54.736-54.736C345.886 467.965 314.351 480 280 480V236c0-6.627-5.373-12-12-12h-24c-6.627.0-12 5.373-12 12v244c-34.351.0-65.886-12.035-90.636-32.108l-54.736 54.736c-12.498 12.497-32.759 12.496-45.256.0-12.496-12.497-12.496-32.758.0-45.255l60.228-60.228C92.882 378.584 88 357.864 88 336v-16H32.666C15.23 320 .491 306.33.013 288.9-.484 270.816 14.028 256 32 256h56v-58.745l-46.628-46.628c-12.496-12.497-12.496-32.758.0-45.255 12.498-12.497 32.758-12.497 45.256.0L141.255 160h229.489l54.627-54.627c12.498-12.497 32.758-12.497 45.256.0 12.496 12.497 12.496 32.758.0 45.255L424 197.255V256h56c17.972.0 32.484 14.816 31.988 32.9zM257 0c-61.856.0-112 50.144-112 112h224C369 50.144 318.856.0 257 0z"/></svg> Report an issue
</a><a href=https://github.com/foonathan/lexy/edit/main/docs/content/reference/token.adoc><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="edit" class="svg-inline--fa fa-edit fa-w-18" role="img" viewBox="0 0 576 512"><path fill="currentcolor" d="M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8.0zm162-22.9-48.8-48.8c-15.2-15.2-39.9-15.2-55.2.0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8.0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2.0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5.0 112v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"/></svg> Edit this page</a><form class=search id=dsl-goto-form><input type=search id=dsl-goto-search placeholder="Go to..." list=dsl-goto-data autocomplete=off>
<button type=submit title=Go><svg viewBox="0 0 448 512"><path d="M438.6 278.6c12.5-12.5 12.5-32.8.0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3.0s-12.5 32.8.0 45.3L338.8 224H32c-17.7.0-32 14.3-32 32s14.3 32 32 32h306.7L233.4 393.4c-12.5 12.5-12.5 32.8.0 45.3s32.8 12.5 45.3.0l160-160z"/></svg></button></form></nav></header><section><div class="paragraph lead"><p>Identifying and storing tokens of the input.</p></div><div class=sect1><h2 id=predefined_token_kind>Enum <code>lexy::predefined_token_kind</code></h2><div class=sectionbody><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>namespace</span> <span class=n>lexy</span>
<span class=p>{</span>
    <span class=k>enum</span> <span class=n>predefined_token_kind</span>
    <span class=p>{</span>
        <span class=n>unknown_token_kind</span><span class=p>,</span>

        <span class=n>error_token_kind</span><span class=p>,</span>
        <span class=n>whitespace_token_kind</span><span class=p>,</span>
        <span class=n>any_token_kind</span><span class=p>,</span>

        <span class=n>literal_token_kind</span><span class=p>,</span>
        <span class=n>position_token_kind</span><span class=p>,</span>
        <span class=n>eof_token_kind</span><span class=p>,</span>

        <span class=n>identifier_token_kind</span><span class=p>,</span>
        <span class=n>digits_token_kind</span><span class=p>,</span>
    <span class=p>};</span>
<span class=p>}</span></code></pre></div></div><div class="paragraph lead"><p>Predefined token kinds for special token rules, as given in the table below.</p></div><details><summary class=title>The predefined token kinds</summary><div class=content><table class="tableblock frame-all grid-all stretch"><col style=width:50%><col style=width:50%><thead><tr><th class="tableblock halign-left valign-top">Token Kind</th><th class="tableblock halign-left valign-top">Token Rule</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>lexy::unknown_token_kind</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>all token rules by default</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>lexy::error_token_kind</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock>tokens produced during the "discard input" phase of error recovery, e.g. by <a href=/reference/dsl/recover/#find><code>lexy::dsl::find</code>Â </a> or <a href=/reference/dsl/recover/#recover><code>lexy::dsl::recover</code>Â </a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>lexy::whitespace_token_kind</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=/reference/dsl/whitespace/#whitespace><code>lexy::dsl::whitespace</code>Â </a> (not actually a token rule)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>lexy::any_token_kind</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=/reference/dsl/any/#any><code>lexy::dsl::any</code>Â </a>, <a href=/reference/dsl/code_point/#code_point><code>lexy::dsl::code_point</code>Â </a> (without predicate), <a href=/reference/dsl/until/#until><code>lexy::dsl::until</code>Â </a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>lexy::literal_token_kind</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=/reference/dsl/literal/#lit><code>lexy::dsl::lit</code>Â </a>, <a href=/reference/dsl/code_point/#code_point><code>lexy::dsl::code_point</code>Â </a> (literal version), and other tokens that are fully identified by their spelling</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>lexy::position_token_kind</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=/reference/dsl/position/#position><code>lexy::dsl::position</code>Â </a> (not actually a token rule)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>lexy::eof_token_kind</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=/reference/dsl/eof/#eof><code>lexy::dsl::eof</code>Â </a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>lexy::identifier_token_kind</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=/reference/dsl/identifier/#identifier><code>lexy::dsl::identifier</code>Â </a> and <a href=/reference/dsl/symbol/#symbol><code>lexy::dsl::symbol</code>Â </a></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock><code>lexy::digits_token_kind</code></p></td><td class="tableblock halign-left valign-top"><p class=tableblock><a href=/reference/dsl/digit/#digit><code>lexy::dsl::digit</code>Â </a>, <a href=/reference/dsl/digit/#digits><code>lexy::dsl::digits</code>Â </a>, and other rules parsing digits</p></td></tr></tbody></table></div></details></div></div><div class=sect1><h2 id=token_kind>Class <code>lexy::token_kind</code></h2><div class=sectionbody><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>namespace</span> <span class=n>lexy</span>
<span class=p>{</span>
    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=nc>TokenKind</span> <span class=o>=</span> <span class=kt>void</span><span class=p>&gt;</span>
    <span class=k>class</span> <span class=nc>token_kind</span>
    <span class=p>{</span>
        <span class=k>using</span> <span class=n><em>underlying</em></span><em><span class=o>-</span><span class=n>type</span></em>
          <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>conditional_t</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>is_void_v</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>TokenKind</span><span class=o>&gt;</span><span class=p>;</span>

    <span class=nl>public:</span>
        <span class=c1>//=== constructors ===//</span>
        <span class=k>constexpr</span> <span class=n>token_kind</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>;</span>
        <span class=k>constexpr</span> <span class=n>token_kind</span><span class=p>(</span><span class=n>predefined_token_kind</span> <span class=n>value</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=k>constexpr</span> <span class=n>token_kind</span><span class=p>(</span><span class=n><em>underlying</em></span><em><span class=o>-</span><span class=n>type</span></em> <span class=n>value</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=k>constexpr</span> <span class=n>token_kind</span><span class=p>(</span><span class=n><em>token</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>token_rule</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=c1>//== access ===//</span>
        <span class=k>constexpr</span> <span class=k>explicit</span> <span class=k>operator</span> <span class=kt>bool</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
        <span class=k>constexpr</span> <span class=kt>bool</span> <span class=n>is_predefined</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
        <span class=k>constexpr</span> <span class=kt>bool</span> <span class=n>ignore_if_empty</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=k>constexpr</span> <span class=n><em>underlying</em></span><em><span class=o>-</span><span class=n>type</span></em> <span class=n>get</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=k>constexpr</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=k>static</span> <span class=k>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=kt>uint_least16_t</span> <span class=n>to_raw</span><span class=p>(</span><span class=n>token_kind</span> <span class=n>kind</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
        <span class=k>static</span> <span class=k>constexpr</span> <span class=n>token_kind</span> <span class=n>from_raw</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=kt>uint_least16_t</span> <span class=n>kind</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=k>friend</span> <span class=k>constexpr</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=n>token_kind</span> <span class=n>lhs</span><span class=p>,</span> <span class=n>token_kind</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
        <span class=k>friend</span> <span class=k>constexpr</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>!=</span><span class=p>(</span><span class=n>token_kind</span> <span class=n>lhs</span><span class=p>,</span> <span class=n>token_kind</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
    <span class=p>};</span>
<span class=p>}</span></code></pre></div></div><div class="paragraph lead"><p>Identifies a <a href=/reference/dsl/token/#doc><code>token-rule</code>Â </a>.</p></div><div class=paragraph><p>It either stores a <code>lexy::predefined_token_kind</code> or a user-defined token kind given by <code>TokenKind</code>.
If <code>TokenKind</code> is <code>void</code> (the default), the assumes a user-defined token type is <code>int</code>.
Otherwise, <code>TokenKind</code> must be an enumeration type.</p></div><div class=paragraph><p>Token rules are associated with their kind using <a href=/reference/dsl/token/#kind><code>.kind</code>Â </a> or by specializing <a href=/reference/token/#token_kind_map><code>lexy::token_kind_map_for</code>Â </a>.
Some token rules that require special behavior in the parse tree have a <a href=/reference/token/#predefined_token_kind><code>lexy::predefined_token_kind</code>Â </a>.
For all others, the token kind is unknown by default.</p></div><div class=paragraph><p>Internally, all values are stored as a <code>std::uint_least16_t</code>.</p></div><div class=sect2><h3 id=_constructors>Constructors</h3><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=nf>token_kind</span><span class=p>()</span> <span class=k>noexcept</span>
<span class=o>:</span> <span class=n>token_kind</span><span class=p>(</span><span class=n>lexy</span><span class=o>::</span><span class=n>unknown_token_kind</span><span class=p>)</span>
<span class=p>{}</span>

<span class=k>constexpr</span> <span class=n>token_kind</span><span class=p>(</span><span class=n>predefined_token_kind</span> <span class=n>value</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Initialize with the given <a href=/reference/token/#predefined_token_kind><code>lexy::predefined_token_kind</code>Â </a>.</p></div><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=n>token_kind</span><span class=p>(</span><span class=n><em>underlying</em></span><em><span class=o>-</span><span class=n>type</span></em> <span class=n>value</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>

<span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=nc>T</span><span class=p>&gt;</span>
    <span class=k>requires</span> <span class=n>std</span><span class=o>::</span><span class=n>is_enum_v</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span>
<span class=n>token_kind</span><span class=p>(</span><span class=n>T</span> <span class=n>value</span><span class=p>)</span>                  <span class=o>-&gt;</span> <span class=n>token_kind</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span>
<span class=n>token_kind</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>integral</span> <span class=k>auto</span> <span class=n>value</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>token_kind</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Initialize with the given user-defined token kind.
If <code>TokenKind</code> is <code>void</code>, it accepts an <code>int</code>, otherwise <code>TokenKind</code> itself.
<code>value</code> must fit in a 15bit unsigned integer.</p></div><div class=paragraph><p>If CTAD is used and the argument is an integer, deduces <code>void</code> for <code>TokenKind</code>.
Otherwise, deduces the specified information type.</p></div><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=n>token_kind</span><span class=p>(</span><span class=n><em>token</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>token_rule</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Initialize with the token kind of the given <a href=/reference/dsl/token/#doc>token rule</a>.</p></div><div class=paragraph><p>This is determined as follows:</p></div><div class="olist arabic"><ol class=arabic><li><p>If <a href=/reference/token/#token_kind_map><code>lexy::token_kind_map_for</code>Â </a> instantiated with <code>TokenKind</code> contains a token kind for <code>token_rule</code>, uses that.</p></li><li><p>Otherwise, if <code>token_rule</code> has been assigned a <a href=/reference/token/#predefined_token_kind><code>lexy::predefined_token_kind</code>Â </a> by lexy, uses that.</p></li><li><p>Otherwise, if <code>token_rule</code> has been assigned a user-defined token kind by <a href=/reference/dsl/token/#kind><code>.kind</code>Â </a>,
whose type is compatible, uses that.
If <code>TokenKind == void</code>, a user-defined token kind is compatible if it is an integral value;
else, a user-defined token kind is compatible if it has the same enumeration type.</p></li><li><p>Otherwise, uses <code>lexy::unknown_token_kind</code>.</p></li></ol></div><div class=paragraph><p>Cases 2 and 3 are subject to the same range restrictions as the constructor that takes a user-defined value directly.</p></div></div><div class=sect2><h3 id=_access>Access</h3><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=k>explicit</span> <span class=k>operator</span> <span class=kt>bool</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span> <b class=conum>(1)</b>

<span class=k>constexpr</span> <span class=kt>bool</span> <span class=n>is_predefined</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>     <b class=conum>(2)</b>

<span class=k>constexpr</span> <span class=kt>bool</span> <span class=n>ignore_if_empty</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>   <b class=conum>(3)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>true</code> if the token kind is not <code>lexy::unknown_token_kind</code>, <code>false</code> otherwise.</p></li><li><p>Returns <code>true</code> if the token kind is user-defined (including unknown), <code>false</code> otherwise.</p></li><li><p>Returns <code>true</code> if an empty token of that kind should be ignored by <a href=/reference/parse_tree/#parse_tree><code>lexy::parse_tree</code>Â </a> and related, <code>false</code> otherwise.
It currently returns <code>true</code> for <code>lexy::unknown_token_kind</code>, <code>lexy::error_token_kind</code>, <code>lexy::whitespace_token_kind</code>.</p></li></ol></div><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=n><em>underlying</em></span><em><span class=o>-</span><span class=n>type</span></em> <span class=n>get</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Returns the value of the token kind.</p></div><div class=paragraph><p>If <code>TokenKind</code> is <code>void</code>, the return type is <code>int</code>.
Otherwise, it is <code>TokenKind</code>.</p></div><div class=paragraph><p>If the token kind is user-defined, returns its value unchanged.
If the token kind is predefined, returns an implementation defined value.
This value is guaranteed to uniquely identify the predefined token kind and distinguish it from all user-defined token types,
but it must not be passed to the constructor taking a user-defined token kind.</p></div><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span></code></pre></div></div><div class=paragraph><p>Returns the name of the token kind.</p></div><div class=paragraph><p>If the token kind is <code>lexy::unknown_token_kind</code>, the name is <code>"token"</code>.
If the token kind is some other predefined token kind, the name is a nice version of the enumeration name (e.g. <code>"EOF"</code> for <code>lexy::eof_token_kind</code>).
If the token kind is user-defined and the ADL call <code>token_kind_name(get())</code> resolves to a <code>const char*</code>, returns that.
Otherwise, returns <code>"token"</code> for user-defined token kinds.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>ADL only works if the <code>TokenKind</code> is an enumeration and not <code>void</code>.</td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=token_kind_map><code>lexy::token_kind_map</code></h2><div class=sectionbody><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>namespace</span> <span class=n>lexy</span>
<span class=p>{</span>
    <span class=k>class</span> <span class=nc><em>token</em></span><em><span class=o>-</span><span class=n>kind</span><span class=o>-</span><span class=n>map</span></em>
    <span class=p>{</span>
    <span class=nl>public:</span>
        <span class=k>template</span> <span class=o>&lt;</span><span class=k>auto</span> <span class=n>TokenKind</span><span class=p>&gt;</span>
        <span class=k>consteval</span> <span class=n><em>token</em></span><em><span class=o>-</span><span class=n>kind</span><span class=o>-</span><span class=n>map</span></em> <span class=n>map</span><span class=p>(</span><span class=n><em>token</em></span><em><span class=o>-</span><span class=n>rule</span></em> <span class=k>auto</span> <span class=n>token_rule</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
    <span class=p>};</span>

    <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>token_kind_map</span> <span class=o>=</span> <span class=n><em>token</em></span><em><span class=o>-</span><span class=n>kind</span><span class=o>-</span><span class=n>map</span></em><span class=p>();</span>

    <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=nc>TokenKind</span><span class=p>&gt;</span>
    <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>token_kind_map_for</span> <span class=o>=</span> <span class=n>token_kind_map</span><span class=p>;</span>
<span class=p>}</span></code></pre></div></div><div class="paragraph lead"><p>Defines a compile-time mapping of <a href=/reference/dsl/token/#doc>token rule</a>s to a user-defined <code>TokenKind</code> enum.</p></div><div class=paragraph><p>It is initially empty.
A mapping is added by calling <code>.map()</code> which associates <code>TokenKind</code> with the <code>token_rule</code>;
its result is a map that contains this mapping in addition to all previous mappings.
<code>TokenKind</code> must always have the same type.</p></div><div class=paragraph><p>The mapping is associated with the user-defined <code>TokenKind</code> enum by specializing <code>token_kind_map_for</code>;
the default specialization is the empty mapping for all token kinds.
This specialization is used by the <a href=/reference/token/#token_kind><code>lexy::token_kind</code>Â </a> constructor that takes a token rule.</p></div><div class=exampleblock><div class=title>Example 1. Associate custom token kinds with the default playground example</div><div class=content><div class="listingblock godbolt-example"><div class=title><a href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbXSwiZXhlY3V0b3JzIjpbeyJjb21waWxlciI6eyJpZCI6ImNsYW5nX3RydW5rIiwibGlicyI6W3siaWQiOiJsZXh5IiwidmVyc2lvbiI6InRydW5rIn1dLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9LCJzdGRpbiI6IkhlbGxvIFdvcmxkISIsInN0ZGluVmlzaWJsZSI6dHJ1ZX1dLCJpZCI6MSwibGFuZ3VhZ2UiOiJjKysiLCJzb3VyY2UiOiIjaW5jbHVkZSBcdTAwM2NsZXh5L2FjdGlvbi9wYXJzZV9hc190cmVlLmhwcFx1MDAzZVxuI2luY2x1ZGUgXHUwMDNjbGV4eS9kc2wuaHBwXHUwMDNlXG4jaW5jbHVkZSBcdTAwM2NsZXh5L3Zpc3VhbGl6ZS5ocHBcdTAwM2VcbiNpbmNsdWRlIFx1MDAzY2xleHlfZXh0L2NvbXBpbGVyX2V4cGxvcmVyLmhwcFx1MDAzZVxuI2luY2x1ZGUgXHUwMDNjbGV4eV9leHQvcmVwb3J0X2Vycm9yLmhwcFx1MDAzZVxuXG5uYW1lc3BhY2UgZHNsID0gbGV4eTo6ZHNsO1xuXG5zdHJ1Y3QgbmFtZVxue1xuICAgIHN0YXRpYyBjb25zdGV4cHIgYXV0byBydWxlXG4gICAgICAgIC8vIE9uZSBvciBtb3JlIGFscGhhIG51bWVyaWMgY2hhcmFjdGVycywgdW5kZXJzY29yZXMgb3IgaHlwaGVucy5cbiAgICAgICAgPSBkc2w6OmlkZW50aWZpZXIoZHNsOjphc2NpaTo6YWxudW0gLyBkc2w6OmxpdF9jXHUwMDNjJ18nXHUwMDNlIC8gZHNsOjpsaXRfY1x1MDAzYyctJ1x1MDAzZSk7XG59O1xuXG5zdHJ1Y3QgcHJvZHVjdGlvblxue1xuICAgIC8vIEFsbG93IGFyYml0cmFyeSBzcGFjZXMgYmV0d2VlbiBpbmRpdmlkdWFsIHRva2Vucy5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpbmNsdWRlcyB0aGUgaW5kaXZpZHVhbCBjaGFyYWN0ZXJzIG9mIHRoZSBuYW1lLlxuICAgIHN0YXRpYyBjb25zdGV4cHIgYXV0byB3aGl0ZXNwYWNlID0gZHNsOjphc2NpaTo6c3BhY2U7XG5cbiAgICBzdGF0aWMgY29uc3RleHByIGF1dG8gcnVsZSA9IFtdIHtcbiAgICAgICAgYXV0byBncmVldGluZyA9IExFWFlfTElUKFwiSGVsbG9cIik7XG4gICAgICAgIHJldHVybiBncmVldGluZyArIGRzbDo6cFx1MDAzY25hbWVcdTAwM2UgKyBkc2w6OmV4Y2xhbWF0aW9uX21hcmsgKyBkc2w6OmVvZjtcbiAgICB9KCk7XG59O1xuXG5lbnVtIGNsYXNzIG15X3Rva2VuX2tpbmRcbntcbiAgICBncmVldGluZyxcbiAgICBleGNsYW1hdGlvbl9tYXJrLFxufTtcblxudGVtcGxhdGUgXHUwMDNjXHUwMDNlXG5jb25zdGV4cHIgYXV0byBsZXh5Ojp0b2tlbl9raW5kX21hcF9mb3JcdTAwM2NteV90b2tlbl9raW5kXHUwMDNlXG4gICAgLy8gU3RhcnQgd2l0aCB0aGUgZW1wdHkgbWFwLlxuICAgID0gbGV4eTo6dG9rZW5fa2luZF9tYXBcbiAgICAgICAgICAvLyBNYXAgdGhlIGdyZWV0aW5nIHRva2VuLlxuICAgICAgICAgIC5tYXBcdTAwM2NteV90b2tlbl9raW5kOjpncmVldGluZ1x1MDAzZShMRVhZX0xJVChcIkhlbGxvXCIpKVxuICAgICAgICAgIC8vIE1hcCB0aGUgZXhjbGFtYXRpb24gdG9rZW4uXG4gICAgICAgICAgLm1hcFx1MDAzY215X3Rva2VuX2tpbmQ6OmV4Y2xhbWF0aW9uX21hcmtcdTAwM2UoZHNsOjpleGNsYW1hdGlvbl9tYXJrKTtcblxuY29uc3QgY2hhciogdG9rZW5fa2luZF9uYW1lKG15X3Rva2VuX2tpbmQga2luZClcbntcbiAgICBzd2l0Y2ggKGtpbmQpXG4gICAge1xuICAgIGNhc2UgbXlfdG9rZW5fa2luZDo6Z3JlZXRpbmc6XG4gICAgICAgIHJldHVybiBcImdyZWV0aW5nXCI7XG4gICAgY2FzZSBteV90b2tlbl9raW5kOjpleGNsYW1hdGlvbl9tYXJrOlxuICAgICAgICByZXR1cm4gXCJleGNsYW1hdGlvbl9tYXJrXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCI7XG59XG5cbmludCBtYWluKClcbntcbiAgICBhdXRvIGlucHV0ID0gbGV4eV9leHQ6OmNvbXBpbGVyX2V4cGxvcmVyX2lucHV0KCk7XG5cbiAgICAvLyBOZWVkIHRvIHNwZWNpZnkgdGhlIHRva2VuIGtpbmQgd2Ugd2FudCBoZXJlLlxuICAgIGxleHk6OnBhcnNlX3RyZWVfZm9yXHUwMDNjZGVjbHR5cGUoaW5wdXQpLCBteV90b2tlbl9raW5kXHUwMDNlIHRyZWU7XG4gICAgYXV0byByZXN1bHQgPSBsZXh5OjpwYXJzZV9hc190cmVlXHUwMDNjcHJvZHVjdGlvblx1MDAzZSh0cmVlLCBpbnB1dCwgbGV4eV9leHQ6OnJlcG9ydF9lcnJvcik7XG5cbiAgICBsZXh5Ojp2aXN1YWxpemUoc3Rkb3V0LCB0cmVlLCB7bGV4eTo6dmlzdWFsaXplX2ZhbmN5fSk7XG5cbiAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgcmV0dXJuIDE7XG59In1dfQ==" , title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>enum</span> <span class=k>class</span> <span class=nc>my_token_kind</span>
<span class=p>{</span>
    <span class=n>greeting</span><span class=p>,</span>
    <span class=n>exclamation_mark</span><span class=p>,</span>
<span class=p>};</span>

<span class=k>template</span> <span class=o>&lt;</span><span class=p>&gt;</span>
<span class=k>constexpr</span> <span class=k>auto</span> <span class=n>lexy</span><span class=o>::</span><span class=n>token_kind_map_for</span><span class=o>&lt;</span><span class=n>my_token_kind</span><span class=o>&gt;</span>
    <span class=c1>// Start with the empty map.</span>
    <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>token_kind_map</span>
          <span class=c1>// Map the greeting token.</span>
          <span class=p>.</span><span class=n>map</span><span class=o>&lt;</span><span class=n>my_token_kind</span><span class=o>::</span><span class=n>greeting</span><span class=o>&gt;</span><span class=p>(</span><span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>))</span>
          <span class=c1>// Map the exclamation token.</span>
          <span class=p>.</span><span class=n>map</span><span class=o>&lt;</span><span class=n>my_token_kind</span><span class=o>::</span><span class=n>exclamation_mark</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>exclamation_mark</span><span class=p>);</span></code></pre></div></div></div></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>Token rules are identified based on type.
If two token rules are equivalent but have different types, theyâ€™re token kind is not going to be picked up.</td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>It is usually better to specify the token kind inline in the grammar using <a href=/reference/dsl/token/#kind><code>.kind</code>Â </a>.</td></tr></tbody></table></div></div></div><div class=sect1><h2 id=token>Class <code>lexy::token</code></h2><div class=sectionbody><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>namespace</span> <span class=n>lexy</span>
<span class=p>{</span>
    <span class=k>template</span> <span class=o>&lt;</span><span class=n><em>reader</em></span> <span class=n>Reader</span><span class=p>,</span> <span class=k>typename</span> <span class=nc>TokenKind</span> <span class=o>=</span> <span class=kt>void</span><span class=p>&gt;</span>
    <span class=k>class</span> <span class=nc>token</span>
    <span class=p>{</span>
    <span class=nl>public:</span>
        <span class=k>using</span> <span class=n>encoding</span>  <span class=o>=</span> <span class=k>typename</span> <span class=n>Reader</span><span class=o>::</span><span class=n>encoding</span><span class=p>;</span>
        <span class=k>using</span> <span class=n>char_type</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>encoding</span><span class=o>::</span><span class=n>char_type</span><span class=p>;</span>
        <span class=k>using</span> <span class=n>iterator</span>  <span class=o>=</span> <span class=k>typename</span> <span class=n>Reader</span><span class=o>::</span><span class=n>iterator</span><span class=p>;</span>

        <span class=c1>//=== constructors ===//</span>
        <span class=k>explicit</span> <span class=k>constexpr</span> <span class=n>token</span><span class=p>(</span><span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>kind</span><span class=p>,</span>
                                 <span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span> <span class=n>lexeme</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
        <span class=k>explicit</span> <span class=k>constexpr</span> <span class=n>token</span><span class=p>(</span><span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>kind</span><span class=p>,</span>
                                 <span class=n>iterator</span> <span class=n>begin</span><span class=p>,</span> <span class=n>iterator</span> <span class=n>end</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=c1>//=== access ===//</span>
        <span class=k>constexpr</span> <span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>kind</span><span class=p>()</span>   <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
        <span class=k>constexpr</span> <span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span>  <span class=n>lexeme</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=k>constexpr</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span>
        <span class=p>{</span>
            <span class=k>return</span> <span class=n>kind</span><span class=p>().</span><span class=n>name</span><span class=p>();</span>
        <span class=p>}</span>

        <span class=k>constexpr</span> <span class=n>iterator</span> <span class=n>position</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span>
        <span class=p>{</span>
            <span class=k>return</span> <span class=n>lexeme</span><span class=p>().</span><span class=n>begin</span><span class=p>();</span>
        <span class=p>}</span>
    <span class=p>};</span>

    <span class=k>template</span> <span class=o>&lt;</span><span class=n><em>input</em></span> <span class=n>Input</span><span class=p>,</span> <span class=k>typename</span> <span class=nc>TokenKind</span> <span class=o>=</span> <span class=kt>void</span><span class=p>&gt;</span>
    <span class=k>using</span> <span class=n>token_for</span> <span class=o>=</span> <span class=n>token</span><span class=o>&lt;</span><span class=n>input_reader</span><span class=o>&lt;</span><span class=n>Input</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>TokenKind</span><span class=o>&gt;</span><span class=p>;</span>
<span class=p>}</span></code></pre></div></div><div class="paragraph lead"><p>Stores a token as a pair of <a href=/reference/token/#token_kind><code>lexy::token_kind</code>Â </a> and <a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code>Â </a>.</p></div><div class=paragraph><p>A <em>token</em> is not to be confused with a <a href=/reference/dsl/token/#doc>token rule</a>:
the latter describes what sort of input constitutes a token (e.g. a sequence of decimal digits or the keyword <code>int</code>),
while the former is the concrete realization of the rule (e.g. the number <code>123</code> at offset 10, or the keyword <code>int</code> at offset 23).</p></div><div class=sect2><h3 id=_constructors_2>Constructors</h3><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>explicit</span> <span class=k>constexpr</span> <span class=n>token</span><span class=p>(</span><span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>kind</span><span class=p>,</span>
                         <span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span> <span class=n>lexeme</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
<span class=k>explicit</span> <span class=k>constexpr</span> <span class=n>token</span><span class=p>(</span><span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>kind</span><span class=p>,</span>
                         <span class=n>iterator</span> <span class=n>begin</span><span class=p>,</span> <span class=n>iterator</span> <span class=n>end</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>

<span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=nc>TokenKind</span><span class=p>,</span> <span class=k>typename</span> <span class=nc>Reader</span><span class=p>&gt;</span>
<span class=n>token</span><span class=p>(</span><span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>token</span><span class=o>&lt;</span><span class=n>Reader</span><span class=p>,</span> <span class=n>TokenKind</span><span class=o>&gt;</span><span class=p>;</span>
<span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=nc>T</span><span class=p>,</span> <span class=k>typename</span> <span class=nc>Reader</span><span class=p>&gt;</span>
    <span class=k>requires</span> <span class=n>std</span><span class=o>::</span><span class=n>is_enum_v</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span>
<span class=n>token</span><span class=p>(</span><span class=n>T</span> <span class=n>kind</span><span class=p>,</span> <span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>token</span><span class=o>&lt;</span><span class=n>Reader</span><span class=p>,</span> <span class=n>T</span><span class=o>&gt;</span><span class=p>;</span>
<span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=nc>T</span><span class=p>,</span> <span class=k>typename</span> <span class=nc>Reader</span><span class=p>&gt;</span>
<span class=n>token</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>integral</span> <span class=k>auto</span> <span class=n>kind</span><span class=p>,</span> <span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>token</span><span class=o>&lt;</span><span class=n>Reader</span><span class=p>,</span> <span class=kt>void</span><span class=o>&gt;</span><span class=p>;</span></code></pre></div></div><div class="paragraph lead"><p>Constructs the token from <code>kind</code> and <code>lexeme</code>.</p></div><div class=paragraph><p>If CTAD is used, the arguments can be deduced for the first overload.</p></div></div></div></div></section><section id=see-also><h2>See also</h2><ul><li><a href=/reference/dsl/token/#kind><code>.kind</code></a></li><li><a href=/reference/dsl/any/#any><code>lexy::dsl::any</code></a></li><li><a href=/reference/dsl/code_point/#code_point><code>lexy::dsl::code_point</code></a></li><li><a href=/reference/dsl/digit/#digit><code>lexy::dsl::digit</code></a></li><li><a href=/reference/dsl/digit/#digits><code>lexy::dsl::digits</code></a></li><li><a href=/reference/dsl/eof/#eof><code>lexy::dsl::eof</code></a></li><li><a href=/reference/dsl/recover/#find><code>lexy::dsl::find</code></a></li><li><a href=/reference/dsl/identifier/#identifier><code>lexy::dsl::identifier</code></a></li><li><a href=/reference/dsl/literal/#lit><code>lexy::dsl::lit</code></a></li><li><a href=/reference/dsl/position/#position><code>lexy::dsl::position</code></a></li><li><a href=/reference/dsl/recover/#recover><code>lexy::dsl::recover</code></a></li><li><a href=/reference/dsl/symbol/#symbol><code>lexy::dsl::symbol</code></a></li><li><a href=/reference/dsl/until/#until><code>lexy::dsl::until</code></a></li><li><a href=/reference/dsl/whitespace/#whitespace><code>lexy::dsl::whitespace</code></a></li><li><a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code></a></li><li><a href=/reference/parse_tree/#parse_tree><code>lexy::parse_tree</code></a></li><li><a href=/reference/dsl/token/#doc>token rules</a></li><li><a href=/reference/dsl/token/#doc><code>token-rule</code></a></li></ul></section></article><datalist id=dsl-goto-data></datalist>
<script>window.addEventListener("load",async function(){var e=await(await fetch("/reference/index.json")).json(),n=document.getElementById("dsl-goto-data"),s=document.getElementById("dsl-goto-form"),t=document.getElementById("dsl-goto-search");for(let t in e){let s=document.createElement("option");t.startsWith("lexy_")?s.value=t.toUpperCase():s.value=t,n.appendChild(s)}s.addEventListener("submit",function(n){n.preventDefault();let s=e[t.value.toLowerCase()];return s?window.location.href=s:t.value="",!1})})</script></main><footer id=page-footer><section class=copyright>&copy; <a target=_blank href=https://github.com/foonathan/lexy/blob/main/LICENSE title=License>2020-2025 Jonathan MÃ¼ller and lexy contributors</a></section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://fontawesome.com/license>Font Awesome</a>.</section></footer></body></html>