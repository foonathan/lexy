<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>lexy/parse_tree.hpp — lexy</title><style>:root{--white:white;--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#202020;--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1250px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px;display:flex;justify-content:center}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a,a svg,button svg{color:var(--link-color);fill:var(--link-color);stroke:var(--link-color);transition:color ease .3s}a:hover,button:hover{color:var(--highlight-color)}a:hover svg,button:hover svg{color:var(--highlight-color);fill:var(--highlight-color);stroke:var(--highlight-color)}a:focus,button:focus{outline:none}br{margin:1em}article{flex:1;min-width:0}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a svg{height:1em}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home .title{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1100px){aside.toc{display:initial;position:sticky;top:0;min-width:200px;max-width:350px;padding-right:1em;align-self:flex-start;hyphens:auto}aside.toc header{margin-top:1em;font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.2em}aside.toc ul li{padding-bottom:.2em}aside.toc a{text-decoration:none}}article form svg,article a svg,article i svg{height:1em;position:relative;top:2px;padding-right:3px}article p svg:not(:first-child){padding-left:.25em}article header{margin-top:1em;margin-bottom:1em}article header nav{display:flex;flex-wrap:wrap}article header nav a{text-decoration:none;padding-right:7px}@media(min-width:700px){article header nav form.search{margin-left:auto}}article header nav form.search input[type=search]{padding:2px;width:250px}article header nav form.search input[type=search]:focus{border-color:var(--highlight-color);outline:solid var(--highlight-color)1px}article header nav form.search button[type=submit]{margin-left:-25px;border:none;background:initial}article .lead p{font-weight:500;font-size:1.1em}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{font-weight:700}article .admonitionblock td.content div:first-child p{margin-top:0}article .admonitionblock td.content div:last-child p{margin-bottom:0}@media(max-width:600px){article .admonitionblock tr{display:block;float:left;padding-left:.5em;padding-right:.5em}article .admonitionblock tr td{display:block}}@media(min-width:600px){article .admonitionblock td.icon{width:75px;text-align:center;border-right:1px solid var(--gray-highlight-color)}article .admonitionblock td.content{padding-left:.5em}}article .exampleblock{margin-top:1em;margin-bottom:1em}article .exampleblock .title{font-style:italic}article a.github-example{text-decoration:none}article a.github-example svg{height:.8em;position:relative;top:2px}article .playground-example .title,article .godbolt-example .title{position:relative}article .playground-example .title a,article .godbolt-example .title a{position:absolute;top:7px;right:7px}article .playground-example .title a svg,article .godbolt-example .title a svg{height:1em}article details{margin-bottom:1em}article details summary{font-style:italic}article ul p,article ol p{margin:.2em}article div ul:not(:first-child),article div ol:not(:first-child){margin-top:0}article dl dt{margin-top:.5em;font-weight:700}article dl dd p,article dl dd div:only-child ul{margin:0;padding:0}article div dl:not(:first-child){margin-top:0}article table.tableblock{background:var(--white);margin:0 auto;border-collapse:collapse}article table.tableblock td,article table.tableblock th{border:1px solid var(--gray-highlight-color);padding:5px;text-align:left}article table.tableblock td p,article table.tableblock th p{margin:0}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article code{font-family:Inconsolata,monospace,sans-serif}article pre{margin-top:0;overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}.highlight .c,.highlight .cm,.highlight .cp,.highlight .c1,.highlight .cs,.ace_editor .c,.ace_editor .cm,.ace_editor .cp,.ace_editor .c1,.ace_editor .cs{color:#998;font-style:italic;font-weight:initial}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kp,.highlight .kr,.highlight .kt,.highlight .ace_storage,.highlight .ace_keyword,.ace_editor .k,.ace_editor .kc,.ace_editor .kd,.ace_editor .kp,.ace_editor .kr,.ace_editor .kt,.ace_editor .ace_storage,.ace_editor .ace_keyword{color:#458;font-style:initial;font-weight:700}.highlight .o,.highlight .p,.highlight .ace_keyword.ace_operator,.highlight .ace_paren,.highlight .ace_punctuation,.ace_editor .o,.ace_editor .p,.ace_editor .ace_keyword.ace_operator,.ace_editor .ace_paren,.ace_editor .ace_punctuation{color:red;font-style:initial;font-weight:initial}.highlight .ace_dsl,.ace_editor .ace_dsl{pointer-events:auto}.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .ace_constant,.ace_editor .m,.ace_editor .mf,.ace_editor .mh,.ace_editor .mi,.ace_editor .mo,.ace_editor .ace_constant{color:#ff8000;font-style:initial;font-weight:initial}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .s3,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss,.highlight .se,.highlight .ace_string,.ace_editor .s,.ace_editor .sb,.ace_editor .sc,.ace_editor .sd,.ace_editor .s2,.ace_editor .s3,.ace_editor .sh,.ace_editor .si,.ace_editor .sx,.ace_editor .sr,.ace_editor .s1,.ace_editor .ss,.ace_editor .se,.ace_editor .ace_string{color:green;font-style:initial;font-weight:initial}.highlight .cp,.highlight .cpf,.ace_editor .cp,.ace_editor .cpf{color:green;font-style:initial;font-weight:700}.highlight .err,.highlight .ace_invalid,.ace_editor .err,.ace_editor .ace_invalid{color:red;font-style:initial;font-weight:initial}.highlight strong,.ace_editor strong{font-weight:initial}.highlight strong:not(:empty)::before,.ace_editor strong:not(:empty)::before{content:"*";color:red}.highlight strong:not(:empty)::after,.ace_editor strong:not(:empty)::after{content:"*";color:red}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/><span class=title>lexy:</span> C++ parsing DSL</a></li></ul><ul id=main><li><a href=/learn/>Learn</a></li><li><a href=/reference/>Reference</a></li><li><a href=/playground/>Playground</a></li><li><a href=/download/>Download</a></li><li><a href=https://github.com/foonathan/lexy title=GitHub><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li></ul></div></nav><main><aside class=toc><header><a href=#>Table of Contents</a></header></aside><article id=doc><header><h1>Header <code>lexy/parse_tree.hpp</code></h1><nav><a href=https://github.com/foonathan/lexy/blob/main/include/lexy/parse_tree.hpp><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> View source
</a><a href="https://github.com/foonathan/lexy/issues/new?title=lexy%2fparse_tree.hpp"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bug" class="svg-inline--fa fa-bug fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M511.988 288.9c-.478 17.43-15.217 31.1-32.653 31.1H424v16c0 21.864-4.882 42.584-13.6 61.145l60.228 60.228c12.496 12.497 12.496 32.758.0 45.255-12.498 12.497-32.759 12.496-45.256.0l-54.736-54.736C345.886 467.965 314.351 480 280 480V236c0-6.627-5.373-12-12-12h-24c-6.627.0-12 5.373-12 12v244c-34.351.0-65.886-12.035-90.636-32.108l-54.736 54.736c-12.498 12.497-32.759 12.496-45.256.0-12.496-12.497-12.496-32.758.0-45.255l60.228-60.228C92.882 378.584 88 357.864 88 336v-16H32.666C15.23 320 .491 306.33.013 288.9-.484 270.816 14.028 256 32 256h56v-58.745l-46.628-46.628c-12.496-12.497-12.496-32.758.0-45.255 12.498-12.497 32.758-12.497 45.256.0L141.255 160h229.489l54.627-54.627c12.498-12.497 32.758-12.497 45.256.0 12.496 12.497 12.496 32.758.0 45.255L424 197.255V256h56c17.972.0 32.484 14.816 31.988 32.9zM257 0c-61.856.0-112 50.144-112 112h224C369 50.144 318.856.0 257 0z"/></svg> Report an issue
</a><a href=https://github.com/foonathan/lexy/edit/main/docs/content/reference/parse_tree.adoc><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="edit" class="svg-inline--fa fa-edit fa-w-18" role="img" viewBox="0 0 576 512"><path fill="currentcolor" d="M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8.0zm162-22.9-48.8-48.8c-15.2-15.2-39.9-15.2-55.2.0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8.0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2.0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5.0 112v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"/></svg> Edit this page</a><form class=search id=dsl-goto-form><input type=search id=dsl-goto-search placeholder="Go to..." list=dsl-goto-data autocomplete=off>
<button type=submit title=Go><svg viewBox="0 0 448 512"><path d="M438.6 278.6c12.5-12.5 12.5-32.8.0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3.0s-12.5 32.8.0 45.3L338.8 224H32c-17.7.0-32 14.3-32 32s14.3 32 32 32h306.7L233.4 393.4c-12.5 12.5-12.5 32.8.0 45.3s32.8 12.5 45.3.0l160-160z"/></svg></button></form></nav></header><section><div class=sect1><h2 id=parse_tree>Class <code>lexy::parse_tree</code></h2><div class=sectionbody><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>namespace</span> <span class=n>lexy</span>
<span class=p>{</span>
    <span class=k>template</span> <span class=o>&lt;</span><span class=n><em>reader</em></span> <span class=n>Reader</span><span class=p>,</span> <span class=k>typename</span> <span class=nc>TokenKind</span> <span class=o>=</span> <span class=kt>void</span><span class=p>,</span>
              <span class=k>typename</span> <span class=nc>MemoryResource</span> <span class=o>=</span> <span class=n><em>default</em></span><em><span class=o>-</span><span class=n>resource</span></em><span class=p>&gt;</span>
    <span class=k>class</span> <span class=nc>parse_tree</span>
    <span class=p>{</span>
    <span class=nl>public:</span>
        <span class=c1>//=== construction ===//</span>
        <span class=k>class</span> <span class=nc>builder</span><span class=p>;</span>

        <span class=k>constexpr</span> <span class=n>parse_tree</span><span class=p>();</span>
        <span class=k>constexpr</span> <span class=k>explicit</span> <span class=n>parse_tree</span><span class=p>(</span><span class=n>MemoryResource</span><span class=o>*</span> <span class=n>resource</span><span class=p>);</span>

        <span class=n>parse_tree</span><span class=p>(</span><span class=k>const</span> <span class=n>parse_tree</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
        <span class=n>parse_tree</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>parse_tree</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>

        <span class=n>parse_tree</span><span class=p>(</span><span class=n>parse_tree</span><span class=o>&amp;&amp;</span><span class=p>);</span>
        <span class=n>parse_tree</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>parse_tree</span><span class=o>&amp;&amp;</span><span class=p>);</span>

        <span class=c1>//=== container interface ===//</span>
        <span class=kt>bool</span> <span class=n>empty</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>size</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
        <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>depth</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=kt>void</span> <span class=n>clear</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=c1>//=== nodes ===//</span>
        <span class=k>class</span> <span class=nc>node</span><span class=p>;</span>
        <span class=k>class</span> <span class=nc>node_kind</span><span class=p>;</span>

        <span class=n>node</span> <span class=n>root</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=c1>//=== traversal ===//</span>
        <span class=k>class</span> <span class=nc>traverse_range</span><span class=p>;</span>

        <span class=n>traverse_range</span> <span class=n>traverse</span><span class=p>(</span><span class=n>node</span> <span class=n>n</span><span class=p>)</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
        <span class=n>traverse_range</span> <span class=n>traverse</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

        <span class=c1>//=== remaining input ===//</span>
        <span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span> <span class=n>remaining_input</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span>
    <span class=p>};</span>

    <span class=k>template</span> <span class=o>&lt;</span><span class=n><em>input</em></span> <span class=n>Input</span><span class=p>,</span> <span class=k>typename</span> <span class=nc>TokenKind</span> <span class=o>=</span> <span class=kt>void</span><span class=p>,</span>
              <span class=k>typename</span> <span class=nc>MemoryResource</span> <span class=o>=</span> <span class=n><em>default</em></span><em><span class=o>-</span><span class=n>resource</span></em><span class=p>&gt;</span>
    <span class=k>using</span> <span class=n>parse_tree_for</span>
      <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>parse_tree</span><span class=o>&lt;</span><span class=n>input_reader</span><span class=o>&lt;</span><span class=n>Input</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>TokenKind</span><span class=p>,</span> <span class=n>MemoryResource</span><span class=o>&gt;</span><span class=p>;</span>
<span class=p>}</span></code></pre></div></div><div class="paragraph lead"><p>A lossless, untyped, immutable parse tree.</p></div><div class=paragraph><p>It is an ordered, rooted tree that represents the structure of the parsed inputs.
It has two kinds of nodes: token nodes and production nodes.
Token nodes represent individual tokens of the input:
they store the <a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code> </a> and the <a href=/reference/token/#token_kind><code>lexy::token_kind</code> </a> and do not have children.
Production nodes represent productions of the input:
they are identified by the <a href=/reference/grammar/#production_name><code>lexy::production_name</code> </a> and have zero or more child nodes for the tokens and child productions of the production.
The root node of a non-empty tree is always the production node for the top-level production of the grammar.</p></div><div class=paragraph><p>The tree is parametrized on the <code>Reader</code>, which determines the type of <a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code> </a> stored by token nodes,
and the <code>TokenKind</code> of <a href=/reference/token/#token_kind><code>lexy::token_kind</code> </a>.
The latter is <code>void</code> by default, which means integers are used to identify tokens.</p></div><div class=paragraph><p>The tree is immutable: once constructed, the nodes cannot be modified in any way;
changing a tree is only possible by re-assigning it.
It is not copyable, but moveable.</p></div><div class=paragraph><p>All memory allocation for the tree is done via a <code>MemoryResource</code> object,
which must be a class with the same interface as <code>std::pmr::memory_resource</code>.
By default, it uses <code>new</code> and <code>delete</code>.
The memory resource object passed to the constructor does not propagate during copy/move/swap.</p></div><div class=paragraph><p>Internally, the nodes of the tree are stored in big chunks of continuous memory.
Each node has the size of three pointers and they form a linked list.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use <a href=/reference/action/parse_as_tree/#parse_as_tree><code>lexy::parse_as_tree</code> </a> to build a parse tree for an input.</td></tr></tbody></table></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>The parse tree does not own the contents of token nodes, so make sure the input stays alive as long as the tree does.</td></tr></tbody></table></div><div class=sect2><h3 id=_construction_constructors>Construction: Constructors</h3><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=nf>parse_tree</span><span class=p>();</span>
<span class=k>constexpr</span> <span class=k>explicit</span> <span class=nf>parse_tree</span><span class=p>(</span><span class=n>MemoryResource</span><span class=o>*</span> <span class=n>resource</span><span class=p>);</span></code></pre></div></div><div class="paragraph lead"><p>Construct an empty parse tree without any nodes.</p></div><div class=paragraph><p>The default constructor is only valid for the <em>`default-resource`</em> and uses the default resource for memory allocation.
The second overload assigns the specified <code>resource</code>, which is not changed by further assignment.</p></div></div><div class=sect2><h3 id=builder>Construction: <code>lexy::​parse​_tree::​builder</code></h3><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>class</span> <span class=nc>parse_tree</span><span class=o>::</span><span class=n>builder</span>
<span class=p>{</span>
    <span class=k>using</span> <span class=n><em>iterator</em></span> <span class=o>=</span> <span class=k>typename</span> <span class=n>Reader</span><span class=o>::</span><span class=n>iterator</span><span class=p>;</span>

<span class=nl>public:</span>
    <span class=k>struct</span> <span class=nc>marker</span>
    <span class=p>{</span>
        <span class=n>marker</span><span class=p>();</span>
    <span class=p>};</span>

    <span class=c1>//=== root node ===//</span>
    <span class=k>explicit</span> <span class=n>builder</span><span class=p>(</span><span class=n>parse_tree</span><span class=o>&amp;&amp;</span> <span class=n>tree</span><span class=p>,</span> <span class=n><em>production</em></span> <span class=k>auto</span> <span class=n>root</span><span class=p>);</span>
    <span class=k>explicit</span> <span class=n>builder</span><span class=p>(</span><span class=n><em>production</em></span> <span class=k>auto</span> <span class=n>root</span><span class=p>)</span>
    <span class=o>:</span> <span class=n>builder</span><span class=p>(</span><span class=n>parse_tree</span><span class=p>{},</span> <span class=n>root</span><span class=p>)</span>
    <span class=p>{}</span>

    <span class=n>parse_tree</span><span class=o>&amp;&amp;</span> <span class=n>finish</span><span class=p>(</span><span class=k>typename</span> <span class=n>Reader</span><span class=o>::</span><span class=n>iterator</span> <span class=n>end</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>{</span> <span class=k>return</span> <span class=n>finish</span><span class=p>({</span><span class=n>end</span><span class=p>,</span> <span class=n>end</span><span class=p>});</span> <span class=p>}</span>
    <span class=n>parse_tree</span><span class=o>&amp;&amp;</span> <span class=n>finish</span><span class=p>(</span><span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span> <span class=n>remaining_input</span><span class=p>)</span> <span class=o>&amp;&amp;</span><span class=p>;</span>

    <span class=c1>//=== production node ===//</span>
    <span class=n>marker</span> <span class=n>start_production</span><span class=p>(</span><span class=n><em>production</em></span> <span class=k>auto</span> <span class=n>production</span><span class=p>);</span>

    <span class=kt>void</span> <span class=n>finish_production</span><span class=p>(</span><span class=n>marker</span><span class=o>&amp;&amp;</span> <span class=n>m</span><span class=p>);</span>
    <span class=kt>void</span> <span class=n>cancel_production</span><span class=p>(</span><span class=n>marker</span><span class=o>&amp;&amp;</span> <span class=n>m</span><span class=p>);</span>

    <span class=c1>//=== container node ===//</span>
    <span class=n>marker</span> <span class=n>start_container</span><span class=p>();</span>

    <span class=kt>void</span> <span class=n>set_container_production</span><span class=p>(</span><span class=n><em>production</em></span> <span class=k>auto</span> <span class=n>production</span><span class=p>);</span>

    <span class=kt>void</span> <span class=n>finish_container</span><span class=p>(</span><span class=n>marker</span><span class=o>&amp;&amp;</span> <span class=n>m</span><span class=p>);</span>
    <span class=kt>void</span> <span class=n>cancel_container</span><span class=p>(</span><span class=n>marker</span><span class=o>&amp;&amp;</span> <span class=n>m</span><span class=p>);</span>

    <span class=c1>//=== token node ===//</span>
    <span class=kt>void</span> <span class=n>token</span><span class=p>(</span><span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>kind</span><span class=p>,</span> <span class=n><em>iterator</em></span> <span class=n>begin</span><span class=p>,</span> <span class=n>_iterator</span> <span class=n>_end</span><span class=p>);</span>

    <span class=c1>//=== accessors ===//</span>
    <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>current_child_count</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
<span class=p>};</span></code></pre></div></div><div class="paragraph lead"><p>Manually builds a non-empty parse tree.</p></div><div class=paragraph><p>The constructor can optionally take an existing parse tree, which will be <code>clear()`ed.
This allows re-using already allocated memory or a custom memory resource.
The root node of the tree will be a production node for the specified `root</code> production,
which is the active node (see below).</p></div><div class=paragraph><p>Then the tree can be built using the following methods:</p></div><div class=dlist><dl><dt class=hdlist1><code>finish</code></dt><dd><p>Finishes the construction of the entire tree and returns it.
The active node must be the root node.
It also sets <code>.remaining_input()</code>, whose <code>.begin()</code> should be the <code>.end()</code> of the last token in the tree.</p></dd><dt class=hdlist1><code>start_production</code></dt><dd><p>Start construction for a new production node for <code>production</code> and pushes it to the active node’s list of children.
It returns a <code>marker</code> object, which must eventually be passed to <code>finish_production</code> or <code>cancel_production</code>.
The new production node will be the active node.</p><div class=paragraph><p>If <code>production</code> is a <a href=/reference/grammar/#transparent_production><code>lexy::transparent_production</code> </a>, no new node is created.
However, the <code>marker</code> object must still be passed to <code>finish_production</code> or <code>cancel_production</code>.</p></div></dd><dt class=hdlist1><code>finish_production</code></dt><dd><p>Finishes the production node of the corresponding <code>marker</code> object,
which must be the active node.
The parent node will become active node again.</p></dd><dt class=hdlist1><code>cancel_production</code></dt><dd><p>Cancels construction of the production node of the corresponding <code>marker</code> object,
which must be the active node.
The node and all children already added to it will be removed from the parse tree;
it is returned to the same state it had before the corresponding <code>start_production</code> call.</p></dd><dt class=hdlist1><code>start_container</code></dt><dd><p>Starts a container of more nodes.
This can then later be turned into a production node, if desired.
It returns a <code>marker</code> object, which must eventually be passed to <code>finish_container</code> or <code>cancel_container</code>.
The container will be the active node.</p></dd><dt class=hdlist1><code>set_container_production</code></dt><dd><p>If the passed production is transparent, does nothing.
Otherwise, creates a new production node and adds all children from the currently active container to it.
It then creates a new container whose only child is the newly added production node.
The new container will be the active node, everything added to it will become a sibling of the production node.</p></dd><dt class=hdlist1><code>finish_container</code></dt><dd><p>Finishes a container of the corresponding <code>marker</code> object, which must be the active node.
Adds all child nodes to the parent without adding an intermediate node.
This results in the same tree as if <code>start_container()</code> had never been called, and all children just added directly.
The parent node will become active node again.</p></dd><dt class=hdlist1><code>cancel_container</code></dt><dd><p>Cancels construction of a container of the corresponding <code>marker</code> object, which must be the active node.
All children of the container will be removed from the parse tree;
it is returned to the same state it had before the corresponding <code>cancel_container</code> call.</p></dd><dt class=hdlist1><code>token</code></dt><dd><p>Construct a new token node and push it to the active node’s list of children.
The node will have the specified <a href=/reference/token/#token_kind><code>lexy::token_kind</code> </a> and the lexeme <code>[begin, end)</code> of the input.</p><div class=paragraph><p>If <code>kind.ignore_if_empty() == true</code> and <code>begin == end</code>, no token node is constructed.</p></div></dd><dt class=hdlist1><code>current_child_count</code></dt><dd><p>Returns the child nodes already added to the node that is currently being built.</p></dd></dl></div></div><div class=sect2><h3 id=_container_interface>Container interface</h3><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=kt>bool</span> <span class=n>empty</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span> <b class=conum>(1)</b>

<span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>size</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>  <b class=conum>(2)</b>
<span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>depth</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span> <b class=conum>(3)</b>

<span class=kt>void</span> <span class=n>clear</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>;</span>              <b class=conum>(4)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>true</code> if the tree is empty, <code>false</code> otherwise.
An empty tree does not have any nodes.</p></li><li><p>Returns the total number of nodes of the tree, including the root node.</p></li><li><p>Returns the maximum depth of all nodes in the tree,
which is the number of times you need to call <code>node.parent()</code> to reach the root.
The depth of an empty tree is not defined.</p></li><li><p>Clears the tree by removing all nodes, but without deallocating memory.</p></li></ol></div><div class=paragraph><p>An empty tree has <code>size() == 0</code> and undefined <code>depth()</code>.
A tree that consists only of the root node has <code>size() == 1</code> and <code>depth() == 0</code>.
A shallow tree, where all nodes are children of the root node, has <code>depth() == 1</code>.
A completely nested tree, where each node has exactly one child, has <code>depth() == size() - 1</code>.</p></div></div><div class=sect2><h3 id=node_kind>Nodes: <code>lexy::​parse​_tree::​node​_kind</code></h3><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>class</span> <span class=nc>parse_tree</span><span class=o>::</span><span class=n>node_kind</span>
<span class=p>{</span>
<span class=nl>public:</span>
    <span class=c1>//=== access ===//</span>
    <span class=kt>bool</span> <span class=n>is_token</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
    <span class=kt>bool</span> <span class=n>is_production</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=kt>bool</span> <span class=n>is_root</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
    <span class=kt>bool</span> <span class=n>is_token_production</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=c1>//=== comparison ===//</span>
    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=n>node_kind</span> <span class=n>lhs</span><span class=p>,</span> <span class=n>node_kind</span> <span class=n>rhs</span><span class=p>);</span>
    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>!=</span><span class=p>(</span><span class=n>node_kind</span> <span class=n>lhs</span><span class=p>,</span> <span class=n>node_kind</span> <span class=n>rhs</span><span class=p>);</span>

    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=n>node_kind</span> <span class=n>nk</span><span class=p>,</span> <span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>tk</span><span class=p>);</span>
    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>tk</span><span class=p>,</span> <span class=n>node_kind</span> <span class=n>nk</span><span class=p>);</span>
    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>!=</span><span class=p>(</span><span class=n>node_kind</span> <span class=n>nk</span><span class=p>,</span> <span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>tk</span><span class=p>);</span>
    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>!=</span><span class=p>(</span><span class=n>token_kind</span><span class=o>&lt;</span><span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>tk</span><span class=p>,</span> <span class=n>node_kind</span> <span class=n>nk</span><span class=p>);</span>

    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=n>node_kind</span> <span class=n>nk</span><span class=p>,</span> <span class=n>production_info</span> <span class=n>info</span><span class=p>);</span>
    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=n>production_info</span> <span class=n>info</span><span class=p>,</span> <span class=n>node_kind</span> <span class=n>nk</span><span class=p>);</span>
    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>!=</span><span class=p>(</span><span class=n>node_kind</span> <span class=n>nk</span><span class=p>,</span> <span class=n>production_info</span> <span class=n>info</span><span class=p>);</span>
    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>!=</span><span class=p>(</span><span class=n>production_info</span> <span class=n>info</span><span class=p>,</span> <span class=n>node_kind</span> <span class=n>nk</span><span class=p>);</span>
<span class=p>};</span></code></pre></div></div><div class="paragraph lead"><p>Information about the kind of a node.</p></div><div class=dlist><dl><dt class=hdlist1><code>is_token</code></dt><dd><p><code>true</code> if the node is a token node, <code>false</code> otherwise.
<code>is_token() == !is_production()</code>.</p></dd><dt class=hdlist1><code>is_production</code></dt><dd><p><code>true</code> if the node is a production node, <code>false</code> otherwise.
<code>is_production() == !is_token()</code>.</p></dd><dt class=hdlist1><code>is_root</code></dt><dd><p><code>true</code> if the node is the root node of the tree, <code>false</code> otherwise.
The root node is always a production node.</p></dd><dt class=hdlist1><code>is_token_production</code></dt><dd><p><code>true</code> if the node is a production node that is a <a href=/reference/grammar/#token_production><code>lexy::token_production</code> </a>, <code>false</code> otherwise.</p></dd><dt class=hdlist1><code>name</code></dt><dd><p>For a production node, returns <a href=/reference/grammar/#production_name><code>lexy::production_name</code> </a>.
For a token node, returns <code>.name()</code> of its <a href=/reference/token/#token_kind><code>lexy::token_kind</code> </a>.</p></dd></dl></div><div class=paragraph><p>Node kinds can be compared with equality with each other, <a href=/reference/token/#token_kind><code>lexy::token_kind</code> </a> and productions.
Two node kinds are equal if they are either both token nodes with the same token nodes, or both production nodes for the same production.
A node kind and a token kind is equal, if the node kind is a token node with that kind,
and a node kind and a production is equal, if it is a production node for that production.</p></div></div><div class=sect2><h3 id=node>Nodes: <code>lexy::​parse​_tree::​node</code></h3><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>class</span> <span class=nc>parse_tree</span><span class=o>::</span><span class=n>node</span>
<span class=p>{</span>
<span class=nl>public:</span>
    <span class=c1>//=== properties ===//</span>
    <span class=kt>void</span><span class=o>*</span> <span class=n>address</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=n>node_kind</span> <span class=n>kind</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span>           <span class=n>lexeme</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
    <span class=n>lexy</span><span class=o>::</span><span class=n>token</span><span class=o>&lt;</span><span class=n>Reader</span><span class=p>,</span> <span class=n>TokenKind</span><span class=o>&gt;</span> <span class=n>token</span><span class=p>()</span>  <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=n>iterator</span> <span class=n>position</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
    <span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span> <span class=n>covering_lexeme</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=c1>//=== relationships ===//</span>
    <span class=n>node</span> <span class=n>parent</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=k>class</span> <span class=nc>children_range</span><span class=p>;</span>
    <span class=n>children_range</span> <span class=n>children</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=k>class</span> <span class=nc>sibling_range</span><span class=p>;</span>
    <span class=n>sibling_range</span> <span class=n>siblings</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=kt>bool</span> <span class=n>is_last_child</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=c1>//=== comparison ===//</span>
    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=n>node</span> <span class=n>lhs</span><span class=p>,</span> <span class=n>node</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
    <span class=k>friend</span> <span class=kt>bool</span> <span class=k>operator</span><span class=o>!=</span><span class=p>(</span><span class=n>node</span> <span class=n>lhs</span><span class=p>,</span> <span class=n>node</span> <span class=n>rhs</span><span class=p>)</span> <span class=k>noexcept</span><span class=p>;</span>
<span class=p>};</span></code></pre></div></div><div class="paragraph lead"><p>A reference to node in the parse tree.</p></div><div class=paragraph><p>Internally, this is just a pointer to the node data structure.</p></div><div class=dlist><div class=title>Properties:</div><dl><dt class=hdlist1><code>address</code></dt><dd><p>The address of the referenced node in memory.
It uniquely identifies the node.</p></dd><dt class=hdlist1><code>kind</code></dt><dd><p>The <a href=/reference/parse_tree/#node_kind><code>lexy::parse_tree::node_kind</code> </a> of the node.</p></dd><dt class=hdlist1><code>lexeme</code></dt><dd><p>For a token node, returns the <a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code> </a> of the node.
For a production node, returns an empty lexeme.</p></dd><dt class=hdlist1><code>token</code></dt><dd><p>Requires that the node is a token node; returns the stored <a href=/reference/token/#token><code>lexy::token</code> </a> of the node.</p></dd><dt class=hdlist1><code>position</code></dt><dd><p>Equivalent to <code>covering_lexeme().begin()</code>.</p></dd><dt class=hdlist1><code>covering_lexeme</code></dt><dd><p>For a token node, returns the <a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code> </a> of the node.
For a production node, returns a lexeme that covers all token descendants of the production node.</p></dd></dl></div><div class=paragraph><p>Two node references can be compared for equality, which compares their addresses.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content><code>covering_lexeme()</code> and <code>position()</code> require that every production node has at least one child and that <code>tree.remaining_input().begin()</code> is <code>.end()</code> of the last token descendant of the root node (in particular, it is not <code>iterator()</code>).
All parse trees created by <a href=/reference/action/parse_as_tree/#parse_as_tree><code>lexy::parse_as_tree</code> </a> have that property.</td></tr></tbody></table></div><div class=sect3><h4 id=_node_relationships_parent>Node relationships: Parent</h4><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=n>node</span> <span class=n>parse_tree</span><span class=o>::</span><span class=n>node</span><span class=o>::</span><span class=n>parent</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span></code></pre></div></div><div class="paragraph lead"><p>Returns a reference to its parent node.</p></div><div class=paragraph><p>For the root node, which does not have a parent node, returns <code>*this</code>.</p></div><div class=paragraph><p>This operation is <code>O(number of siblings)</code>.</p></div></div><div class=sect3><h4 id=_node_relationships_children>Node relationships: Children</h4><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>class</span> <span class=nc>parse_tree</span><span class=o>::</span><span class=n>node</span><span class=o>::</span><span class=n>children_range</span>
<span class=p>{</span>
<span class=nl>public:</span>
    <span class=k>class</span> <span class=nc>iterator</span><span class=p>;</span> <span class=c1>// value_type = node</span>

    <span class=n>iterator</span> <span class=n>begin</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
    <span class=n>iterator</span> <span class=n>end</span><span class=p>()</span>   <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=kt>bool</span> <span class=n>empty</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
    <span class=n>std</span><span class=o>::</span><span class=kt>size_t</span> <span class=n>size</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
<span class=p>};</span>

<span class=n>children_range</span> <span class=n>parse_tree</span><span class=o>::</span><span class=n>node</span><span class=o>::</span><span class=n>children</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span></code></pre></div></div><div class="paragraph lead"><p>A sized range that iterates over all direct children of the referenced node in order.</p></div><div class=paragraph><p>For a token node, this is always an empty range.</p></div></div><div class=sect3><h4 id=_node_relationships_siblings>Node relationships: Siblings</h4><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>class</span> <span class=nc>parse_tree</span><span class=o>::</span><span class=n>node</span><span class=o>::</span><span class=n>sibling_range</span>
<span class=p>{</span>
<span class=nl>public:</span>
    <span class=k>class</span> <span class=nc>iterator</span><span class=p>;</span> <span class=c1>// value_type = node</span>

    <span class=n>iterator</span> <span class=n>begin</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
    <span class=n>iterator</span> <span class=n>end</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
<span class=p>};</span>

<span class=n>sibling_range</span> <span class=n>parse_tree</span><span class=o>::</span><span class=n>node</span><span class=o>::</span><span class=n>siblings</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span></code></pre></div></div><div class="paragraph lead"><p>A range that iterates over all siblings of the referenced node.</p></div><div class=paragraph><p>The siblings of a node are all other child nodes of its parent.
Iteration begins with the child that is following the referenced node and continues until the last child of the parent node.
It then wraps around to the first child and ends when it reaches the referenced node again.
The referenced node is not included; no node is its own sibling.</p></div><div class=paragraph><p>For the root node, this is always an empty range.</p></div><hr></div></div><div class=sect2><h3 id=_nodes_root_node>Nodes: Root node</h3><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=n>node</span> <span class=n>parse_tree</span><span class=o>::</span><span class=n>root</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span></code></pre></div></div><div class="paragraph lead"><p>A reference to the root node of the tree.</p></div><div class=paragraph><p>The tree must not be empty.</p></div></div><div class=sect2><h3 id=_traversal>Traversal</h3><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>namespace</span> <span class=n>lexy</span>
<span class=p>{</span>
    <span class=k>enum</span> <span class=k>class</span> <span class=nc>traverse_event</span>
    <span class=p>{</span>
        <span class=n>enter</span><span class=p>,</span>
        <span class=n>exit</span><span class=p>,</span>
        <span class=n>leaf</span><span class=p>,</span>
    <span class=p>};</span>
<span class=p>}</span></code></pre></div></div><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>class</span> <span class=nc>parse_tree</span><span class=o>::</span><span class=n>traverse_range</span>
<span class=p>{</span>
<span class=nl>public:</span>
    <span class=k>using</span> <span class=n>event</span> <span class=o>=</span> <span class=n>traverse_event</span><span class=p>;</span>
    <span class=k>class</span> <span class=nc>iterator</span><span class=p>;</span> <span class=c1>// struct value_type { traverse_event event; node node; };</span>

    <span class=n>iterator</span> <span class=n>begin</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
    <span class=n>iterator</span> <span class=n>end</span><span class=p>()</span>   <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

    <span class=kt>bool</span> <span class=n>empty</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>
<span class=p>};</span>

<span class=n>traverse_range</span> <span class=n>parse_tree</span><span class=o>::</span><span class=n>traverse</span><span class=p>(</span><span class=n>node</span> <span class=n>n</span><span class=p>)</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span>

<span class=n>traverse_range</span> <span class=n>parse_tree</span><span class=o>::</span><span class=n>traverse</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span><span class=p>;</span></code></pre></div></div><div class="paragraph lead"><p>A range that traverses all descendants of a node.</p></div><div class=paragraph><p>The first overload traverses all descendants of the node <code>n</code>, which includes <code>n</code> itself.
The second overload traverses all nodes in the parse tree.
For a non-empty tree, it is equivalent to <code>traverse(root())</code>.
For an empty tree, it returns the empty range.</p></div><div class=paragraph><p>The value type of the traverse range’s iterator is a pair of <code>lexy::traverse_event</code> and <code>node</code>.
The traverse event indicates why a node is visited, and <code>node</code> is the reference to the current node.</p></div><div class=paragraph><p>For a token node <code>n</code>, <code>traverse(n)</code> is a one element range whose value is <code>n</code> itself with the <code>traverse_event::leaf</code>.</p></div><div class=paragraph><p>For a production node <code>n</code>, <code>traverse(n)</code> is at least a two element range.
The first element is <code>n</code> itself with the <code>traverse_event::enter</code>.
It then recursively traverses all direct children of <code>n</code>.
The final element is again <code>n</code> with the <code>traverse_event::exit.</code></p></div><div class=exampleblock><div class=title>Example 1. Print a tree</div><div class=content><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>auto</span> <span class=n>depth</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=p>[</span><span class=n>event</span><span class=p>,</span> <span class=n>node</span><span class=p>]</span> <span class=o>:</span> <span class=n>tree</span><span class=p>.</span><span class=n>traverse</span><span class=p>())</span>
<span class=p>{</span>
    <span class=k>switch</span> <span class=p>(</span><span class=n>event</span><span class=p>)</span>
    <span class=p>{</span>
    <span class=k>case</span> <span class=n>lexy</span><span class=o>::</span><span class=n>traverse_event</span><span class=o>::</span><span class=n>enter</span><span class=p>:</span>
        <span class=o>++</span><span class=n>depth</span><span class=p>;</span>
        <span class=n>indent</span><span class=p>(</span><span class=n>depth</span><span class=p>);</span>
        <span class=n>print_node</span><span class=p>(</span><span class=n>node</span><span class=p>);</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=k>case</span> <span class=n>lexy</span><span class=o>::</span><span class=n>traverse_event</span><span class=o>::</span><span class=n>exit</span><span class=p>:</span>
        <span class=o>--</span><span class=n>depth</span><span class=p>;</span>
        <span class=k>break</span><span class=p>;</span>

    <span class=k>case</span> <span class=n>lexy</span><span class=o>::</span><span class=n>traverse_event</span><span class=o>::</span><span class=n>leaf</span><span class=p>:</span>
        <span class=n>indent</span><span class=p>(</span><span class=n>depth</span><span class=p>);</span>
        <span class=n>print_node</span><span class=p>(</span><span class=n>node</span><span class=p>);</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span></code></pre></div></div></div></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>Traversing the parse tree is an optimized operation that does not involve dynamic memory allocation or recursion.
Instead, each iteration step simply follows a pointer.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_remaining_input>Remaining input</h3><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=n>lexy</span><span class=o>::</span><span class=n>lexeme</span><span class=o>&lt;</span><span class=n>Reader</span><span class=o>&gt;</span> <span class=n>remaining_input</span><span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span></code></pre></div></div><div class="paragraph lead"><p>Returns the remaining input, i.e. everything that has not been turned into the parse tree.</p></div><div class=paragraph><p>Unless it has been set in <code>finish()</code>, it is empty.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>The position of an empty remaining input is not necessarily at the end of the input.
<a href=/reference/action/parse_as_tree/#parse_as_tree><code>lexy::parse_as_tree</code> </a> guarantees it, however.</td></tr></tbody></table></div></div></div></div></section><section id=see-also><h2>See also</h2><ul><li><a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code></a></li><li><a href=/reference/action/parse_as_tree/#parse_as_tree><code>lexy::parse_as_tree</code></a></li><li><a href=/reference/grammar/#production_name><code>lexy::production_name</code></a></li><li><a href=/reference/token/#token><code>lexy::token</code></a></li><li><a href=/reference/token/#token_kind><code>lexy::token_kind</code></a></li><li><a href=/reference/grammar/#token_production><code>lexy::token_production</code></a></li><li><a href=/reference/grammar/#transparent_production><code>lexy::transparent_production</code></a></li></ul></section></article><datalist id=dsl-goto-data></datalist>
<script>window.addEventListener("load",async function(){var e=await(await fetch("/reference/index.json")).json(),n=document.getElementById("dsl-goto-data"),s=document.getElementById("dsl-goto-form"),t=document.getElementById("dsl-goto-search");for(let t in e){let s=document.createElement("option");t.startsWith("lexy_")?s.value=t.toUpperCase():s.value=t,n.appendChild(s)}s.addEventListener("submit",function(n){n.preventDefault();let s=e[t.value.toLowerCase()];return s?window.location.href=s:t.value="",!1})})</script></main><footer id=page-footer><section class=copyright>&copy; <a target=_blank href=https://github.com/foonathan/lexy/blob/main/LICENSE title=License>2020-2025 Jonathan Müller and lexy contributors</a></section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://fontawesome.com/license>Font Awesome</a>.</section></footer></body></html>