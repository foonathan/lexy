<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>lexy Reference Documentation</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1><code>lexy</code> Reference Documentation</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_inputs_and_encodings">Inputs and Encodings</a>
<ul class="sectlevel2">
<li><a href="#_encodings">Encodings</a>
<ul class="sectlevel3">
<li><a href="#_the_supported_encodings">The supported encodings</a></li>
<li><a href="#_deducing_encoding">Deducing encoding</a></li>
<li><a href="#_encoding_endianness">Encoding endianness</a></li>
</ul>
</li>
<li><a href="#_the_pre_defined_inputs">The pre-defined Inputs</a>
<ul class="sectlevel3">
<li><a href="#_null_input">Null input</a></li>
<li><a href="#_range_input">Range input</a></li>
<li><a href="#_string_input">String input</a></li>
<li><a href="#_buffer_input">Buffer Input</a></li>
<li><a href="#_file_input">File Input</a></li>
<li><a href="#_shell_input">Shell Input</a></li>
<li><a href="#_command_line_argument_input">Command-line argument Input</a></li>
</ul>
</li>
<li><a href="#_lexemes">Lexemes</a>
<ul class="sectlevel3">
<li><a href="#_lexeme">Lexeme</a></li>
<li><a href="#_code_point">Code point</a></li>
</ul>
</li>
<li><a href="#_writing_custom_inputs">Writing custom Inputs</a></li>
</ul>
</li>
<li><a href="#_matching_parsing_and_validating">Matching, parsing and validating</a>
<ul class="sectlevel2">
<li><a href="#_result">Result</a></li>
<li><a href="#_callbacks">Callbacks</a>
<ul class="sectlevel3">
<li><a href="#_callback_adapters">Callback adapters</a></li>
<li><a href="#_callback_composition">Callback composition</a></li>
<li><a href="#_the_no_op_callback">The no-op callback</a></li>
<li><a href="#_constructing_objects">Constructing objects</a></li>
<li><a href="#_constructing_lists">Constructing lists</a></li>
<li><a href="#_constructing_strings">Constructing strings</a></li>
<li><a href="#_rule_specific_callbacks">Rule-specific callbacks</a></li>
</ul>
</li>
<li><a href="#_error_handling">Error handling</a>
<ul class="sectlevel3">
<li><a href="#_error_types">Error types</a></li>
<li><a href="#_error_context">Error context</a></li>
<li><a href="#_error_location">Error location</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_the_rule_dsl">The rule DSL</a>
<ul class="sectlevel2">
<li><a href="#_whitespace">Whitespace</a></li>
<li><a href="#_primitive_tokens">Primitive Tokens</a></li>
<li><a href="#_character_classes">Character classes</a></li>
<li><a href="#_values">Values</a></li>
<li><a href="#_errors">Errors</a></li>
<li><a href="#_branch_conditions">Branch conditions</a></li>
<li><a href="#_branches">Branches</a></li>
<li><a href="#_loops">Loops</a></li>
<li><a href="#_productions">Productions</a></li>
<li><a href="#_brackets_and_terminator">Brackets and terminator</a></li>
<li><a href="#_numbers">Numbers</a></li>
<li><a href="#_delimited_and_quoted">Delimited and quoted</a></li>
<li><a href="#_aggregates">Aggregates</a></li>
<li><a href="#_context_sensitive_parsing">Context sensitive parsing</a></li>
<li><a href="#_raw_input">Raw input</a></li>
<li><a href="#_custom_rules">Custom rules</a></li>
</ul>
</li>
<li><a href="#_glossary">Glossary</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is the reference documentation for <a href="https://github.com/foonathan/lexy"><code>lexy</code></a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>If anything in the documentation could be improved (and there is probably a lot),
please raise an issue or&#8201;&#8212;&#8201;even better&#8201;&#8212;&#8201;create a PR.
Thank you!</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_inputs_and_encodings">Inputs and Encodings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An <code>Input</code> defines the input that will be parsed by <code>lexy</code>.
It has a corresponding <code>Encoding</code> that controls, among other things, its character type and whether certain rules are available.
The <code>Input</code> itself is unchanging and it produces a <code>Reader</code> which remembers the current position of the input during parsing.</p>
</div>
<div class="sect2">
<h3 id="_encodings">Encodings</h3>
<div class="listingblock">
<div class="title"><code>lexy/encoding.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    struct default_encoding;
    struct ascii_encoding;
    struct utf8_encoding;
    struct utf16_encoding;
    struct utf32_encoding;
    struct raw_encoding;

    template &lt;typename CharT&gt;
    using deduce_encoding = /* see below */;

    enum class encoding_endianness;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>Encoding</code> is a set of pre-defined policy classes that determine the text encoding of an input.</p>
</div>
<div class="paragraph">
<p>Each encoding has a <em>primary character type</em>, which is the character type of the input.
It can also have a <em>secondary character type</em>, which the input should accept, but internally convert to the primary character type.
For example, <code>lexy::utf8_encoding&#8217;s primary character type is `char8_t</code>, but it also accepts <code>char</code>.</p>
</div>
<div class="paragraph">
<p>The encoding also has an <em>integer type</em>, which can store either any valid character (code unit to be precise) or a special EOF value, similar to <code>std::char_traits</code>.
For some encodings, the integer type can be the same as the character type as not all values are valid code units.
This allows optimizations.</p>
</div>
<div class="paragraph">
<p>Certain rules can require a certain encodings.
For example, <code>lexy::dsl::code_point</code> does not work with the <code>lexy::default_encoding</code>, and <code>lexy::dsl::encode</code> requires <code>lexy::raw_encoding</code>.</p>
</div>
<div class="sect3">
<h4 id="_the_supported_encodings">The supported encodings</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>lexy::default_encoding</code></dt>
<dd>
<p>The encoding that will be used when no other encoding is specified.
Its character type is <code>char</code> and it can work with any 8-bit encoding (ASCII, UTF-8, extended ASCII etc.).
Only use this encoding if you don&#8217;t know the exact encoding of your input.</p>
</dd>
<dt class="hdlist1"><code>lexy::ascii_encoding</code></dt>
<dd>
<p>Assumes the input is valid ASCII. Its character type is <code>char</code>.</p>
</dd>
<dt class="hdlist1"><code>lexy::utf8_encoding</code></dt>
<dd>
<p>Assumes the input is valid UTF-8. Its character type is <code>char8_t</code>, but it also accepts <code>char</code>.</p>
</dd>
<dt class="hdlist1"><code>lexy::utf16_encoding</code></dt>
<dd>
<p>Assumes the input is valid UTF-16. Its character type is <code>char16_t</code>, but it also accepts <code>wchar_t</code> on Windows.</p>
</dd>
<dt class="hdlist1"><code>lexy::utf32_encoding</code></dt>
<dd>
<p>Assumes the input is valid UTF-32. Its character type is <code>char32_t</code>, but it also accepts <code>wchar_t</code> on Linux.</p>
</dd>
<dt class="hdlist1"><code>lexy::raw_encoding</code></dt>
<dd>
<p>Does not assume the input is text. Its character type is <code>unsigned char</code>, but it also accepts <code>char</code>.
Use this encoding if you&#8217;re not parsing text or if you&#8217;re parsing text consisting of multiple encodings.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you specify an encoding that does not match the inputs actual encoding, e.g. you say it is UTF-8 but in reality it is some Windows code page, the library will handle it by generating parse errors.
The worst that can happen is that you&#8217;ll get an unexpected EOF error because the input contains the character that is used to signal EOF in the encoding.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_deducing_encoding">Deducing encoding</h4>
<div class="paragraph">
<p>If you don&#8217;t specify an encoding for your input, <code>lexy</code> can sometimes deduce it by matching the character type to the primary character type.
For example, a string of <code>char8_t</code> will be deduce it to be <code>lexy::utf8_encoding</code>.
If the character type is <code>char</code>, <code>lexy</code> will deduce <code>lexy::default_encoding</code> (unless that has been overriden by a build option).</p>
</div>
</div>
<div class="sect3">
<h4 id="_encoding_endianness">Encoding endianness</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">enum class encoding_endianness
{
    little,
    big,
    bom,
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In-memory, UTF-16 and UTF-32 come in two flavors: big and little endian.
Which version is used, can be specified with the <code>encoding_endianness</code> enumeration.
This is only relevant when e.g. reading data from files.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">little</dt>
<dd>
<p>The encoding is written using little endian.
For single-byte encodings, this has no effect.</p>
</dd>
<dt class="hdlist1">big</dt>
<dd>
<p>The encoding is written using big endian.
For single-byte encodings, this has no effect.</p>
</dd>
<dt class="hdlist1">bom</dt>
<dd>
<p>The endianness is determined using the byte-order mark (BOM) of the encoding.
If no BOM is present, defaults to big endian as per Unicode recommendation.
For UTF-8, this will skip the optional BOM, but has otherwise no effect.
For non-Unicode encodings, this has no effect.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_pre_defined_inputs">The pre-defined Inputs</h3>
<div class="sect3">
<h4 id="_null_input">Null input</h4>
<div class="listingblock">
<div class="title"><code>lexy/input/null_input.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Encoding = default_encoding&gt;
    class null_input
    {
    public:
        constexpr Reader reader() const&amp; noexcept;
    };

    template &lt;typename Encoding = default_encoding&gt;
    using null_lexeme = lexeme_for&lt;null_input&lt;Encoding&gt;&gt;;
    template &lt;typename Tag, typename Encoding = default_encoding&gt;
    using null_error = error_for&lt;null_input&lt;Encoding&gt;, Tag&gt;;
    template &lt;typename Production, typename Encoding = default_encoding&gt;
    using null_error_context = error_context&lt;Production, null_input&lt;Encoding&gt;&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>lexy::null_input</code> is an input that is always empty.</p>
</div>
</div>
<div class="sect3">
<h4 id="_range_input">Range input</h4>
<div class="listingblock">
<div class="title"><code>lexy/input/range_input.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Encoding, typename Iterator, typename Sentinel = Iterator&gt;
    class range_input
    {
    public:
        using encoding  = Encoding;
        using char_type = typename encoding::char_type;
        using iterator  = Iterator;

        constexpr range_input() noexcept;
        constexpr range_input(Iterator begin, Sentinel end) noexcept;

        constexpr iterator begin() const noexcept;
        constexpr iterator end() const noexcept;

        constexpr Reader reader() const&amp; noexcept;
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>lexy::range_input</code> is an input that represents the range <code>[begin, end)</code>.
CTAD can be used to deduce the encoding from the value type of the iterator.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The input is a lightweight view and does not own any data.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <code>lexy::string_input</code> instead if the range is contiguous.
</td>
</tr>
</table>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>Using the range input to parse content from a list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">std::list&lt;char8_t&gt; list = …;

// Create the input, deducing the encoding.
auto input = lexy::range_input(list.begin(), list.end());</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="_string_input">String input</h4>
<div class="listingblock">
<div class="title"><code>lexy/input/string_input.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Encoding = default_encoding&gt;
    class string_input
    {
    public:
        using encoding  = Encoding;
        using char_type = typename encoding::char_type;
        using iterator  = const char_type*;

        constexpr string_input() noexcept;

        template &lt;typename CharT&gt;
        constexpr string_input(const CharT* begin, const CharT* end) noexcept;
        template &lt;typename CharT&gt;
        constexpr string_input(const CharT* data, std::size_t size) noexcept;

        template &lt;typename View&gt;
        constexpr explicit string_input(const View&amp; view) noexcept;

        constexpr iterator begin() const noexcept;
        constexpr iterator end() const noexcept;

        constexpr Reader reader() const&amp; noexcept;
    };

    template &lt;typename Encoding, typename CharT&gt;
    constexpr auto zstring_input(const CharT* str) noexcept;
    template &lt;typename CharT&gt;
    constexpr auto zstring_input(const CharT* str) noexcept;

    template &lt;typename Encoding = default_encoding&gt;
    using string_lexeme = lexeme_for&lt;string_input&lt;Encoding&gt;&gt;;
    template &lt;typename Tag, typename Encoding = default_encoding&gt;
    using string_error = error_for&lt;string_input&lt;Encoding&gt;, Tag&gt;;
    template &lt;typename Production, typename Encoding = default_encoding&gt;
    using string_error_context = error_context&lt;Production, string_input&lt;Encoding&gt;&gt;;
} // namespace lexy</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>lexy::string_input</code> is an input that represents the string view defined by the constructors.
CTAD can be used to deduce the encoding from the character type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The input is a lightweight view and does not own any data.
Use <code>lexy::buffer</code> if you want an owning version.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_pointer_constructor">Pointer constructor</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template &lt;typename CharT&gt;
constexpr string_input(const CharT* begin, const CharT* end) noexcept; <i class="conum" data-value="1"></i><b>(1)</b>
template &lt;typename CharT&gt;
constexpr string_input(const CharT* data, std::size_t size) noexcept; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The input is the contiguous range <code>[begin, end)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The input is the contiguous range <code>[data, data + size)</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>CharT</code> must be the primary or secondary character type of the encoding.</p>
</div>
</div>
<div class="sect4">
<h5 id="_view_constructor">View constructor</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template &lt;typename View&gt;
constexpr explicit string_input(const View&amp; view) noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The input is given by the <code>View</code>, which requires a <code>.data()</code> and <code>.size()</code> member.
The character type of the <code>View</code> must be the primary or secondary character type of the encoding.</p>
</div>
</div>
<div class="sect4">
<h5 id="_null_terminated_string_functions">Null-terminated string functions</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template &lt;typename Encoding, typename CharT&gt;
constexpr auto zstring_input(const CharT* str) noexcept; <i class="conum" data-value="1"></i><b>(1)</b>
template &lt;typename CharT&gt;
constexpr auto zstring_input(const CharT* str) noexcept; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use the specified encoding.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Deduce the encoding from the character type.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The input is given by the range <code>[str, end)</code>, where <code>end</code> is a pointer to the first null character of the string.
The return type is an appropriate <code>lexy::string_input</code> instantiation.</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>Using the string input to parse content from a <code>std::string</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">std::string str = …;
auto input = lexy::string_input(str);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the string input to parse content from a string literal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">auto input = lexy::zstring_input(u"Hello World!");</code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
<div class="sect3">
<h4 id="_buffer_input">Buffer Input</h4>
<div class="listingblock">
<div class="title"><code>lexy/input/buffer.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
template &lt;typename Encoding       = default_encoding,
          typename MemoryResource = /* default resource */&gt;
class buffer
{
public:
    using encoding  = Encoding;
    using char_type = typename encoding::char_type;

    class builder;

    constexpr buffer() noexcept;
    constexpr explicit buffer(MemoryResource* resource) noexcept;

    template &lt;typename CharT&gt;
    explicit buffer(const CharT* data, std::size_t size,
                    MemoryResource* resource = /* default resource */);
    template &lt;typename CharT&gt;
    explicit buffer(const CharT* begin, const CharT* end,
                    MemoryResource* resource = /* default resource */);

    template &lt;typename View&gt;
    explicit buffer(const View&amp;     view,
                    MemoryResource* resource = /* default resource */);

    buffer(const buffer&amp; other, MemoryResource* resource);

    const char_type* begin() const noexcept;
    const char_type* end() const noexcept;

    const char_type* data() const noexcept;

    bool empty() const noexcept;

    std::size_t size() const noexcept;
    std::size_t length() const noexcept;

    Reader reader() const&amp; noexcept;
};

template &lt;typename Encoding, encoding_endianness Endianness&gt;
constexpr auto make_buffer;

template &lt;typename Encoding       = default_encoding,
          typename MemoryResource = /* default resource */&gt;
using buffer_lexeme = lexeme_for&lt;buffer&lt;Encoding, MemoryResource&gt;&gt;;
template &lt;typename Tag, typename Encoding = default_encoding,
          typename MemoryResource = /* default resource */&gt;
using buffer_error = error_for&lt;buffer&lt;Encoding, MemoryResource&gt;, Tag&gt;;
template &lt;typename Production, typename Encoding = default_encoding,
          typename MemoryResource = /* default resource */&gt;
using buffer_error_context = error_context&lt;Production, buffer&lt;Encoding, MemoryResource&gt;&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>lexy::buffer</code> is an immutable, owning variant of <code>lexy::string_input</code>.
The memory for the input is allocated using the <code>MemoryResource</code>, which is a class with the same interface as <code>std::pmr::memory_resource</code>.
By default, it uses a <code>new</code> and <code>delete</code> for the allocation, just like <code>std::pmr::new_delete_resource</code>.
Construction of the buffer is just like <code>lexy::string_input</code>, except for the additional <code>MemoryResource</code> parameter.
Once a memory resource has been specified, it will not propagate on assignment.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
As the buffer owns the input, it can terminate it with the EOF character for encodings that have the same character and integer type.
This eliminates the "is the reader at eof?"-branch during parsing.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_builder">Builder</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">class builder
{
public:
    explicit builder(std::size_t     size,
                     MemoryResource* resource = /* default resource */);

    char_type* data() const noexcept;
    std::size_t size() const noexcept;

    buffer finish() &amp;&amp; noexcept;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>builder</code> class separates the allocation and copying of the buffer data.
This allows, for example, writing into the immutable buffer from a file.
The constructor allocates memory for <code>size</code> characters, then <code>data()</code> gives a mutable pointer to that memory.</p>
</div>
</div>
<div class="sect4">
<h5 id="_make_buffer">Make buffer</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">struct /* unspecified */
{
    auto operator()(const void* memory, std::size_t size) const;

    template &lt;typename MemoryResource&gt;
    auto operator()(const void* memory, std::size_t size, MemoryResource* resource) const;
};

template &lt;typename Encoding, encoding_endianness Endianness&gt;
constexpr auto make_buffer = /* unspecified */;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>lexy::make_buffer</code> is a function object that constructs a <code>lexy::buffer</code> of the specified encoding from raw memory.
If necessary, it will take care of the endianness conversion as instructed by the <code>lexy::encoding_endianness</code> enumeration.
Any BOM, if present, will not be part of the input.</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>Using a buffer to parse content from a <code>std::string</code> using UTF-8.
This enables the sentinel optimization.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">std::string str = …;
auto input = lexy::buffer&lt;lexy::utf8_encoding&gt;(str);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using a buffer to parse a memory-mapped file containing little endian UTF-16.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">auto ptr = mmap(…);

constexpr auto make_utf16_little = lexy::make_buffer&lt;lexy::utf16_encoding,
                                        lexy::encoding_endianness::little&gt;;
auto input = make_utf16_little(ptr, length);</code></pre>
</div>
</div>
</div>
</details>
</div>
</div>
<div class="sect3">
<h4 id="_file_input">File Input</h4>
<div class="listingblock">
<div class="title"><code>lexy/input/file.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    enum class file_error
    {
        os_error,
        file_not_found,
        permission_denied,
    };

    template &lt;typename Encoding          = default_encoding,
              encoding_endianness Endian = encoding_endianness::bom,
              typename MemoryResource&gt;
    auto read_file(const char*     path,
                   MemoryResource* resource = /* default resource */)
        -&gt; result&lt;buffer&lt;Encoding, MemoryResource&gt;, file_error&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>lexy::read_file()</code> reads the file at the specified path using the specified encoding and endianness.
On success, it returns a <code>lexy::result</code> containing a <code>lexy::buffer</code> with the file contents.
On failure, it returns a <code>lexy::result</code> containing the error code.</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>Reading UTF-16 from a file with a BOM.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">auto result = lexy::read_file&lt;lexy::utf16_encoding&gt;("input.txt");
if (!result)
    throw my_file_read_error_exception(result.error()); <i class="conum" data-value="1"></i><b>(1)</b>

auto input = std::move(result).value(); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Throw an exception giving it the <code>lexy::file_error</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Move the buffer out of the result and use it as input.</td>
</tr>
</table>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="_shell_input">Shell Input</h4>
<div class="listingblock">
<div class="title"><code>lexy/input/shell.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Encoding = default_encoding&gt;
    struct default_prompt;

    template &lt;typename Prompt = default_prompt&lt;&gt;&gt;
    class shell
    {
    public:
        using encoding    = typename Prompt::encoding;
        using char_type   = typename encoding::char_type;
        using prompt_type = Prompt;

        shell();
        explicit shell(Prompt prompt);

        bool is_open() const noexcept;

        Input prompt_for_input();

        class writer;
        template &lt;typename... Args&gt;
        writer write_message(Args&amp;&amp;... args);

        Prompt&amp; get_prompt() noexcept;
        const Prompt&amp; get_prompt() const noexcept;
    };

    template &lt;typename Prompt = default_prompt&lt;&gt;&gt;
    using shell_lexeme = /* unspecified */;
    template &lt;typename Tag, typename Prompt = default_prompt&lt;&gt;&gt;
    using shell_error = /* unspecified */;
    template &lt;typename Production, typename Prompt = default_prompt&lt;&gt;&gt;
    using shell_error_context = /* unspecified */;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>lexy::shell</code> creates an interactive shell to ask for user input and write messages out.
The exact behavior is controlled by the <code>Prompt</code>.
By default, it uses <code>lexy::default_prompt</code> which reads from <code>stdin</code> and writes to <code>stdout</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The interface of a <code>Prompt</code> is currently experimental.
Refer to <code>lexy::default_prompt</code> if you want to write your own.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_state">State</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">bool is_open() const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A shell is initially open and can receive input, but the user can close the shell.
For <code>lexy::default_prompt</code>, the shell is closed if the user enters EOF e.g. by pressing <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span> under Linux.</p>
</div>
<div class="paragraph">
<p><code>is_open()</code> returns <code>false</code> if the user has closed it, and <code>true</code> otherwise.</p>
</div>
</div>
<div class="sect4">
<h5 id="_input">Input</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">Input prompt_for_input();</code></pre>
</div>
</div>
<div class="paragraph">
<p>A shell object is not itself an <code>Input</code>, but it can be used to create one.
Calling <code>prompt_for_input()</code> will ask the user to enter some input, and then return an unspecified <code>Input</code> type that refers to that input.
If parsing reaches the end of the input and the shell is still open, it will automatically ask the user for continuation input that will be appended to the current input.
Once parsing of the input is done, <code>prompt_for_input()</code> can be called again to request new input from the user.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Calling <code>prompt_for_input()</code> again will invalidate all memory used by the previous input.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>lexy::default_prompt</code> asks for input by display <code>&gt; ` and reading an entire line from `stdin</code>.
If continuation input is requested, it will display `. ` and reads another line.</p>
</div>
</div>
<div class="sect4">
<h5 id="_output">Output</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">class writer
{
public:
    // non-copyable

    template &lt;typename CharT&gt;
    writer&amp; operator()(const CharT* str, std::size_t length);
    template &lt;typename CharT&gt;
    writer&amp; operator()(const CharT* str);
    template &lt;typename CharT&gt;
    writer&amp; operator()(CharT c);

    writer&amp; operator()(lexy::lexeme_for&lt;/* input type */&gt; lexeme);
};

template &lt;typename... Args&gt;
writer write_message(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>write_message()</code> will prepare the prompt for displaying a message and returns a <code>writer</code> function object that can be used to specify the contents of the message.
The arguments of <code>write_message()</code> are forwarded to the prompt and can be used to distinguish between e.g. normal and error messages.
The <code>writer</code> can be invoked multiple times to give different parts of the message; the entire message is written out when the writer is destroyed.
A <code>writer</code> can only write messages whose character type are the primary or secondary character type of the encoding.</p>
</div>
<div class="paragraph">
<p>Using <code>lexy::default_prompt</code> does not require any message arguments and it will simply write the message to <code>stdout</code>, appending a newline at the end.</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>An interactive REPL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">lexy::shell&lt;&gt; shell;
while (shell.is_open())
{
    auto input = shell.prompt_for_input(); <i class="conum" data-value="1"></i><b>(1)</b>
    auto result = lexy::parse&lt;expression&gt;(input, …); <i class="conum" data-value="2"></i><b>(2)</b>
    if (result)
        shell.write_message()(result.value()); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Ask the user to enter more input.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Parse the input, requesting continuation input if necessary.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Write the result.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For a full example, see <code>examples/shell.cpp</code>.</p>
</div>
</div>
</details>
</div>
</div>
<div class="sect3">
<h4 id="_command_line_argument_input">Command-line argument Input</h4>
<div class="listingblock">
<div class="title"><code>lexy/input/argv_input.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    class argv_sentinel;
    class argv_iterator;

    constexpr argv_iterator argv_begin(int argc, char* argv[]) noexcept;
    constexpr argv_iterator argv_end(int argc, char* argv[]) noexcept;

    template &lt;typename Encoding = default_encoding&gt;
    class argv_input
    {
    public:
        using encoding  = Encoding;
        using char_type = typename encoding::char_type;
        using iterator  = argv_iterator;

        constexpr argv_input() = default;
        constexpr argv_input(argv_iterator begin, argv_iterator end) noexcept;
        constexpr argv_input(int argc, char* argv[]) noexcept;

        constexpr Reader reader() const&amp; noexcept;
    };

    template &lt;typename Encoding = default_encoding&gt;
    using argv_lexeme = lexeme_for&lt;argv_input&lt;Encoding&gt;&gt;;
    template &lt;typename Tag, typename Encoding = default_encoding&gt;
    using argv_error = error_for&lt;argv_input&lt;Encoding&gt;, Tag&gt;;
    template &lt;typename Production, typename Encoding = default_encoding&gt;
    using argv_error_context = error_context&lt;Production, argv_input&lt;Encoding&gt;&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>lexy::argv_input</code> is an input that uses the command-line arguments passed to <code>main()</code>.
It excludes <code>argv[0]</code>, which is the executable name, and includes <code>\0</code> as a separator between command line arguments.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The input is a lightweight view and does not own any data.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_command_line_iterators">Command-line iterators</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">class argv_sentinel;
class argv_iterator;

constexpr argv_iterator argv_begin(int argc, char* argv[]) noexcept;
constexpr argv_iterator argv_end(int argc, char* argv[]) noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>lexy::argv_iterator</code> is a bidirectional iterator iterating over the command-line arguments excluding the initial argument which is the executable name.
It can be created using <code>argv_begin()</code> and <code>argv_end()</code>.</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>Use the command line arguments as input.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">int main(int argc, char* argv[])
{
    auto input = lexy::argv_input(argc, argv);
    …
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the program is invoked with <code>./a.out a 123 b</code>, the input will be <code>a\0123\0b</code>.</p>
</div>
</div>
</details>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lexemes">Lexemes</h3>
<div class="paragraph">
<p>A <strong>lexeme</strong> is a the part of the input matched by a rule.</p>
</div>
<div class="sect3">
<h4 id="_lexeme">Lexeme</h4>
<div class="listingblock">
<div class="title"><code>lexy/lexeme.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Reader&gt;
    class lexeme
    {
    public:
        using encoding  = typename Reader::encoding;
        using char_type = typename encoding::char_type;
        using iterator  = typename Reader::iterator;

        constexpr lexeme() noexcept;
        constexpr lexeme(iterator begin, iterator end) noexcept;

        constexpr explicit lexeme(const Reader&amp; reader, iterator begin) noexcept
        : lexeme(begin, reader.cur())
        {}

        constexpr bool empty() const noexcept;

        constexpr iterator begin() const noexcept;
        constexpr iterator end() const noexcept;

        // Only if the iterator is a pointer.
        constexpr const char_type* data() const noexcept;

        // Only if the iterator has `operator-`.
        constexpr std::size_t size() const noexcept;

        // Only if the iterator has `operator[]`.
        constexpr char_type operator[](std::size_t idx) const noexcept;
    };

    template &lt;typename Input&gt;
    using lexeme_for = lexeme&lt;input_reader&lt;Input&gt;&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>lexy::lexeme</code> represents a sub-range of the input.
For convenience, most inputs also provide convenience typedefs that can be used instead of <code>lexy::lexeme_for</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_code_point">Code point</h4>
<div class="listingblock">
<div class="title"><code>lexy/encoding.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    class code_point
    {
    public:
        constexpr code_point() noexcept;
        constexpr explicit code_point(char32_t value) noexcept;

        constexpr char32_t value() const noexcept;

        constexpr bool is_valid() const noexcept;
        constexpr bool is_surrogate() const noexcept;
        constexpr bool is_scalar() const noexcept;

        constexpr bool is_ascii() const noexcept;
        constexpr bool is_bmp() const noexcept;

        friend constexpr bool operator==(code_point lhs, code_point rhs) noexcept;
        friend constexpr bool operator!=(code_point lhs, code_point rhs) noexcept;
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>lexy::code_point</code> represents a single code point from the input.
It is merely a wrapper over a <code>char32_t</code> that contains the numerical code.</p>
</div>
<div class="sect4">
<h5 id="_constructors">Constructors</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr code_point() noexcept; <i class="conum" data-value="1"></i><b>(1)</b>
constexpr explicit code_point(char32_t value) noexcept; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates an invalid code point.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creates the specified code point. The value will be returned from <code>value()</code> unchanged.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_validity">Validity</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr bool is_valid() const noexcept; <i class="conum" data-value="1"></i><b>(1)</b>
constexpr bool is_surrogate() const noexcept; <i class="conum" data-value="2"></i><b>(2)</b>
constexpr bool is_scalar() const noexcept; <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns <code>true</code> if the code point is less than <code>0x10&#8217;FFFF</code>, <code>false</code> otherwise.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns <code>true</code> if the code point is a UTF-16 surrogate, <code>false</code> otherwise.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Returns <code>true</code> if the code point is valid and not a surrogate, <code>false</code> otherwise.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_category">Category</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr bool is_ascii() const noexcept; <i class="conum" data-value="1"></i><b>(1)</b>
constexpr bool is_bmp() const noexcept; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns <code>true</code> if the code point is ASCII (7-bit value), <code>false</code> otherwise.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns <code>true</code> if the code point is in the Unicode BMP (16-bit value), <code>false</code> otherwise.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_writing_custom_inputs">Writing custom Inputs</h3>
<div class="listingblock">
<div class="title">The <code>Input</code> concept</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">class Input
{
public:
    Reader reader() const&amp;;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>Input</code> is just a class with a <code>reader()</code> member function that returns a <code>Reader</code> to the beginning of the input.
The type alias <code>lexy::input_reader&lt;Reader&gt;</code> returns the type of the corresponding reader.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The interface of a <code>Reader</code> is currently experimental.
Refer to the comments in <code>lexy/input/base.hpp</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_matching_parsing_and_validating">Matching, parsing and validating</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">The <code>Production</code> concept</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">struct Production
{
    static constexpr auto rule = …;

    static constexpr auto value = …; // optional
    static constexpr auto list  = …; // optional
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>Production</code> is type containing a rule and optional callbacks that produce the value.
A grammar contains an entry production where parsing begins and all productions referenced by it.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It is recommended to put all productions of a grammar into a separate namespace.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By passing the entry production of the grammar to <code>lexy::match()</code>, <code>lexy::parse()</code>, or <code>lexy::validate()</code>, the production is parsed.</p>
</div>
<h3 id="_matching" class="discrete">Matching</h3>
<div class="listingblock">
<div class="title"><code>lexy/match.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Production, typename Input&gt;
    constexpr bool match(const Input&amp; input);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>lexy::match()</code> matches the <code>Production</code> on the given <code>input</code>.
If the production accepts the input, returns <code>true</code>, otherwise, returns <code>false</code>.
It will discard any values produced and does not give detailed information about why the production did not accept the input.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A production does not necessarily need to consume the entire input for it to match.
Add <code>lexy::dsl::eof</code> to the end if the production should consume the entire input.
</td>
</tr>
</table>
</div>
<h3 id="_validating" class="discrete">Validating</h3>
<div class="listingblock">
<div class="title"><code>lexy/validate.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Production, typename Input, typename Callback&gt;
    constexpr auto validate(const Input&amp; input, Callback callback)
        -&gt; result&lt;/* see below */&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>lexy::validate()</code> validates that the <code>Production</code> matches on the given <code>input</code>.
The return value is an <code>lexy::result&lt;void, E&gt;</code>, where <code>E</code> is the return type of <code>callback</code>.
If the production accepts the input, returns an empty optional, otherwise, invokes the callback with the error information (see <a href="#_error_handling">Error handling</a>) and returns its result.
It will discard any values produced.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A production does not necessarily need to consume the entire input for it to match.
Add <code>lexy::dsl::eof</code> to the end if the production should consume the entire input.
</td>
</tr>
</table>
</div>
<h3 id="_parsing" class="discrete">Parsing</h3>
<div class="listingblock">
<div class="title"><code>lexy/parse.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Production, typename Input, typename Callback&gt;
    constexpr auto parse(const Input&amp; input, Callback callback)
        -&gt; result&lt;/* see below */&gt;;

    template &lt;typename Production, typename Input, typename State, typename Callback&gt;
    constexpr auto parse(const Input&amp; input, State&amp;&amp; state, Callback callback)
        -&gt; result&lt;/* see below */&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <code>lexy::parse()</code> parses the <code>Production</code> on the given <code>input</code>.
The return value is a <code>lexy::result&lt;T, E&gt;</code>, where <code>T</code> is the return type of the <code>Production::value</code> or <code>Production::list</code> callback,
and <code>E</code> is the return type of the <code>callback</code>.
If the production accepts the input, invokes <code>Production::value</code> or <code>Production::list</code> (see below) with the produced values and returns their result.
Otherwise, invokes <code>callback</code> with the error information (see <a href="#_error_handling">Error handling</a>) and returns its result.</p>
</div>
<div class="paragraph">
<p>The return value on success is determined using <code>Production::value</code> or <code>Production::list</code> depending on three cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Production::rule</code> does not contain a list. Then all arguments will be forwarded to the <code>Production::value</code> callback whose result is returned.
The <code>Production::value</code> callback must be present.</p>
</li>
<li>
<p><code>Production::rule</code> contains a list and no other rule produces a value. Then the <code>Production::list</code> callback will be used as sink for the list values.
If an additional <code>Production::value</code> callback is present, the result of the <code>Production::list</code> callback will be passed to the <code>Production::value</code> callback whose result is returned.
Otherwise, the result of the <code>Production::list</code> callback is the final result.
The <code>Production::list</code> callback must be present.</p>
</li>
<li>
<p><code>Production::rule</code> contains a list and other rules produce values as well.
Then the <code>Production::list</code> callback will be used as sink for the list values.
The resulting value will be added to the list of other rule values in order, and all values forwarded to the <code>Production::value</code> callback whose result is returned.
Both <code>Production::value</code> and <code>Production::list</code> must be present.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The second overload of <code>lexy::parse()</code> allows passing an arbitrary state argument.
This will be made available to the <code>lexy::dsl::parse_state</code> and <code>lexy::dsl::parse_state_member</code> rules which can forward it to the <code>Production::value</code> callback.</p>
</div>
<div class="sect2">
<h3 id="_result">Result</h3>
<div class="listingblock">
<div class="title"><code>lexy/result.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    struct result_value_t {};
    constexpr auto result_value = result_value_t{};

    struct result_error_t {};
    constexpr auto result_error = result_error_t{};

    template &lt;typename T, typename E&gt;
    class result
    {
    public:
        using value_type = /* see below */;
        using error_type = /* see below */;

        constexpr result();

        template &lt;typename... Args&gt;
        constexpr result(result_value_t, Args&amp;&amp;... args);
        template &lt;typename... Args&gt;
        constexpr result(result_error_t, Args&amp;&amp;... args);

        template &lt;typename U&gt;
        constexpr explicit result(const result&lt;U, E&gt;&amp; other);
        template &lt;typename U&gt;
        constexpr explicit result(result&lt;U, E&gt;&amp;&amp; other);

        template &lt;typename Arg&gt;
        constexpr explicit result(Arg&amp;&amp; arg);

        constexpr explicit operator bool() const noexcept;
        constexpr bool has_value() const noexcept;
        constexpr bool has_error() const noexcept;

        static constexpr bool has_void_value() noexcept;
        static constexpr bool has_void_error() noexcept;

        constexpr value_type&amp; value() &amp; noexcept;
        constexpr const value_type&amp; value() const&amp; noexcept;
        constexpr value_type&amp;&amp; value() &amp;&amp; noexcept;
        constexpr const value_type&amp;&amp; value() const&amp;&amp; noexcept;

        constexpr error_type&amp; error() &amp; noexcept;
        constexpr const error_type&amp; error() const&amp; noexcept;
        constexpr error_type&amp;&amp; error() &amp;&amp; noexcept;
        constexpr const error_type&amp;&amp; error() const&amp;&amp; noexcept;
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>lexy::result&lt;T, E&gt;</code> stores either a value <code>T</code> or an error <code>E</code> and is used to return the result of parsing.
<code>T</code> and <code>E</code> can be <code>void</code>; in that case it is internally translated to the tag types <code>result_value_t</code> or <code>result_error_t</code>, respectively, which is reflected in the <code>value_type</code> and <code>error_type</code> typedefs as well.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>lexy::result&lt;T, void&gt;</code> is like <code>std::optional&lt;T&gt;</code> and <code>lexy::result&lt;void, void&gt;</code> is like <code>bool</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Once a result is created containing a value or error, it can never change that state.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>lexy::result</code> was created for use by the library only.
While it can be used as a general purpose result monad (which we leverage for <code>lexy::read_file()</code>), it is better to us a designated library for it.
</td>
</tr>
</table>
</div>
<h5 id="_creation" class="discrete">Creation</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr result(); <i class="conum" data-value="1"></i><b>(1)</b>

template &lt;typename... Args&gt;
constexpr result(result_value_t, Args&amp;&amp;... args); <i class="conum" data-value="2"></i><b>(2)</b>
template &lt;typename... Args&gt;
constexpr result(result_error_t, Args&amp;&amp;... args); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates a result containing a default constructed error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creates a result containing the value constructed by forwarding the arguments.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creates a result containing the error constructed by forwarding the arguments.</td>
</tr>
</table>
</div>
<h5 id="_conversion" class="discrete">Conversion</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template &lt;typename U&gt;
constexpr explicit result(const result&lt;U, E&gt;&amp; other); <i class="conum" data-value="1"></i><b>(1)</b>
template &lt;typename U&gt;
constexpr explicit result(result&lt;U, E&gt;&amp;&amp; other); <i class="conum" data-value="2"></i><b>(2)</b>

template &lt;typename Arg&gt;
constexpr explicit result(Arg&amp;&amp; arg); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Converts an errored <code>result&lt;U, E&gt;</code> to a <code>result&lt;T, E&gt;</code> by copying the error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Converts an errored <code>result&lt;U, E&gt;</code> to a <code>result&lt;T, E&gt;</code> by moving the error.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Only available for <code>result&lt;T, void&gt;</code> or <code>result&lt;void, E&gt;</code>. Constructs the value/error by forwarding the argument.</td>
</tr>
</table>
</div>
<h5 id="_state_2" class="discrete">State</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr explicit operator bool() const noexcept; <i class="conum" data-value="1"></i><b>(1)</b>
constexpr bool has_value() const noexcept; <i class="conum" data-value="2"></i><b>(2)</b>
constexpr bool has_error() const noexcept; <i class="conum" data-value="3"></i><b>(3)</b>

static constexpr bool has_void_value() noexcept; <i class="conum" data-value="4"></i><b>(4)</b>
static constexpr bool has_void_error() noexcept; <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns <code>true</code> if it contains a value, <code>false</code> otherwise.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns <code>true</code> if it contains a value, <code>false</code> otherwise.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Returns <code>true</code> if it contains an error, <code>false</code> otherwise.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Returns <code>true</code> if <code>T == void</code>, <code>false</code> otherwise.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Returns <code>true</code> if <code>E == void</code>, <code>false</code> otherwise.</td>
</tr>
</table>
</div>
<h5 id="_access" class="discrete">Access</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr value_type&amp; value() &amp; noexcept;
constexpr const value_type&amp; value() const&amp; noexcept;
constexpr value_type&amp;&amp; value() &amp;&amp; noexcept;
constexpr const value_type&amp;&amp; value() const&amp;&amp; noexcept;

constexpr error_type&amp; error() &amp; noexcept;
constexpr const error_type&amp; error() const&amp; noexcept;
constexpr error_type&amp;&amp; error() &amp;&amp; noexcept;
constexpr const error_type&amp;&amp; error() const&amp;&amp; noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns the stored value or error, respectively.</p>
</div>
</div>
<div class="sect2">
<h3 id="_callbacks">Callbacks</h3>
<div class="listingblock">
<div class="title">The <code>Callback</code> concept</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">struct Callback
{
    using return_type = …;

    return_type operator()(Args&amp;&amp;... args) const;
};

struct Sink
{
    class _sink // exposition only
    {
    public:
        using return_type = …;

        void operator()(Args&amp;&amp;... args);

        return_type&amp;&amp; finish() &amp;&amp;;
    };

    _sink sink() const;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>Callback</code> is a function object whose return type is specified by a member typedef.
A <code>Sink</code> is a type with a <code>sink()</code> member function that returns a callback.
The callback can be invoked multiple times and the final value is return by calling <code>.finish()</code>.</p>
</div>
<div class="paragraph">
<p>Callbacks are used by <code>lexy</code> to compute the parse result and handle error values.
They can either be written manually implementing to the above concepts or composed from the pre-defined concepts.</p>
</div>
<div class="sect3">
<h4 id="_callback_adapters">Callback adapters</h4>
<div class="listingblock">
<div class="title"><code>lexy/callback.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename ReturnType = void, typename... Fns&gt;
    consteval Callback callback(Fns&amp;&amp;... fns);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a callback with the given <code>ReturnType</code> from multiple functions.
When calling the resulting callback, it will use overload resolution to determine the correct function to call.
Every function must either be an empty class (i.e. a stateless lambda), or a pointer to a (member) function or data member.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/callback.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename T, typename... Fns&gt;
    consteval Sink sink(Fns&amp;&amp;... fns);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Creates a sink constructing the given <code>T</code> using the given functions.
The sink will value-construct the <code>T</code> and then call one of the functions selected by overload resolution, passing it a reference to the resulting object as first argument.
Every function must either be an empty class (i.e. a stateless lambda), or a pointer to a (member) function or data member.</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>Creating a sink that will add all values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr auto adder = lexy::sink&lt;int&gt;([](int&amp; cur, int arg) { cur += arg; }); <i class="conum" data-value="1"></i><b>(1)</b>

auto s = adder.sink(); <i class="conum" data-value="2"></i><b>(2)</b>
s(1);
s(2);
s(3);
auto result = std::move(s).finish();
assert(result == 1 + 2 + 3);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Define the sink.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use it.</td>
</tr>
</table>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="_callback_composition">Callback composition</h4>
<div class="listingblock">
<div class="title"><code>lexy/callback.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename First, typename Second&gt;
    consteval auto operator|(First first, Second second);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of <code>g | h</code>, where <code>g</code> and <code>h</code> are both callbacks, is another callback that first invokes <code>g</code> and then passes the result to <code>h</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It does not compose sinks.
</td>
</tr>
</table>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>Build a string, then get its length.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr auto make_string = lexy::callback&lt;std::string&gt;([](const char* str) { return str; });
constexpr auto string_length = lexy::callback&lt;std::size_t&gt;(&amp;std::string::size);

constexpr auto inefficient_strlen = make_string | string_length; <i class="conum" data-value="1"></i><b>(1)</b>

assert(inefficient_strlen("1234") == 4); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Compose the two callbacks.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use it.</td>
</tr>
</table>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="_the_no_op_callback">The no-op callback</h4>
<div class="listingblock">
<div class="title"><code>lexy/callback.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    constexpr auto noop = /* unspecified */;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>lexy::noop</code> is both a callback and a sink.
It ignores all arguments passed to it and its return type is <code>void</code>.</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>Parse the production, but do nothing on errors.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">auto result = lexy::parse&lt;my_production&gt;(my_input, lexy::noop); <i class="conum" data-value="1"></i><b>(1)</b>
if (!result)
    throw my_parse_error(); <i class="conum" data-value="2"></i><b>(2)</b>
auto value = result.value(); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Parse <code>my_production</code>. If an error occurs, just return a <code>result&lt;T, void&gt;</code> in the error state.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>lexy::noop</code> does not make errors disappear, they still need to be handled.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Do something with the parsed value.</td>
</tr>
</table>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="_constructing_objects">Constructing objects</h4>
<div class="listingblock">
<div class="title"><code>lexy/callback.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename T&gt;
    constexpr auto forward = /* unspecified */;

    template &lt;typename T&gt;
    constexpr auto construct = /* unspecified */;

    template &lt;typename T, typename PtrT = T*&gt;
    constexpr auto new_ = /* unspecified */;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The callback <code>lexy::forward&lt;T&gt;</code> can accept either a <code>const T&amp;</code> or a <code>T&amp;&amp;</code> and forwards it.
It does not have a sink.</p>
</div>
<div class="paragraph">
<p>The callback <code>lexy::construct&lt;T&gt;</code> constructs a <code>T</code> by forwarding all arguments to a suitable constructor.
If the type does not have a constructor, it forwards all arguments using brace initialization.
It does not have a sink.</p>
</div>
<div class="paragraph">
<p>The callback <code>lexy::new_&lt;T, PtrT&gt;</code> works just like <code>lexy::construct&lt;T&gt;</code>, but it constructs the object on the heap by calling <code>new</code>.
The resulting pointer is then converted to the specified <code>PtrT</code>.
It does not have a sink.</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>A callback that creates a <code>std::unique_ptr&lt;std::string&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr auto make_unique_str = lexy::new_&lt;std::string, std::unique_ptr&lt;std::string&gt;&gt;; <i class="conum" data-value="1"></i><b>(1)</b>

constexpr auto make_unique_str2 = lexy::new_&lt;std::string&gt; | lexy::construct&lt;std::unique_ptr&lt;std::string&gt;&gt;; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Specify a suitable <code>PtrT</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Equivalent version that uses composition and <code>lexy::construct</code> instead.</td>
</tr>
</table>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="_constructing_lists">Constructing lists</h4>
<div class="listingblock">
<div class="title"><code>lexy/callback.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename T&gt;
    constexpr auto as_list = /* unspecified */;

    template &lt;typename T&gt;
    constexpr auto as_collection = /* unspecified */;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>lexy::as_list&lt;T&gt;</code> is both a callback and a sink.
As a callback, it forwards all arguments to the <code>std::initializer_list</code> constructor of <code>T</code> and returns the result.
As a sink, it first default constructs a <code>T</code> and then repeatedly calls <code>push_back()</code> for single arguments and <code>emplace_back()</code> otherwise.</p>
</div>
<div class="paragraph">
<p><code>lexy::as_collection&lt;T&gt;</code> is like <code>lexy::as_list&lt;T&gt;</code>, but instead of calling <code>push_back()</code> and <code>emplace_back()</code>, it calls <code>insert()</code> and <code>emplace()</code>.</p>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="paragraph">
<p>Create a <code>std::vector&lt;int&gt;</code> and <code>std::set&lt;int&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr auto as_int_vector = lexy::as_list&lt;std::vector&lt;int&gt;&gt;;
constexpr auto as_int_set = lexy::as_collection&lt;std::set&lt;int&gt;&gt;;</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="_constructing_strings">Constructing strings</h4>
<div class="listingblock">
<div class="title"><code>lexy/callback.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename String, typename Encoding = /* see below */&gt;
    constexpr auto as_string = /* unspecified */;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>lexy::as_string&lt;String, Encoding&gt;</code> is both a callback and a sink.
It constructs a <code>String</code> object in the given <code>Encoding</code>.
If no encoding is specified, it deduces one from the character type of the string.</p>
</div>
<div class="paragraph">
<p>As a callback, it constructs the string directly from the given argument.
Then it accepts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A reference to an existing <code>String</code> object, which is forwarded as the result.</p>
</li>
<li>
<p>A <code>const CharT*</code> and a <code>std::size_t</code>, where <code>CharT</code> is a compatible character type. The two arguments are forwarded to a <code>String</code> constructor.</p>
</li>
<li>
<p>A <code>lexy::lexeme&lt;Reader&gt; lex</code>, where <code>Reader::iterator</code> is a pointer.
The character type of the reader must be compatible with the encoding.
It constructs the string using <code>String(lex.data(), lex.size())</code> (potentially casting the pointer type if necessary).</p>
</li>
<li>
<p>A <code>lexy::lexeme&lt;Reader&gt; lex</code>, where <code>Reader::iterator</code> is not a pointer.
It constructs the string using <code>String(lex.begin(), lex.end())</code>.
The range constructor has to take care of any necessary character conversion.</p>
</li>
<li>
<p>A <code>lexy::code_point</code>. It is encoded into a local character array according to the specified <code>Encoding</code>.
Then the string is constructed using a two-argument <code>(const CharT*, std::size_t)</code> constructor.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a sink, it first default constructs the string.
Then it will repeatedly append the following arguments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A single <code>CharT</code>, which is convertible to the strings character type.
It is appended by calling <code>.push_back()</code>.</p>
</li>
<li>
<p>A reference to an existing <code>String</code> object, which is appended by calling <code>.append()</code>.</p>
</li>
<li>
<p>A <code>const CharT*</code> and a <code>std::size_t</code>, where <code>CharT</code> is a compatible character type.
The two arguments are forwarded to <code>.append()</code>.</p>
</li>
<li>
<p>A <code>lexy::lexeme&lt;Reader&gt; lex</code>, where <code>Reader::iterator</code> is a pointer.
The character type of the reader must be compatible with the encoding.
It is appended using <code>.append(lex.data(), lex.size())</code> (potentially casting the pointer type if necessary).</p>
</li>
<li>
<p>A <code>lexy::lexeme&lt;Reader&gt; lex</code>, where <code>Reader::iterator</code> is not a pointer.
It constructs the string using <code>.append(lex.begin(), lex.end())</code>.
The range append function has to take care of any necessary character conversion.</p>
</li>
<li>
<p>A <code>lexy::code_point</code>. It is encoded into a local character array according to the specified <code>Encoding</code>.
Then it is appended to the string using a two-argument <code>.append(const CharT*, std::size_t)</code> overload.</p>
</li>
</ul>
</div>
<details>
<summary class="title">Example</summary>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr auto as_utf16_string = lexy::as_string&lt;std::u16string&gt;;                   <i class="conum" data-value="1"></i><b>(1)</b>
constexpr auto as_utf8_string  = lexy::as_string&lt;std::string, lexy::utf8_encoding&gt;; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Constructs a <code>std::u16string</code>, deducing the encoding as UTF-16.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Constructs a <code>std::string</code>, specifying the encoding as UTF-8.</td>
</tr>
</table>
</div>
</div>
</details>
</div>
<div class="sect3">
<h4 id="_rule_specific_callbacks">Rule-specific callbacks</h4>
<div class="listingblock">
<div class="title"><code>lexy/callback.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename T&gt;
    constexpr auto as_aggregate = /* unspecified */;

    template &lt;typename T&gt;
    constexpr auto as_integer = /* unspecified */;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The callback and sink <code>lexy::as_aggregate&lt;T&gt;</code> is only used together with the <code>lexy::dsl::member</code> rule and documented there.</p>
</div>
<div class="paragraph">
<p>The callback <code>lexy::as_integer&lt;T&gt;</code> constructs an integer type <code>T</code> and has two overloads:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template &lt;typename Integer&gt;
T operator()(const Integer&amp; value) const; <i class="conum" data-value="1"></i><b>(1)</b>

template &lt;typename Integer&gt;
T operator()(int sign, const Integer&amp; value) const; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Returns <code>T(value)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Returns <code>T(sign * value)</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The second overload is meant to be used together with <code>lexy::dsl::sign</code> and related rules.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_error_handling">Error handling</h3>
<div class="paragraph">
<p>Parsing errors are reported by constructing a <code>lexy::error</code> object and passing it to the error callback of <code>lexy::parse</code> and <code>lexy::validate</code> together with the <code>lexy::error_context</code>.</p>
</div>
<div class="paragraph">
<p>As such, an error callback looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">class ErrorCallback
{
public:
    using return_type = /* … */;

    template &lt;typename Production, typename Input, typename Tag&gt;
    return_type operator()(const lexy::error_context&lt;Production, Input&gt;&amp; context,
                           const lexy::error&lt;lexy::input_reader&lt;Input&gt;, Tag&gt;&amp; error) const;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, overloading can be used to differentiate between various error types and contexts.</p>
</div>
<div class="sect3">
<h4 id="_error_types">Error types</h4>
<div class="listingblock">
<div class="title"><code>lexy/error.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Reader, typename Tag&gt;
    class error;

    struct expected_literal {};
    template &lt;typename Reader&gt;
    class error&lt;Reader, expected_literal&gt;;

    struct expected_char_class {};
    template &lt;typename Reader&gt;
    class error&lt;Reader, expected_char_class&gt;;

    template &lt;typename Input, typename Tag&gt;
    using error_for = error&lt;input_reader&lt;Input&gt;, Tag&gt;;

    template &lt;typename Reader, typename Tag, typename ... Args&gt;
    constexpr auto make_error(Args&amp;&amp;... args);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All errors are represented by instantiations of <code>lexy::error&lt;Reader, Tag&gt;</code>.
The <code>Tag</code> is an empty type that specifies the kind of error.
There are specializations for two tags to store additional information.</p>
</div>
<div class="paragraph">
<p>The function <code>lexy::make_error</code> constructs an error object given the reader and tag by forwarding all the arguments.</p>
</div>
<div class="sect4">
<h5 id="_generic_error">Generic error</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template &lt;typename Reader, typename Tag&gt;
class error
{
    using iterator = typename Reader::iterator;

public:
    constexpr explicit error(iterator pos) noexcept;
    constexpr explicit error(iterator begin, iterator end) noexcept;

    constexpr iterator position() const noexcept;

    constexpr iterator begin() const noexcept;
    constexpr iterator end() const noexcept;

    constexpr /* see below */ message() const noexcept;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The primary class template <code>lexy::error&lt;Reader, Tag&gt;</code> represents a generic error without additional metadata.
It can either be constructed giving it a single position, then <code>position() == begin() == end()</code>;
or a range of the input, then <code>position() == begin() &#8656; end()</code>.</p>
</div>
<div class="paragraph">
<p>The <code>message()</code> is determined using the <code>Tag</code>.
By default, it returns the type name of <code>Tag</code> after removing the top-level namespace name.
This can be overridden by defining either <code>Tag::name()</code> or <code>Tag::name</code>.
The result is an unspecified type similar to <code>std::string_view</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_expected_literal_error">Expected literal error</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">struct expected_literal
{};

template &lt;typename Reader&gt;
class error&lt;Reader, expected_literal&gt;
{
    using iterator    = typename Reader::iterator;
    using string_view = /* see below */;

public:
    constexpr explicit error(iterator position,
                             string_view string, std::size_t index) noexcept;

    constexpr iterator position() const noexcept;

    constexpr string_view string() const noexcept;
    constexpr string_view::char_type character() const noexcept;

    constexpr std::size_t index() const noexcept;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A specialization of <code>lexy::error</code> is provided if <code>Tag == lexy::expected_literal</code>.
It represents the error where a literal string was expected, but could not be matched.
It is mainly raised by the <code>lexy::dsl::lit</code> rule.</p>
</div>
<div class="paragraph">
<p>The error happens at a given <code>position()</code> and with a given <code>string()</code>.
The <code>index()</code> is the index into the string where matching failed; e.g. <code>0</code> if the input starts with a different character, <code>2</code> if the first two characters matched, etc.
The <code>character()</code> is the string character at that index.</p>
</div>
<div class="paragraph">
<p>The unspecified <code>string_view</code> type is like <code>std::string_view</code>.
Its character type must match the encoding of the <code>Reader</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_character_class_error">Character class error</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">struct expected_char_class
{};

template &lt;typename Reader&gt;
class error&lt;Reader, expected_char_class&gt;
{
    using iterator = typename Reader::iterator;

public:
    constexpr explicit error(iterator position, const char* name) noexcept;

    constexpr iterator position() const noexcept;

    constexpr /* see below */ name() const noexcept;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A specialization of <code>lexy::error</code> is provided if <code>Tag == lexy::expected_char_class</code>.
It represents the error where any character from a given set of characters was expected, but could not be matched.
It is raised by the <code>lexy::dsl::ascii::*</code> rules or <code>lexy::dsl::newline</code>, among others.</p>
</div>
<div class="paragraph">
<p>The error happens at the given <code>position()</code> and a symbolic name of the character class is returned by <code>name()</code>.
The return type of <code>name()</code> is an unspecified type similar to <code>std::string_view</code>.</p>
</div>
<div class="paragraph">
<p>By convention, the name format used is <code>&lt;group&gt;.&lt;name&gt;</code> or <code>&lt;name&gt;</code>, where both <code>&lt;group&gt;</code> and <code>&lt;name&gt;</code> consist of characters.
Examples include <code>newline</code>, <code>ASCII.alnum</code> and <code>digit.decimal</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_error_context">Error context</h4>
<div class="listingblock">
<div class="title"><code>lexy/error.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Production, typename Input&gt;
    class error_context
    {
        using iterator = typename input_reader&lt;Input&gt;::iterator;

    public:
        constexpr explicit error_context(const Input&amp; input, iterator pos) noexcept;

        constexpr const Input&amp; input() const noexcept;

        static consteval /* see below */ production();

        constexpr iterator position() const noexcept;
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class <code>lexy::error_context&lt;Production, Input&gt;</code> contain information about the context where the error occurred.</p>
</div>
<div class="paragraph">
<p>The entire input containing the error is returned by <code>input()</code>.</p>
</div>
<div class="paragraph">
<p>The <code>Production</code> whose rule has raised the error is specified as template parameter and its name returned by <code>production()</code>.
Like <code>lexy::error&lt;Reader, Tag&gt;::message()</code>, it returns the name of the type without the top level namespace name.
This can be overridden by defining <code>Production::name()</code> or <code>Production::name</code>.
The result is an unspecified type similar to <code>std::string_view</code>.</p>
</div>
<div class="paragraph">
<p>The <code>position()</code> of the error context is the input position where the production started parsing.</p>
</div>
</div>
<div class="sect3">
<h4 id="_error_location">Error location</h4>
<div class="listingblock">
<div class="title"><code>lexy/error_location.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Reader&gt;
    struct error_location
    {
        std::size_t line, column;
        lexeme&lt;Reader&gt; context;
    };

    template &lt;typename Input&gt;
    using error_location_for = error_location&lt;input_reader&lt;Input&gt;&gt;;

    template &lt;typename Input, typename TokenCP, typename TokenNL&gt;
    constexpr auto make_error_location(const Input&amp; input,
                                       typename input_reader&lt;Input&gt;::iterator pos,
                                       TokenCP code_point_token,
                                       TokenNL newline_token)
        -&gt; error_location_for&lt;Input&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The header <code>lexy/error_location.hpp</code> provides a utility function <code>lexy::make_error_location()</code> to convert an error position,
which is always given via an iterator, into the traditional line/column format.</p>
</div>
<div class="paragraph">
<p>The function takes the position into the input, as well as two tokens.
It then determines the line and column by repeatedly parsing the two tokens until the error position is reached.
Every time the <code>code_point_token</code> matches, the column is increased by one.
Every time the <code>newline_token</code> matches, the column is reset to one and the line increased by one.
If neither token matches, column is increased by one and the next code unit skipped.
The final line and column number are returned, together with the <code>context</code> which is a lexeme containing the entire line where the error occurred.</p>
</div>
<div class="paragraph">
<p>For ASCII encoded texts, the <code>code_point_token</code> is <code>lexy::dsl::ascii::character</code> and the <code>newline_token</code> is <code>lexy::dsl::newline</code>.
For Unicode encoded texts, the <code>code_point_token</code> is <code>lexy::dsl::code_point</code> and the <code>newline_token</code> is <code>lexy::dsl::newline</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_rule_dsl">The rule DSL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The rule of a production is specified using a DSL built on top of C++ operator overloading.
Everything of the DSL is defined in the namespace <code>lexy::dsl::*</code> and every header available under <code>lexy/dsl/*</code>.
The umbrella header <code>lexy/dsl.hpp</code> includes all DSL headers.</p>
</div>
<div class="paragraph">
<p>A <code>Rule</code> is an object that defines a specific set of input to be parsed.
It first tries to match a set of characters from the input by comparing the character at the current reader position to the set of expected characters,
temporarily advancing the reader further if necessary.
If the matching was successful, a subset of matched characters are consumed by advancing the reader permanently.
The rule can then produce zero or more values, which are eventually forwarded to the value callback of its production.
If the matching was not successful, an error is produced instead.
A failed rule does not consume any characters.</p>
</div>
<div class="paragraph">
<p>A <code>Branch</code> is a rule that has an associated condition.
The parsing algorithm can efficiently check whether the condition would match at the current reader position.
As such, they are used whenever the algorithm needs to decide between multiple alternatives.
Once the branch condition matches, the branch is taken without any additional backtracking.</p>
</div>
<div class="paragraph">
<p>A <code>Token</code> is a special <code>Rule</code> that is an atomic element of the input.
As a rule, it does not produce any value.
Every <code>Token</code> is also a <code>Branch</code> that uses itself as the condition.</p>
</div>
<div class="sect2">
<h3 id="_whitespace">Whitespace</h3>
<h4 id="_lexydslwhitespaced" class="discrete"><code>lexy::dsl::whitespaced</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/whitespace.hpp</code></div>
<div class="content">
<pre>whitespaced(rule, whitespace) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>By default, no whitespace skipping is done.
Use <code>whitespaced()</code> to skip arbitrary long whitespace before parsing a rule.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p><code>whitespace</code> is a branch that does not produce any values</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Equivalent to
</td>
<td class="hdlist2">
<p><code>token(while_(whitespace)) + rule</code></p>
</td>
</tr>
</table>
</div>
<details id="r5b8Gb">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/r5b8Gb" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Skips whitespace and then parses `abc`.
dsl::whitespaced(LEXY_LIT("abc"), dsl::ascii::space)</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
"whitespace" can mean literal space characters but also things like comments.
</td>
</tr>
</table>
</div>
<h4 id="_ruleoperator" class="discrete"><code>Rule::operator[]</code></h4>
<div class="listingblock">
<div class="content">
<pre>rule[whitespace]    : Rule
token[whitespace]   : Token
branch[whitespace]  : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>Some rules also provide an <code>operator[]</code> that does the same as <code>whitespaced()</code>.
They are here described as whitespace aware.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p><code>whitespace</code> is a branch that does not produce any values</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Equivalent to
</td>
<td class="hdlist2">
<p><code>whitespaced(rule, whitespace)</code></p>
</td>
</tr>
</table>
</div>
<details id="sqdze6">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/sqdze6" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Skips whitespace and then parses `abc`.
LEXY_LIT("abc")[dsl::ascii::space]</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect2">
<h3 id="_primitive_tokens">Primitive Tokens</h3>
<h4 id="_lexydslany" class="discrete"><code>lexy::dsl::any</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/any.hpp</code></div>
<div class="content">
<pre>any : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>any</code> token matches anything, i.e. all the remaining input.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>All the remaining input.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p>n/a (it never fails)</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>any</code> is useful in combination with partial inputs such as the minus rule or <code>switch_</code>.
</td>
</tr>
</table>
</div>
<h4 id="_lexydsllit" class="discrete"><code>lexy::dsl::lit</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/literal.hpp</code></div>
<div class="content">
<pre>lit_c&lt;C&gt; : Token
lit&lt;Str&gt; : Token

LEXY_LIT(Str) : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The literal tokens match the specified sequence of characters.
They are whitespace aware.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>C</code> is a character literal.</p>
</li>
<li>
<p><code>Str</code> is a string literal.</p>
<div class="paragraph">
<p>In both cases, their encoding must be ASCII or match the encoding of the input.</p>
</div>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>The specified character or string of characters, which are consumed.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p><code>lexy::expected_literal</code> giving it the string and the index where the match failure occurred.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>lit&lt;Str&gt;</code> requires C++20 support for extended NTTPs.
Use the <code>LEXY_LIT(Str)</code> macro if your compiler does not support them.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/punctuator.hpp</code></div>
<div class="content">
<pre>period    : Token = lit&lt;"."&gt;
comma     : Token = lit&lt;","&gt;
colon     : Token = lit&lt;":"&gt;
semicolon : Token = lit&lt;";"&gt;

hyphen     : Token = lit&lt;"-"&gt;
slash      : Token = lit&lt;"/"&gt;
backslash  : Token = lit&lt;"\\"&gt;
apostrophe : Token = lit&lt;"'"&gt;

hash_sign   : Token = lit&lt;"#"&gt;
dollar_sign : Token = lit&lt;"$"&gt;
at_sign     : Token = lit&lt;"@"&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The header <code>lexy/dsl/punctuator.hpp</code> defines common punctuator literals.
They are equivalent to a literal matching the specified character.
They are whitespace aware.</p>
</div>
</div>
<div class="sect2">
<h3 id="_character_classes">Character classes</h3>
<h4 id="_lexydsleof" class="discrete"><code>lexy::dsl::eof</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/eof.hpp</code></div>
<div class="content">
<pre>eof : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>eof</code> token matches EOF.
It is whitespace aware.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Only if the reader is at the end of the input. It does not consume anything (it can&#8217;t).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p><code>lexy::expected_char_class</code> with the name <code>EOF</code>.</p>
</td>
</tr>
</table>
</div>
<h4 id="_lexydslnewline" class="discrete"><code>lexy::dsl::newline</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/newline.hpp</code></div>
<div class="content">
<pre>newline : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>newline</code> token matches a newline.
It is whitespace aware.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p><code>\n</code> or <code>\r\n</code>, which is consumed.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p><code>lexy::expected_char_class</code> with the name <code>newline</code>.</p>
</td>
</tr>
</table>
</div>
<h4 id="_lexydsleol" class="discrete"><code>lexy::dsl::eol</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/newline.hpp</code></div>
<div class="content">
<pre>eol : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>eol</code> token matches an end-of-line (EOL).
It is whitespace aware.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p><code>\n</code> or <code>\r\n</code>, which is consumed.
Also matches EOF, which is not consumed.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p><code>lexy::expected_char_class</code> with the name <code>EOL</code>.</p>
</td>
</tr>
</table>
</div>
<h4 id="_lexydslascii" class="discrete"><code>lexy::dsl::ascii::*</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/ascii.hpp</code></div>
<div class="content">
<pre>namespace ascii
{
    control : Token // 0x00-0x1F, 0x7F

    blank       : Token // ' ' (space character) or '\t'
    newline     : Token // '\n' or '\r'
    other_space : Token // '\f' or '\v'
    space       : Token // `blank` or `newline` or `other_space`

    lower : Token // a-z
    upper : Token // A-Z
    alpha : Token // `lower` or `upper`

    digit : Token // 0-9
    alnum : Token // `digit` or `alpha`

    punct : Token // One of: !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~

    graph : Token // `alnum` or `punct`
    print : Token // `graph` or ' ' (space characters)

    character : Token // 0x00-0x7F
}</pre>
</div>
</div>
<div class="paragraph">
<p>All tokens defined in <code>lexy::dsl::ascii</code> match one of the categories of ASCII characters.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes one of the set of ASCII characters indicated in the comments.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>A <code>lexy::expected_char_class</code> error with name <code>ASCII.&lt;token&gt;</code>, where <code>&lt;token&gt;</code> is the name of the token.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Every ASCII character except for the space character is in exactly one of <code>control</code>, <code>lower</code>, <code>upper</code>, <code>digit</code> or <code>punct</code>.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslcode_point" class="discrete"><code>lexy::dsl::code_point</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/code_point.hpp</code></div>
<div class="content">
<pre>code_point : Token

code_point.capture() : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>code_point</code> token will match and consume a well-formed Unicode code point according to the encoding of the input.
If <code>code_point.capture()</code> is used, the consumed code point will be produced as value.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>The encoding of the input is <code>lexy::ascii_encoding</code>, <code>lexy::utf8_encoding</code>, <code>lexy::utf16_encoding</code>, or <code>lexy::utf32_encoding</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes all code units of the next code point.
For ASCII and UTF-32 this is only one, but for UTF-8 and UTF-16 it can be multiple code units.
If the code point is too big or a UTF-16 surrogate, it fails.
For UTF-8, it also fails for overlong sequences.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>If <code>.capture()</code> was called, it will produce the matched code point as a <code>lexy::code_point</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>If it could not match a valid code point, it fails with a <code>lexy::expected_char_class</code> error with name <code>&lt;encoding&gt;.code_point</code>.</p>
</td>
</tr>
</table>
</div>
<details id="YYTfoe">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/YYTfoe" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Match and capture one arbitrary code point.
dsl::code_point.capture()</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you want to match a specific code point, use a literal rule instead.
This rule is useful for matching things like string literals that can contain arbitrary code points.
</td>
</tr>
</table>
</div>
<h4 id="_lexydsloperator" class="discrete"><code>lexy::dsl::operator-</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/minus.hpp</code></div>
<div class="content">
<pre>token - except : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The minus rule matches the given token, but only if <code>except</code> does not match on the input the rule has consumed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p><code>except</code> is a token.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes whatever <code>token</code> match and consume.
Then matches <code>except</code> on the same input.
Matching fails if <code>except</code> matches the entire input consumed by the token.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>Whatever errors are raised if <code>token</code> is not matched.
A generic error with tag <code>lexy::minus_failure</code> if <code>except</code> has matched.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use a minus rule to exclude characters from a character class; e.g. <code>lexy::dsl::code_point - lexy::dsl::ascii::control</code> matches all code points except control characters.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Minus rules can be chained. This is equivalent to specifying an alternative for <code>except</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>except</code> has to match <em>everything</em> the rule has consumed before; partial matches don&#8217;t count.
Use <code>token - (except + lexy::dsl::any)</code> if you want to allow a partial match.
</td>
</tr>
</table>
</div>
<h4 id="_lexydsltoken" class="discrete"><code>lexy::dsl::token</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/token.hpp</code></div>
<div class="content">
<pre>token(rule) : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>token</code> rule turns an arbitrary rule into a token by parsing it and discarding all values it has produced.
It is whitespace aware.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Whatever <code>rule</code> matches, which will be consumed.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p>A generic error with tag <code>lexy::missing_token</code> if the <code>rule</code> did not match.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While <code>token()</code> is optimized to prevent any overhead created by constructing values that are later discarded,
it still should only be used when required.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_values">Values</h3>
<div class="paragraph">
<p>The following rules are used to produce additional values without any additional matching.</p>
</div>
<h4 id="_lexydslvalue" class="discrete"><code>lexy::dsl::value_*</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/value.hpp</code></div>
<div class="content">
<pre>value_c&lt;Value&gt; : Rule
value_f&lt;Fn&gt;    : Rule
value_t&lt;T&gt;     : Rule
value_str&lt;Str&gt; : Rule

LEXY_VALUE_STR(Str) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>value_*</code> rules create a constant value without parsing anything.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>Value</code> is any constant.</p>
</li>
<li>
<p><code>Fn</code> is a pointer to a function taking no arguments.</p>
</li>
<li>
<p><code>T</code> is a default-constructible type.</p>
</li>
<li>
<p><code>Str</code> is a string literal.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Any input, but does not consume anything.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Value
</td>
<td class="hdlist2">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>value_c</code></dt>
<dd>
<p>The specified constant.</p>
</dd>
<dt class="hdlist1"><code>value_f</code></dt>
<dd>
<p>The result of invoking the function.</p>
</dd>
<dt class="hdlist1"><code>value_t</code></dt>
<dd>
<p>A default constructed object of the specified type.</p>
</dd>
<dt class="hdlist1"><code>value_str</code></dt>
<dd>
<p>The string literal as a pointer, followed by its size.</p>
</dd>
</dl>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p>n/a (it does not fail)</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use the <code>value_*</code> rules only to create symmetry between different branches.
Everything they do, can also be achieved using callbacks, which is usually a better solution.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The function might not be called or the object might not be constructed in all situations. You cannot rely on their side effects.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>value_str&lt;Str&gt;</code> requires C++20 support for extended NTTPs.
Use the <code>LEXY_VALUE_STR(Str)</code> macro if your compiler does not support them.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslnullopt" class="discrete"><code>lexy::dsl::nullopt</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/option.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    struct nullopt
    {
        template &lt;typename T&gt;
        constexpr operator T() const
        {
            return T();
        }
    };
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/option.hpp</code></div>
<div class="content">
<pre>nullopt : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>nullopt</code> rule produces a value of type <code>lexy::nullopt</code> without parsing anything.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Any input, but does not consume anything.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Value
</td>
<td class="hdlist2">
<p>An object of type <code>lexy::nullopt</code>, which is convertible to any other type.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p>n/a (it does not fail)</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is meant to be used for symmetry with together with the <code>opt()</code> rule.
</td>
</tr>
</table>
</div>
<h4 id="_lexydsllabel_and_lexydslid" class="discrete"><code>lexy::dsl::label</code> and <code>lexy::dsl::id</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/label.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;typename Tag&gt;
    struct label
    {
        // only if Tag::value is well-formed
        consteval operator auto() const
        {
            return Tag::value;
        }
    };

    template &lt;auto Id&gt;
    using id = label&lt;std::integral_constant&lt;int, Id&gt;&gt;;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/label.hpp</code></div>
<div class="content">
<pre>label&lt;Tag&gt; : Rule
id&lt;Id&gt;     : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>label</code> and <code>id</code> rules are used to disambiguate between two branches that create otherwise the same values but should resolve to different callbacks.
They simply produce the empty tag object or the id to differentiate them without parsing anything.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>Tag</code> is any type.</p>
</li>
<li>
<p><code>Id</code> is an integer constant.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Any input, but does not consume anything.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Value
</td>
<td class="hdlist2">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>label&lt;Tag&gt;</code></dt>
<dd>
<p>A <code>lexy::label&lt;Tag&gt;</code> object.</p>
</dd>
<dt class="hdlist1"><code>id&lt;Id&gt;</code></dt>
<dd>
<p>A <code>lexy::id&lt;Id&gt;</code> object.</p>
</dd>
</dl>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p>n/a (it does not fail)</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/label.hpp</code></div>
<div class="content">
<pre>label&lt;Tag&gt;(rule)   : Rule   = label&lt;Tag&gt; + rule
label&lt;Tag&gt;(branch) : Branch = /* as above, except as branch */

id&lt;Id&gt;(rule)   : Rule   = id&lt;Id&gt; + rule
id&lt;Id&gt;(branch) : Branch = /* as above, except as branch */</pre>
</div>
</div>
<div class="paragraph">
<p>For convenience, <code>label</code> and <code>id</code> have function call operators.
They produce the label/id and then parse the rule.</p>
</div>
<h4 id="_lexydslcapture" class="discrete"><code>lexy::dsl::capture</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/capture.hpp</code></div>
<div class="content">
<pre>capture(rule)   : Rule
capture(branch) : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>capture()</code> rule takes an arbitrary rule and parses it, capturing everything it has consumed into a <code>lexy::lexeme</code>.
It is a branch if given a branch.
It is whitespace aware; preceding whitespace is not captured.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Branch Condition
</td>
<td class="hdlist2">
<p>The branch condition is whatever <code>branch</code> uses as a branch condition.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes whatever <code>rule</code> matches.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>A <code>lexy::lexeme</code> which begins at the original reader position and ends at the reader position after <code>rule</code> has been parsed,
followed by any other values produced by parsing the <code>rule</code> in the same order.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised by <code>rule</code>. It cannot fail itself.</p>
</td>
</tr>
</table>
</div>
<details id="77jfM5">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/77jfM5" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Captures the entire input.
dsl::capture(dsl::any)</code></pre>
</div>
</div>
</div>
</details>
<h4 id="_lexydslposition" class="discrete"><code>lexy::dsl::position</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/position.hpp</code></div>
<div class="content">
<pre>position : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>position</code> rule creates as its value an iterator to the current reader position without consuming any input.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Any input, but does not consume anything.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Value
</td>
<td class="hdlist2">
<p>An iterator to the current position of the reader.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p>n/a (it does not fail)</p>
</td>
</tr>
</table>
</div>
<details id="Wh86vn">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/Wh86vn" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Parses the entire input and returns the final position.
dsl::any + dsl::position</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <code>position</code> when creating an AST whose nodes are annotated with their original source position.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_errors">Errors</h3>
<div class="paragraph">
<p>The following rules are used to customize/improve error messages.</p>
</div>
<h4 id="_errortag" class="discrete"><code>.error&lt;Tag&gt;()</code></h4>
<div class="listingblock">
<div class="content">
<pre>token.error&lt;Tag&gt;() : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>error()</code> function on tokens changes the error that is raised when a token failed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes what <code>token</code> matches.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p>A generic error with the specified <code>Tag</code>.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It is useful for tokens such as <code>dsl::token()</code> and <code>operator-</code>, where the result is a generic tag such as <code>lexy::missing_token</code> or <code>lexy::minus_failure</code>.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslerror" class="discrete"><code>lexy::dsl::error</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/error.hpp</code></div>
<div class="content">
<pre>error&lt;Tag&gt;       : Branch
error&lt;Tag&gt;(rule) : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>error</code> rule always fails and produces an error with the given tag.
For the second version, the rule is matched first to determine the error range.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Branch Condition
</td>
<td class="hdlist2">
<p>Branch is always taken.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Nothing and always fails.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p>An error object of the specified <code>Tag</code>.
If the optional <code>rule</code> is given, it will be matched (without producing values or errors).
If it matched successfully, the previous and new reader position will be used to determine the error range.
Otherwise, the error has no range.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use it as the final branch of a choice rule to customize the <code>lexy::exhausted_choice</code> error.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslrequire_and_lexydslprevent" class="discrete"><code>lexy::dsl::require</code> and <code>lexy::dsl::prevent</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/error.hpp</code></div>
<div class="content">
<pre>require&lt;Tag&gt;(rule) : Rule
prevent&lt;Tag&gt;(rule) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>require</code> and <code>prevent</code> rules can be used to lookahead and fail if the input matches or does not match the token.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Both match the <code>rule</code> without consuming input (or producing values or errors).
<code>require</code> fails if the <code>rule</code> did not match; <code>rule</code> fails if it did.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Error
</td>
<td class="hdlist2">
<p>An error object of the specified <code>Tag</code>.</p>
</td>
</tr>
</table>
</div>
<details id="n7zM4d">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/n7zM4d" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Parses a sequence of digits but raises an error with tag `forbidden_leading_zero` if a zero is followed by more digits.
// Note: this is already available as `dsl::digits&lt;&gt;.no_leading_zero()`.
dsl::zero &gt;&gt; dsl::prevent&lt;forbidden_leading_zero&gt;(dsl::digits&lt;&gt;)
    | dsl::digits&lt;&gt;</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <code>prevent</code> together with <code>times</code> to prevent the rule from matching more than the specified number of times.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_branch_conditions">Branch conditions</h3>
<div class="paragraph">
<p>The following rules are designed to be used as the condition of an <code>operator&gt;&gt;</code>.
They have no effect if not used in a context that requires a branch.</p>
</div>
<h4 id="_lexydslelse" class="discrete"><code>lexy::dsl::else_</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/branch.hpp</code></div>
<div class="content">
<pre>else_ : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>If <code>else_</code> is used as a condition, that branch will be taken unconditionally.
It must be used as a last alternative in a choice.</p>
</div>
<h4 id="_lexydslpeek" class="discrete"><code>lexy::dsl::peek</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/peek.hpp</code></div>
<div class="content">
<pre>peek(rule) : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>peek</code> branch is taken if <code>rule</code> matches, but does not consume it.
It is whitespace aware; leading whitespace will be consumed.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Long lookahead can slow down parsing speed due to backtracking.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslpeek_not" class="discrete"><code>lexy::dsl::peek_not</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/peek.hpp</code></div>
<div class="content">
<pre>peek_not(rule) : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>peek_not()</code> branch is taken if <code>rule</code> does not match, but does not consume it.
It is whitespace aware; leading whitespace will be consumed.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Long lookahead can slow down parsing speed due to backtracking.
</td>
</tr>
</table>
</div>
<h4 id="_lexydsllookahead" class="discrete"><code>lexy::dsl::lookahead</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/lookahead.hpp</code></div>
<div class="content">
<pre>lookahead(needle, end) : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>lookahead</code> branch is taken if lookahead finds <code>needle</code> before <code>end</code> is found, which must both be tokens.
No characters are consumed.
It is whitespace aware; leading whitespace will be consumed.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Long lookahead can slow down parsing speed due to backtracking.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_branches">Branches</h3>
<h4 id="_lexydsloperator_2" class="discrete"><code>lexy::dsl::operator+</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/sequence.hpp</code></div>
<div class="content">
<pre>rule + rule   : Rule
token + token : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>A sequence rule matches multiple rules one after the other.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Branch Condition
</td>
<td class="hdlist2">
<p>The branch is only taken if all the tokens match in sequence.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consume the first rule, then matches and consumes the second rule, and so on.
Only succeeds if all of them succeed.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>All the values produced by the rules in the same order as they were matched.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>Whatever errors are raised by the individual rules.</p>
</td>
</tr>
</table>
</div>
<h4 id="_lexydsloperator_3" class="discrete"><code>lexy::dsl::operator&gt;&gt;</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/branch.hpp</code></div>
<div class="content">
<pre>branch &gt;&gt; rule : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>operator&gt;&gt;</code> is used to turn a rule into a branch by giving it a branch condition, which must be a branch itself.
If the branch is used as a normal rule, it first matches the condition followed by the rule.
If it is used in a context that requires a branch, the branch is checked to determine whether it should be taken.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Branch Condition
</td>
<td class="hdlist2">
<p>Whatever <code>branch</code> uses as branch condition.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consume the branch, then matches and consumes the <code>rule</code>.
Only succeeds if all of them succeed.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>All the values produced by the branch and rule in the same order as they were matched.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>Whatever errors are raised by the individual branch and rule.</p>
</td>
</tr>
</table>
</div>
<h4 id="_lexydslif" class="discrete"><code>lexy::dsl::if_</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/if.hpp</code></div>
<div class="content">
<pre>if_(branch) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>if_</code> rule matches a branch only if its condition matches.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>First matches the branch condition.
If that succeeds, consumes it and matches and consumes the rest of the branch.
Otherwise, consumes nothing and succeeds anyway.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>Any values produced by the branch.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>Any errors produced by the branch.
It will only fail after the condition has been matched.</p>
</td>
</tr>
</table>
</div>
<details id="GaxjbP">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/GaxjbP" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Matches an optional C style comment.
dsl::if_(LEXY_LIT("/*") &gt;&gt; dsl::until(LEXY_LIT("*/")))</code></pre>
</div>
</div>
</div>
</details>
<h4 id="_lexydslopt" class="discrete"><code>lexy::dsl::opt</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/opt.hpp</code></div>
<div class="content">
<pre>opt(branch) : Rule = branch | else_ &gt;&gt; nullopt</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>opt</code> rule matches a branch only if its condition matches.
Unlike <code>if_</code>, if the branch was not taken, it produces a <code>lexy::nullopt</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>First matches the branch condition.
If that succeeds, consumes it and matches and consumes the rest of the branch.
Otherwise, consumes nothing and succeeds anyway.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>If the branch condition matches, any values produced by the rule.
Otherwise, a single object of type <code>lexy::nullopt</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>Any errors produced by the branch.
It will only fail after the condition has been matched.</p>
</td>
</tr>
</table>
</div>
<details id="nq33hY">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/nq33hY" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Matches an optional list of alpha characters.
// (The id&lt;0&gt; is just there, so the sink will be invoked on each character).
// If no items are present, it will default construct the list type.
dsl::opt(dsl::list(dsl::ascii::alpha &gt;&gt; dsl::id&lt;0&gt;))</code></pre>
</div>
</div>
</div>
</details>
<h4 id="_lexydsloperator_4" class="discrete"><code>lexy::dsl::operator|</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/choice.hpp</code></div>
<div class="content">
<pre>branch  | branch  : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>A choice rule matches the first branch in order whose condition was matched.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Tries to match the condition of each branch in the order they were specified.
As soon as one branch condition matches, matches and consumes that branch without ever backtracking to try another branch.
If no branch condition matched, fails without consuming anything.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>Any values produced by the selected branch.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>Any errors raised by the then of the selected branch.
If no branch condition matched, a generic error with tag <code>lexy::exhausted_choice</code>.</p>
</td>
</tr>
</table>
</div>
<details id="aaEnW7">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/aaEnW7" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// A contrived example to illustrate the behavior of choice.
// Note that branch with id 1 will never be taken, as branch 0 takes everything starting with a and then fails if it isn't followed by bc.
// The correct behavior is illustrated with 2 and 3, there the branch with the longer condition is listed first.
dsl::id&lt;0&gt;(LEXY_LIT("a") &gt;&gt; LEXY_LIT("bc"))
  | dsl::id&lt;1&gt;(LEXY_LIT("a") &gt;&gt; LEXY_LIT("b"))
  | dsl::id&lt;2&gt;(LEXY_LIT("bc"))
  | dsl::id&lt;3&gt;(LEXY_LIT("b"))</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The C++ operator precedence is specified in such a way that <code>condition &gt;&gt; a | else_ &gt;&gt; b</code> works.
The compiler might warn that the precedence is not intuitive without parentheses, but in the context of this DSL it is the expected result.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <code>… | error&lt;Tag&gt;</code> to raise a custom error instead of <code>lexy::exhausted_choice</code>.
</td>
</tr>
</table>
</div>
<h4 id="_lexydsloperator_5" class="discrete"><code>lexy::dsl::operator/</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/alternative.hpp</code></div>
<div class="content">
<pre>token / token : Token</pre>
</div>
</div>
<div class="paragraph">
<p>An alternative rule tries to match each token in order, backtracking if necessary.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Tries to match each token in the order they were specified.
As soon as one token matches, consumes it and succeeds.
If no token matched, fails without consuming anything.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>A generic error with tag <code>lexy::exhausted_alternatives</code> if no token matched.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If an alternative consists of only literals, a trie is used to efficiently match them without backtracking.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Use a choice rule with a suitable condition to avoid potentially long backtracking.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslswitch" class="discrete"><code>lexy::dsl::switch_</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/switch.hpp</code></div>
<div class="content">
<pre>switch_(rule) : Rule

switch_(rule).case_(branch)  : Rule
switch_(rule).default_(rule) : Rule = switch_(rule).case_(else_ &gt;&gt; rule)
switch_(rule).error&lt;Tag&gt;()   : Rule = switch_(rule).case_(error&lt;Tag&gt;(any))</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>switch_</code> rule matches a rule and then switches over the input the rule has consumed.
Switch cases can be added by calling <code>.case_()</code>; they are tried in order.
A default case is added using <code>.default_()</code>; it is taken unconditionally.
Alternatively, an error case can be added using <code>.error&lt;Tag&gt;()</code>; it produces an error if no previous case has matched.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>First matches and consumes the switched rule.
What the rule has consumed is then taken as the entire input for matching the switch cases.
Then it tries to match the branch conditions of each case in order.
When a branch condition matches, that case is taken and its then is matched.
If no case has matched, it fails.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>Any values produced by the switched rule followed by any values produced by the selected case.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>If the switched rule fails to match, any errors raised by it.
If the branch condition of a case has matched, any errors raised by the then.
If the switch had an error case, a generic error with the specified <code>Tag</code> is raised whose range is everything consumed by the switched rule.
Otherwise, a generic error with tag <code>lexy::exhausted_switch</code> is raised.</p>
</td>
</tr>
</table>
</div>
<details id="G87Mqf">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/G87Mqf" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Parse identifiers (one or more alpha numeric characters) but detect the three reserved keywords.
// We use `+ dsl::eof` in the case condition to ensure that `boolean` is not matched as `bool`.
dsl::switch_(dsl::while_one(dsl::ascii::alnum))
    .case_(LEXY_LIT("true")  + dsl::eof &gt;&gt; dsl::id&lt;1&gt;)
    .case_(LEXY_LIT("false") + dsl::eof &gt;&gt; dsl::id&lt;2&gt;)
    .case_(LEXY_LIT("bool")  + dsl::eof &gt;&gt; dsl::id&lt;3&gt;)
    .default_(dsl::id&lt;0&gt;) // It wasn't a reserved keyword but a normal identifier.

// Note: a more efficient and convenient method for handling keywords is planned.</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It does not matter if the then of a case does not consume everything the original rule has consumed.
As soon as the then has matched everything parsing continues from the reader position after the switched rule has been matched.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_loops">Loops</h3>
<h4 id="_lexydsluntil" class="discrete"><code>lexy::dsl::until</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/until.hpp</code></div>
<div class="content">
<pre>until(token)          : Token
until(token).or_eof() : Token = until(token / eof)</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>until</code> token consumes all input until the specified <code>token</code> matches, then consumes that.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>If the closing <code>token</code> matches, consumes it and succeeds.
Otherwise, consumes one code unit and tries again.
If EOF is reached, fails, unless <code>.or_eof()</code> was called, in which case it also succeeds having consumed everything until the end of the input.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>It can only fail if the reader has reached the end of the input without matching the condition.
Then it raises the same error as raised if the condition would be matched at EOF.</p>
</td>
</tr>
</table>
</div>
<details id="Yn4WTj">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/Yn4WTj" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Matches a C style comment.
// Note that we don't care what it contains.
LEXY_LIT("/*") &gt;&gt; dsl::until(LEXY_LIT("*/"))</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>until</code> includes the <code>token</code>.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslloop" class="discrete"><code>lexy::dsl::loop</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/loop.hpp</code></div>
<div class="content">
<pre>loop(rule) : Rule

break_ : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>loop</code> rule matches the given rule repeatedly until it either fails to match or a <code>break_</code> rule was matched.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p><code>rule</code> must not produce any values.
<code>break_</code> must be used inside a loop.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>While the rule matches, consumes it and repeats.
If a <code>break_</code> is matched, parsing will stop immediately and it succeeds.
If the rule does not match, it fails.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>No values are produced.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>Any errors raised when the rule fails to match.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>loop</code> rule is mainly used to implement other rules.
It is unlikely that you are going to need it yourself.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If <code>rule</code> contains a branch that will not consume any characters but does not break, <code>loop</code> will loop forever.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslwhile" class="discrete"><code>lexy::dsl::while_</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/while.hpp</code></div>
<div class="content">
<pre>while_(branch) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>while</code> rule matches a branch as long as it condition has matched.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p><code>branch</code> must not produce any values.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>While the branch condition matches, matches and consumes the then then repeats.
If the branch condition does not match anymore, succeeds without consuming additional input.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>No values are produced.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>The rule can only fail if the then of the branch fails.
Then it will raise its error unchanged.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If the branch does not consume any characters, <code>while_</code> will loop forever.
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title"><code>lexy/dsl/while.hpp</code></div>
<div class="content">
<pre>while_(choice)         : Rule = loop(choice | else_ &gt;&gt; break_)</pre>
</div>
</div>
<div class="paragraph">
<p>This version of the <code>while_</code> rule repeatedly matches a choice as long as one branch matches.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p><code>choice</code> most not produce any values.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>While one branch condition of the choice matches, consumes it and the rest of the branch.
If no branch matches anymore, succeeds without consuming additional input.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>No values are produced.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>The rule can only fail if the then of one of the choice branches fails.
Then it will raise its error unchanged.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
If the choice has an else branch already, it will loop until an error is raised.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslwhile_one" class="discrete"><code>lexy::dsl::while_one()</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/while.hpp</code></div>
<div class="content">
<pre>while_one(rule)    : Rule    = rule + while_(rule)
while_one(branch)  : Branch  = branch &gt;&gt; while_(branch)
while_one(token)   : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>while_one</code> rule matches a rule one or more times.
It is a token if it is given a token.</p>
</div>
<h4 id="_lexydsldo_while" class="discrete"><code>lexy::dsl::do_while()</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/while.hpp</code></div>
<div class="content">
<pre>do_while(rule, condition_branch)   : Rule   = rule + while_(condition_branch &gt;&gt; rule)
do_while(branch, condition_branch) : Branch = branch &gt;&gt; while_(condition_branch &gt;&gt; rule)</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>do_while</code> rule matches a rule first unconditionally, and then again repeatedly while the rule matches.</p>
</div>
<details id="4dzEK7">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/4dzEK7" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Equivalent to `dsl::list(dsl::ascii::alpha, dsl::sep(dsl::comma))` but does not produce a value.
dsl::do_while(dsl::ascii::alpha, dsl::comma)</code></pre>
</div>
</div>
</div>
</details>
<h4 id="_lexydslsep_and_lexydsltrailing_sep" class="discrete"><code>lexy::dsl::sep</code> and <code>lexy::dsl::trailing_sep</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/separator.hpp</code></div>
<div class="content">
<pre>sep(branch)
trailing_sep(branch)</pre>
</div>
</div>
<div class="paragraph">
<p><code>sep</code> and <code>trailing_sep</code> are used to specify a separator between repeated items; they are not rules that can be parsed directly.</p>
</div>
<div class="paragraph">
<p>Use <code>sep(branch)</code> to indicate that <code>branch</code> has to be consumed between two items.
If it would match after the last item, it is not consumed by the rule.</p>
</div>
<div class="paragraph">
<p>Use <code>trailing_sep(branch)</code> to indicate that <code>branch</code> has to be consumed between two items and can occur after the final item.
If it matches after the last item, it is consumed as well.</p>
</div>
<h4 id="_lexydsltimes" class="discrete"><code>lexy::dsl::times</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/times.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy
{
    template &lt;std::size_t N, typename T&gt;
    using times = T (&amp;)[N];

    template &lt;typename T&gt;
    using twice = times&lt;2, T&gt;;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/times.hpp</code></div>
<div class="content">
<pre>times&lt;N&gt;(rule)      : Rule
times&lt;N&gt;(rule, sep) : Rule

twice(rule)      : Rule = times&lt;2&gt;(rule)
twice(rule, sep) : Rule = times&lt;2&gt;(rule, sep)</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>times</code> rule repeats the rule <code>N</code> times with optional separator in between and collects all produced values into an array.
The <code>twice</code> rule is a convenience alias for <code>N = 2</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>The separator must not produce any values.
All values produced by the parsing the rule must have a common type.
In particular, the rule must only produce one value.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>If no separator is specified, matches and consumes <code>rule</code> <code>N</code> times.
If a separator is specified, matches and consumes <code>rule</code> <code>N</code> times, consuming the separator between two items and potentially after all items if the separator is trailing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>Produces a single array containing <code>N</code> items which are all the values produced by each repetition.
The typedef <code>lexy::times</code> or <code>lexy::twice</code> can be used to process that array.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised by matching the rule or separator.</p>
</td>
</tr>
</table>
</div>
<details id="hrTKaT">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/hrTKaT" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Parses an IPv4 address (4 uint8_t's seperated by periods).
dsl::times&lt;4&gt;(dsl::integer&lt;std::uint8_t&gt;(dsl::digits&lt;&gt;), dsl::sep(dsl::period))</code></pre>
</div>
</div>
</div>
</details>
<h4 id="_lexydsllist" class="discrete"><code>lexy::dsl::list</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/list.hpp</code></div>
<div class="content">
<pre>list(rule)   : Rule
list(branch) : Branch

list(rule, sep)   : Rule
list(branch, sep) : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>list</code> rule matches a rule one or more times, optionally separated by a separator.
Values produced by the list items are forwarded to a sink callback.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Branch Condition
</td>
<td class="hdlist2">
<p>Whatever <code>branch</code> uses as branch condition.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>The item rule must be a branch or a choice rule unless a non-trailing separator is used (in that case the separator can be used as condition).
A production whose rule contains <code>list()</code> must provide a sink.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes the item rule one or more times.
In between items and potentially after the final item, a separator is matched and consumed if provided according to its rules.
If the separator is provided and non-trailing, the existence of a separator determines whether or not the rule should be matched again.
Otherwise, the branch condition of the branch rule or an added else branch of the choice rule is used to determine that.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>Only a single value, which is the result of the finished sink.
Every time the item rule is parsed, all values it produces are passed to the sink which is invoked once per iteration.
If the separator is captured, its lexeme is also passed to the sink, but in a separate invocation.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised when parsing the item rule or separator.</p>
</td>
</tr>
</table>
</div>
<details id="fod3vY">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/fod3vY" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Parses a list of integers seperated by (a potentially trailing) comma.
// As the separator is trailing, it cannot be used to determine the end of the list.
// As such we peek whether the input contains a digit in our item condition.
// The sink is invoked with each integer.
dsl::list(dsl::peek(dsl::digit&lt;&gt;) &gt;&gt; dsl::integer&lt;int&gt;(dsl::digits&lt;&gt;),
          dsl::trailing_sep(dsl::comma))</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use one of the bracketing rules if your list item does not have an easy condition and the list is surrounded by given tokens anyway.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslcombination" class="discrete"><code>lexy::dsl::combination</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/combination.hpp</code></div>
<div class="content">
<pre>combination(branch1, branch2, ...) : Rule
combination&lt;Tag&gt;(branch1, branch2, ...) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>combination</code> rule matches each of the sub-rules exactly once but in any order.
Values produced by the rules are forwarded to a sink.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>A production whose rule contains <code>combination()</code> must provide a sink.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes all rules in an arbitrary order.
This is done by parsing the choice created from the branches exactly <code>N</code> times.
Branches that have already been taken are not excluded on future iterations.
If they are taken again, the rule fails.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>Only a single value, which is the result of the finished sink.
All values produced by the branches are passed to the sink which is invoked once per iteration.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised by parsing the branches.
If no branch is matched, but there are still missing branches,
a generic error with tag <code>lexy::exhausted_choice</code> is raised.
If a branch is matched twice, a generic error is raised.
It has the specified tag or <code>lexy::combination_duplicate</code> if none was specified.</p>
</td>
</tr>
</table>
</div>
<details id="bjKqvj">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/bjKqvj" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Matches 'a', 'b', or 'c', in any order.
dsl::combination(dsl::lit_c&lt;'a'&gt;, dsl::lit_c&lt;'b'&gt;, dsl::lit_c&lt;'c'&gt;)</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The branches are tried in order. If an earlier branch always takes precedence over a later one, the combination can never be successful.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslpartial_combination" class="discrete"><code>lexy::dsl::partial_combination</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/combination.hpp</code></div>
<div class="content">
<pre>partial_combination(branch1, branch2, ...) : Rule
partial_combination&lt;Tag&gt;(branch1, branch2, ...) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>partial_combination</code> rule matches each of the sub-rules at most once but in any order.
Values produced by the rules are forwarded to a sink.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>A production whose rule contains <code>partial_combination()</code> must provide a sink.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes a subset of the rules in an arbitrary order.
This is done by parsing the choice created from the branches exactly <code>N</code> times.
Branches that have already been taken are not excluded on future iterations.
If they are taken again, the rule fails.
If no branch is taken, the rule succeeds.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>Only a single value, which is the result of the finished sink.
All values produced by the branches are passed to the sink which is invoked once per iteration.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised by parsing the branches.
If a rule is matched twice, a generic error is raised.
It has the specified tag or <code>lexy::combination_duplicate</code> if none was specified.</p>
</td>
</tr>
</table>
</div>
<details id="85dv9W">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/85dv9W" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Matches a subset of 'a', 'b', or 'c', in any order.
dsl::partial_combination(dsl::lit_c&lt;'a'&gt;, dsl::lit_c&lt;'b'&gt;, dsl::lit_c&lt;'c'&gt;)</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The branches are tried in order. If an earlier branch always takes precedence over a later one, the combination can never be successful.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_productions">Productions</h3>
<div class="paragraph">
<p>Every rule is owned by a production.
The following rules allow interaction with other productions.</p>
</div>
<h4 id="_lexydslp_and_lexydslrecurse" class="discrete"><code>lexy::dsl::p</code> and <code>lexy::dsl::recurse</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/production.hpp</code></div>
<div class="content">
<pre>p&lt;Production&gt; : Rule or Branch
recurse&lt;Production&gt; : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>p</code> and <code>recurse</code> rules parses the rule of another production.
The <code>p</code> rule is a branch, if the rule of the other production is a branch.
Both are whitespace aware.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>For <code>p</code>, the <code>Production</code> is a complete type at the point of the rule definition.
The <code>recurse</code> rule has no such limitations.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Branch Condition
</td>
<td class="hdlist2">
<p>Whatever the production&#8217;s rule uses as a branch condition.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes <code>Production::rule</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>A single value, which is the result of parsing the production.
All values produced by parsing its rule are forwarded to the productions value callback.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>If matching fails, <code>Production::rule</code> will raise an error which is handled in the context of <code>Production</code>.
This results in a failed result object, which is converted to our result type and returned.</p>
</td>
</tr>
</table>
</div>
<details id="oj9T3n">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/oj9T3n" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Parse a sub production followed by an exclamation mark.
dsl::p&lt;sub_production&gt; + dsl::lit_c&lt;'!'&gt;</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
While <code>recurse</code> can be used to implement direct recursion (e.g. <code>prefix &gt;&gt; dsl::p&lt;current_production&gt; | dsl::else_ &gt;&gt; end</code> to match zero or more <code>prefix</code> followed by <code>end</code>), it is better to use loops instead.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Left recursion will create an infinite loop.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslreturn" class="discrete"><code>lexy::dsl::return_</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/return.hpp</code></div>
<div class="content">
<pre>return_ : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>Conceptually, each production has an associated function that parses the specified rule.
The <code>return_</code> rule will exit that function early, without parsing subsequent rules.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>It must not be used inside loops.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Any input, but does not consume anything.
Subsequent rules are not matched further.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>It does not produce any values, but all values produced so far are forwarded to the callback.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>n/a (it does not fail)</p>
</td>
</tr>
</table>
</div>
<details id="zrbcaq">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/zrbcaq" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Match an opening parenthesis followed by 'a' or 'b'.
// If it is followed by 'b', the closing parenthesis is not matched anymore.
dsl::parenthesized(dsl::lit_c&lt;'a'&gt; | dsl::lit_c&lt;'b'&gt; &gt;&gt; dsl::return_)</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
When using <code>return_</code> together with the context sensitive parsing facilities, remember to pop all context objects before the return.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_brackets_and_terminator">Brackets and terminator</h3>
<h4 id="_terminator" class="discrete">Terminator</h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/terminator.hpp</code></div>
<div class="content">
<pre>terminator(branch)
terminator(branch).terminator() : Branch = branch</pre>
</div>
</div>
<div class="paragraph">
<p>A terminator can be specified using <code>terminator()</code>.
The result is not a rule, but a DSL for specifying that a rule is followed by the terminator.
The terminator is defined using a branch; it is returned by calling <code>.terminator()</code>.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/terminator.hpp</code></div>
<div class="content">
<pre>t[rule]</pre>
</div>
</div>
<div class="paragraph">
<p>Whitespace can be added by writing <code>t[rule]</code>, where <code>t</code> is the result of a <code>terminator()</code> call.
It will skip whitespace before matching the terminator.
If whitespace is added, this is also reflected by <code>.terminator()</code>.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/terminator.hpp</code></div>
<div class="content">
<pre>t(rule) : Rule = rule + t.terminator()</pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>t(rule)</code>, where <code>t</code> is the result of a <code>terminator()</code> call, results in a rule that parses the given <code>rule</code> followed by the terminator.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/terminator.hpp</code></div>
<div class="content">
<pre>t.while_(rule) : Rule
t.while_one(rule) : Rule

t.opt(rule) : Rule

t.list(rule) : Rule
t.list(rule, sep) : Rule

t.opt_list(rule) : Rule
t.opt_list(rule, sep) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>t.while_()</code>, <code>t.while_one()</code> <code>t.opt()</code>, <code>t.list()</code>, or <code>t.opt_list()</code>, where <code>t</code> is the result of a <code>terminator()</code> call, results in a rule that parses <code>while_(rule)</code>, <code>while_one(rule)</code>, <code>opt(rule)</code>, <code>list(rule)</code> and <code>opt(list(rule))</code>, respectively, but followed by the terminator.
The <code>rule</code> does not need to be a terminator is used as the branch condition for the <code>while_()</code>, <code>opt()</code> and <code>list()</code> rule.</p>
</div>
<h4 id="_brackets" class="discrete">Brackets</h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/brackets.hpp</code></div>
<div class="content">
<pre>brackets(open_branch, close_branch)
brackets(open_branch, close_branch).open()  : Branch = open_branch
brackets(open_branch, close_branch).close() : Branch = close_branch</pre>
</div>
</div>
<div class="paragraph">
<p>A set of open and close brackets can be specified using <code>brackets()</code>.
The result is not a rule, but a DSL for specifying that a rule is surrounded by brackets.
The open and close brackets are defined using branches; they are returned by calling <code>.open()</code> and <code>.close()</code>.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/brackets.hpp</code></div>
<div class="content">
<pre>b[rule]</pre>
</div>
</div>
<div class="paragraph">
<p>Whitespace can be added by writing <code>b[rule]</code>, where <code>b</code> is the result of a <code>brackets()</code> call.
It will skip whitespace before matching the open and close branch.
If whitespace is added, this is also reflected by <code>.open()</code> and <code>.close()</code>.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/brackets.hpp</code></div>
<div class="content">
<pre>b(rule) : Branch = b.open() &gt;&gt; rule + b.close()</pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>b(rule)</code>, where <code>b</code> is the result of a <code>brackets()</code> call, results in a rule that parses the given <code>rule</code> surrounded by brackets.
The rule is a branch that uses the opening bracket as a branch condition.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/brackets.hpp</code></div>
<div class="content">
<pre>b.while_(rule) : Branch
b.while_one(rule) : Branch

b.opt(rule) : Branch

b.list(rule) : Branch
b.list(rule, sep) : Branch

b.opt_list(rule) : Branch
b.opt_list(rule, sep) : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>b.while_()</code>, <code>b.while_one()</code> <code>b.opt()</code>, <code>b.list()</code>, or <code>b.opt_list()</code>, where <code>b</code> is the result of a <code>brackets()</code> call, results in a branch that parses <code>while_(rule)</code>, <code>while_one(rule)</code>, <code>opt(rule)</code>, <code>list(rule)</code> and <code>opt(list(rule))</code>, respectively, but surrounded as brackets.
The <code>rule</code> does not need to be a branch as the closing brackets is used as the branch condition for the <code>while_()</code>, <code>opt()</code> and <code>list()</code> rule.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/brackets.hpp</code></div>
<div class="content">
<pre>round_bracketed  = brackets(lit_c&lt;'('&gt;, lit_c&lt;')'&gt;)
square_bracketed = brackets(lit_c&lt;'['&gt;, lit_c&lt;']'&gt;)
curly_bracketed  = brackets(lit_c&lt;'{'&gt;, lit_c&lt;'}'&gt;)
angle_bracketed  = brackets(lit_c&lt;'&lt;'&gt;, lit_c&lt;'&gt;'&gt;)

parenthesized = round_bracketed</pre>
</div>
</div>
<div class="paragraph">
<p>Common sets of open and close brackets are pre-defined.</p>
</div>
<details id="dzMTnx">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/dzMTnx" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Parses a list of integers seperated by (a potentially trailing) comma surrounded by parentheses.
// The same example without the parentheses was also used for list,
// but we required a list condition that needed to perform lookahead.
// Now, the closing parentheses is used as the condition and we don't need to lookahead.
dsl::parenthesized.list(dsl::integer&lt;int&gt;(dsl::digits&lt;&gt;),
                        dsl::trailing_sep(dsl::comma))</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect2">
<h3 id="_numbers">Numbers</h3>
<div class="paragraph">
<p>The facilities for parsing integers are split into the digit token, which do not produce any values,
and the <code>integer</code> rule, which matches a digit token and converts it into an integer.
The integer conversion has to be done during and parsing and not as a callback, as overflow creates a parse error.</p>
</div>
<h4 id="_base" class="discrete">Base</h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/digit.hpp</code></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace lexy::dsl
{
    struct binary;
    struct octal;
    struct decimal;
    struct hex_lower;
    struct hex_upper;
    struct hex;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The set of allowed digits and their values is specified using a <code>Base</code>, which is a policy class passed to the rules.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>binary</code></dt>
<dd>
<p>Matches the base 2 digits <code>0</code> and <code>1</code>.</p>
</dd>
<dt class="hdlist1"><code>octal</code></dt>
<dd>
<p>Matches the base 8 digits <code>0-7</code>.</p>
</dd>
<dt class="hdlist1"><code>decimal</code></dt>
<dd>
<p>Matches the base 10 digits <code>0-9</code>. If no base is specified, this is the default.</p>
</dd>
<dt class="hdlist1"><code>hex_lower</code></dt>
<dd>
<p>Matches the lower-case base 16 digits <code>0-9</code> and <code>a-f</code>.</p>
</dd>
<dt class="hdlist1"><code>hex_upper</code></dt>
<dd>
<p>Matches the upper-case base 16 digits <code>0-9</code> and <code>A-F</code>.</p>
</dd>
<dt class="hdlist1"><code>hex</code></dt>
<dd>
<p>Matches the base 16 digits <code>0-9</code>, <code>A-F</code>, and <code>a-f</code>.</p>
</dd>
</dl>
</div>
<h4 id="_lexyinteger_traits" class="discrete"><code>lexy::integer_traits</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/integer.hpp</code></div>
<div class="content">
<pre>namespace lexy
{
    template &lt;typename T&gt;
    struct integer_traits
    {
        using type = T;

        static constexpr bool is_bounded;

        template &lt;int Radix&gt;
        static constexpr std::size_t max_digit_count;

        template &lt;int Radix&gt;
        static constexpr void add_digit_unchecked(type&amp; result, unsigned digit);
        template &lt;int Radix&gt;
        static constexpr bool add_digit_checked(type&amp; result, unsigned digit)
    };

    template &lt;&gt;
    struct integer_traits&lt;lexy::code_point&gt;;

    template &lt;typename T&gt;
    struct unbounded
    {};
    template &lt;typename T&gt;
    struct integer_traits&lt;unbounded&lt;T&gt;&gt;
    {
        using type                       = typename integer_traits&lt;T&gt;::type;
        static constexpr bool is_bounded = false;

        template &lt;int Radix&gt;
        static constexpr void add_digit_unchecked(type&amp; result, unsigned digit);
    };
}</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>lexy::integer_traits</code> are used for parsing an integer.
It controls its maximal value and abstracts away the required integer operations.</p>
</div>
<div class="paragraph">
<p>The <code>type</code> member is the actual type that will be returned by the parse operation. It is usually <code>T</code>.
The parsing algorithm does not require that <code>type</code> is an integer type, it only needs to have a constructor that initializes it from an <code>int</code>.
If <code>is_bounded</code> is <code>true</code>, parsing requires overflow checking.
Otherwise, parsing does not require overflow checking and <code>max_digit_count</code> and <code>add_digit_checked</code> are not required.
<code>max_digit_count</code> returns the number of digits necessary to express the bounded integers maximal value in the given radix.
It must be bigger than <code>1</code>.
<code>add_digit_unchecked</code> and <code>add_digit_checked</code> add <code>digit</code> to result by doing the equivalent of <code>result = result * Radix + digit</code>.
The <code>_checked</code> version returns <code>true</code> if that has lead to an integer overflow.</p>
</div>
<div class="paragraph">
<p>The primary template works with any integer type and there is a specialization for <code>lexy::code_point</code>.
By wrapping your integer type in <code>lexy::unbounded</code>, you can disable bounds checking during parsing.
It specialization of <code>lexy::integer_traits</code> is built on top of the specialization of <code>lexy::integer_traits&lt;T&gt;</code>,
but disables all bounds checking.
You can specialize <code>lexy::integer_traits</code> for your own integer types.</p>
</div>
<h4 id="_lexydslzero" class="discrete"><code>lexy::dsl::zero</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/digit.hpp</code></div>
<div class="content">
<pre>zero : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>zero</code> token matches the zero digit.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes the zero digit <code>0</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>Raises a <code>lexy::expected_char_class</code> error with the name <code>digit.zero</code>.</p>
</td>
</tr>
</table>
</div>
<h4 id="_lexydsldigit" class="discrete"><code>lexy::dsl::digit</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/digit.hpp</code></div>
<div class="content">
<pre>digit&lt;Base&gt; : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>digit</code> token matches a digit of the specified base or <code>decimal</code> if no base was specified.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes any of the valid digits of the base.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>Raises a <code>lexy::expected_char_class</code> error with the name <code>digit.&lt;base&gt;</code>, where <code>&lt;base&gt;</code> is <code>binary</code>, <code>hex-lower</code>, etc.</p>
</td>
</tr>
</table>
</div>
<h4 id="_lexydsldigits" class="discrete"><code>lexy::dsl::digits</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/digit.hpp</code></div>
<div class="content">
<pre>digits&lt;Base&gt; : Token

digits&lt;Base&gt;.sep(token)        : Token
digits&lt;Base&gt;.no_leading_zero() : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>digits</code> token matches a non-empty sequence of digits in the specified base or <code>decimal</code> if no base was specified.
Calling <code>.sep()</code> allows adding a digit separator token that can be present at any point between two digits, but is not required.
Calling <code>.no_leading_zero()</code> raises an error if one or more leading zeros are encountered.
The calls to <code>.sep()</code> and <code>.no_leading_zero()</code> can be chained.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes one or more digits of the specified base.
If a separator was added, it tries to match it after every digit.
It is consumed if it was matched, but it does not fail if no separator was present.
If a separator is matched without a following digit, it fails.
If <code>.no_leading_zero()</code> was called, fails if the first digit was zero and it is followed by another digit or separator.
If it could not match any more digits after the initial one, matching succeeds.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised by <code>digit&lt;Base&gt;</code>, which can only happen for the initial digit.
Raises a generic error with tag <code>lexy::forbidden_leading_zero</code> if a leading zero was matched.</p>
</td>
</tr>
</table>
</div>
<details id="Kq1vez">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/Kq1vez" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Matches upper-case hexadecimal digits seperated by ' without leading zeroes.
dsl::digits&lt;dsl::hex_upper&gt;.sep(dsl::digit_sep_tick).no_leading_zero()</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The separator can be placed at any point between two digits.
There is no validation of rules to ensure it is a thousand separator or similar conventions.
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="title"><code>lexy/dsl/digit.hpp</code></div>
<div class="content">
<pre>digit_sep_underscore : Token = lit&lt;"_"&gt;
digit_sep_tick       : Token = lit&lt;"'"&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>For convenience, two common digit separators <code>_</code> and <code>'</code> are predefined as <code>digit_sep_underscore</code> and <code>digit_sep_tick</code> respectively.
However, the digit separator can be an arbitrarily complex token.</p>
</div>
<h4 id="_lexydsln_digits" class="discrete"><code>lexy::dsl::n_digits</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/digit.hpp</code></div>
<div class="content">
<pre>n_digits&lt;N, Base&gt; : Token

n_digits&lt;N, Base&gt;.sep(token) : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>n_digits</code> token matches exactly <code>N</code> digits in the specified base or <code>decimal</code> if no base was specified.
Calling <code>.sep()</code> allows adding a digit separator token that can be present at any point between two digits, but is not required.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes exactly <code>N</code> digits of the specified base.
If a separator was added, it tries to match it after every digit.
It is consumed if it was matched, but it does not fail if no separator was present.
If a separator is matched without a following digit, it fails.
Separators do not count towards the digit count.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised by <code>digit&lt;Base&gt;</code>, which can happen if less than <code>N</code> digits are available.
Raises a generic error with tag <code>lexy::forbidden_leading_zero</code> if a leading zero was matched.</p>
</td>
</tr>
</table>
</div>
<details id="1YcrGa">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/1YcrGa" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Matches 4 upper-case hexadecimal digits seperated by '.
dsl::n_digits&lt;4, dsl::hex_upper&gt;.sep(dsl::digit_sep_tick)</code></pre>
</div>
</div>
</div>
</details>
<h4 id="_lexydslinteger" class="discrete"><code>lexy::dsl::integer</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/integer.hpp</code></div>
<div class="content">
<pre>integer&lt;T, Base&gt;(token) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>integer</code> rule converts the lexeme matched by the <code>token</code> into an integer of type <code>T</code> using the given base.
The <code>Base</code> can be omitted if the token is <code>digits</code> or <code>n_digits</code>.
It will then be deduced from the token.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes what <code>token</code> matches.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>An integer of type <code>T</code> that is created by the characters the token has consumed.
If the token matches characters that are not valid digits of the base (e.g. a digit separator), those characters are skipped.
Otherwise, the character is converted to a digit and added to the resulting integer using the <code>lexy::integer_traits</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>Any errors raised by matching the token.
If the integer type <code>T</code> is bounded and the integer value would overflow, a generic error with tag <code>lexy::integer_overflow</code> is raised.</p>
</td>
</tr>
</table>
</div>
<details id="6ThWPn">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/6ThWPn" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Matches upper-case hexadecimal digits seperated by ' without leading zeroes.
// Converts them into an integer, the base is deduced from the token.
dsl::integer&lt;int&gt;(dsl::digits&lt;dsl::hex_upper&gt;
                        .sep(dsl::digit_sep_tick).no_leading_zero())</code></pre>
</div>
</div>
</div>
</details>
<h4 id="_lexydslcode_point_id" class="discrete"><code>lexy::dsl::code_point_id</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/integer.hpp</code></div>
<div class="content">
<pre>code_point_id&lt;N, Base&gt; : Rule = integer&lt;lexy::code_point&gt;(n_digits&lt;N, Base&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>code_point_id</code> rule is a convenience rule that parses a code point.
It matches <code>N</code> digits in the specified base, which defaults to <code>hex</code>, and converts it into a code point.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes exactly <code>N</code> digits of the specified base.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>The <code>lexy::code_point</code> that is specified using those digits.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>The same error as <code>digit&lt;Base&gt;</code> if fewer than <code>N</code> digits are available.
A generic error with tag <code>lexy::integer_overflow</code> if the code point value would exceed the maximum code point.</p>
</td>
</tr>
</table>
</div>
<h4 id="_lexydslplus_sign_lexydslminus_sign_and_lexydslsign" class="discrete"><code>lexy::dsl::plus_sign</code>, <code>lexy::dsl::minus_sign</code>, and <code>lexy::dsl::sign</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/sign.hpp</code></div>
<div class="content">
<pre>plus_sign  : Rule
minus_sign : Rule

sign : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>plus_sign</code>, <code>minus_sign</code>, and <code>sign</code> rule match an optional sign.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>plus_sign</code></dt>
<dd>
<p>Matches and consumes a <code>+</code> character, if there is one.</p>
</dd>
<dt class="hdlist1"><code>minus_sign</code></dt>
<dd>
<p>Matches and consumes a <code>-</code> character, if there is one.</p>
</dd>
<dt class="hdlist1"><code>sign</code></dt>
<dd>
<p>Matches and consumes a <code>+</code> or <code>-</code> character, if there is one.</p>
</dd>
<dt class="hdlist1">Values</dt>
<dd>
<p>If a <code>+</code> sign was consumed, the value is <code>+1</code>.
If a <code>-</code> sign was consumed, the value is <code>-1</code>.
If no sign was consumed, the value is <code>+1</code>.</p>
</dd>
</dl>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>n/a (they don&#8217;t fail)</p>
</td>
</tr>
</table>
</div>
<details id="7exP55">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/7exP55" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Parse a decimal integer with optional minus sign.
dsl::minus_sign + dsl::integer&lt;int&gt;(dsl::digits&lt;&gt;)</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The callback <code>lexy::as_integer</code> takes the value produced by the sign rules together with an integer produced by the <code>integer</code> rule and negates it if necessary.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_delimited_and_quoted">Delimited and quoted</h3>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>delimited(open_branch, close_branch)
delimited(open_branch, close_branch).open()  : Branch = open_branch
delimited(open_branch, close_branch).close() : Branch = close_branch</pre>
</div>
</div>
<div class="paragraph">
<p>A set of open and close delimiters can be specified using <code>delimited()</code>.
The result is not a rule, but a DSL for specifying a sequence of code points to be matched between the delimiters.
The open and close delimiters are defined using branches; they are returned by calling <code>.open()</code> and <code>.close()</code>.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>delimited(branch) = delimited(branch, branch)</pre>
</div>
</div>
<div class="paragraph">
<p>There is a convenience overload if the same rule is used for the open and closing delimiters.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>d[rule]</pre>
</div>
</div>
<div class="paragraph">
<p>Whitespace can be added by writing <code>d[rule]</code>, where <code>d</code> is the result of a <code>delimiter()</code> call.
It will skip whitespace before the opening delimiter only.
If whitespace is added, this is also reflected by <code>.open()</code>.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>quoted        = delimited(lit&lt;"\""&gt;)
triple_quoted = delimited(lit&lt;"\"\"\""&gt;)

single_quoted = delimited(lit&lt;"'"&gt;)

backticked        = delimited(lit&lt;"`"&gt;)
double_backticked = delimited(lit&lt;"``"&gt;)
triple_backticked = delimited(lit&lt;"```"&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>Common delimiters are predefined.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The naming of <code>quoted</code>, <code>triple_quoted</code> and <code>single_quoted</code> is not very logical, but reflects common usage.
</td>
</tr>
</table>
</div>
<h4 id="_simple_delimited" class="discrete">Simple delimited</h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>d(rule)  : Branch
d(token) : Branch = d(capture(token))</pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>d(rule)</code>, where <code>d</code> is the result of a <code>delimiter()</code> call, results in a rule that matches <code>rule</code> as often as possible surrounded by the delimiters.
Values produced by the <code>rule</code> are forwarded to a sink callback.</p>
</div>
<div class="paragraph">
<p>For convenience, if passing a token, the token is captured.
Otherwise, nothing would be passed to the sink.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>A production whose rule contains a delimited rule must provide a sink.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Branch Condition
</td>
<td class="hdlist2">
<p>Whatever the opening delimiter uses as branch condition.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matching
</td>
<td class="hdlist2">
<p>Matches and consumes the opening delimiter, followed by zero or more occurrences of <code>rule</code>, followed by the closing delimiter.
It determines whether or not to parse another instance of <code>rule</code> using the condition of the closing delimiter.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>Values produced by the opening delimiter, the finished sink (which might be empty), and values produced by the closing delimiter.
Every time the rule is parsed, all values produced by it are passed to the sink.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised when matching the opening delimiter and the rule.
If EOF is reached without a closing delimiter, a generic error with tag <code>lexy::missing_delimiter</code> is raised.</p>
</td>
</tr>
</table>
</div>
<details id="WPzos5">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/WPzos5" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Match a string consisting of code points that aren't control characters.
dsl::quoted(dsl::code_point - dsl::ascii::control)</code></pre>
</div>
</div>
</div>
</details>
<h4 id="_delimited_with_escape_sequences" class="discrete">Delimited with escape sequences</h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>d(rule, escape_branch)  : Branch
  = d(escape_branch | else_ &gt;&gt; rule)
d(token, escape_branch) : Branch
  = d(escape_branch | else_ &gt;&gt; capture(token))

d(rule, escape_choice)  : Branch
  = d(escape_choice | else_ &gt;&gt; rule)
d(token, escape_choice) : Branch
  = d(escape_choice | else_ &gt;&gt; capture(token))</pre>
</div>
</div>
<div class="paragraph">
<p>There is a convenience overload to specify escape sequences in the delimited.
The <code>choice</code> matches all appropriate escape sequences and produces their values.</p>
</div>
<div class="paragraph">
<p>Calling <code>d(rule, escape)</code>, where <code>d</code> is the result of a <code>delimiter()</code> call, is equivalent to <code>d(escape | else_ &gt;&gt; rule)</code>, so it results in a rule that matches <code>escape | else_ &gt;&gt; rule</code> as often as possible surrounded by the delimiters.
Values produced by the <code>rule</code> or <code>escape</code> are forwarded to a sink callback.</p>
</div>
<div class="paragraph">
<p>For convenience, if passing a token, the token is captured.
Otherwise, nothing would be passed to the sink.</p>
</div>
<details id="7ed5Wc">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/7ed5Wc" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Match a string consisting of code points that aren't control characters.
// `\"` can be used to add a `"` to the string.
dsl::quoted(dsl::code_point - dsl::ascii::control,
            LEXY_LIT("\\\"") &gt;&gt; dsl::value_c&lt;'"'&gt;)</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The closing delimiter is used as termination condition here as well.
If the escape sequence starts with a closing delimiter, it will not be matched.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslescape" class="discrete"><code>lexy::dsl::escape()</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>escape(token) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>For convenience, the <code>escape</code> rule can be used to specify the escape token.</p>
</div>
<div class="paragraph">
<p>An escape rule consists of a leading token that matches the escape character (e.g. <code>\</code>), and zero or more alternatives for characters that can be escaped.
It then is equivalent to <code>token &gt;&gt; (alt0 | alt1 | alt2 | error&lt;lexy::invalid_escape_sequence&gt;)</code>.
It will only be considered after the leading token has been matched and then tries to match one of the alternatives.
If no alternative matches, it raises a generic error with tag <code>lexy::invalid_escape_sequence</code>.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>e.rule(branch) : Rule
  = escape_token &gt;&gt; ( ... | branch
                      | else_ &gt;&gt; error&lt;lexy::invalid_escape_sequence&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>e.rule(branch)</code>, where <code>e</code> is an escape rule, adds <code>branch</code> to the end of the choice.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>e.capture(token) : Rule
  = escape_token &gt;&gt; (... | capture(token)
                      | else_ &gt;&gt; error&lt;lexy::invalid_escape_sequence&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>e.capture(token)</code>, where <code>e</code> is an escape rule, adds an escape sequence that matches and captures token to the end of the choice.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>e.lit&lt;Str&gt;(rule) : Rule
  = escape_token &gt;&gt; (... | lit&lt;Str&gt; &gt;&gt; rule
                      | else_ &gt;&gt; error&lt;lexy::invalid_escape_sequence&gt;)
e.lit&lt;Str&gt;() : Rule
  = e.lit&lt;Str&gt;(value_str&lt;Str&gt;)

e.lit_c&lt;C&gt;(rule) : Rule
  = escape_token &gt;&gt; (... | lit_c&lt;C&gt; &gt;&gt; rule
                      | else_ &gt;&gt; error&lt;lexy::invalid_escape_sequence&gt;)
e.lit_c&lt;C&gt;() : Rule
  = e.lit_c&lt;C&gt;(value_c&lt;C&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>e.lit()</code> or <code>e.lit_c()</code>, where <code>e</code> is an escape rule, adds an escape sequences that matches the literal and produces the values of the rule to the end of the choice.
If no rule is specified, it defaults to producing the literal itself.</p>
</div>
<div class="listingblock">
<div class="title"><code>lexy/dsl/delimited.hpp</code></div>
<div class="content">
<pre>backslash_escape = escape(lit_c&lt;'\\'&gt;)
dollar_escape    = escape(lit_c&lt;'$'&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>Common escape characters are predefined.</p>
</div>
<details id="aajf7c">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/aajf7c" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Match a string consisting of code points that aren't control characters.
// `\"` can be used to add a `"` to the string.
// `\uXXXX` can be used to add the code point with the specified value.
dsl::quoted(dsl::code_point - dsl::ascii::control,
            dsl::backslash_escape
              .lit_c&lt;'"'&gt;()
              .rule(dsl::lit_c&lt;'u'&gt; &gt;&gt; dsl::code_point_id&lt;4&gt;)</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect2">
<h3 id="_aggregates">Aggregates</h3>
<div class="listingblock">
<div class="title"><code>lexy/dsl/member.hpp</code></div>
<div class="content">
<pre>member&lt;MemPtr&gt; = rule   : Rule
member&lt;MemPtr&gt; = branch : Branch

LEXY_MEM(Name) = rule   : Rule
LEXY_MEM(Name) = branch : Branch</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>member</code> rule together with the <code>lexy::as_aggregate&lt;T&gt;</code> callback assigns the values produced by the rule given to it via <code>=</code> to the specified member of the aggregate <code>T</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>A production that contains a member rule needs to use <code>lexy::as_aggregate&lt;T&gt;</code> as sink or callback.
The rule must produce exactly one value.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes the <code>rule</code> given to it via <code>=</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>Produces two values.
The first value identifiers the targeted member.
For <code>member&lt;MemPtr&gt;</code>, this is the member pointed to by the member pointer.
For <code>LEXY_MEM(Name)</code>, it is the member with the given <code>Name</code>.
The second value is the value produced by the rule.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised during parsing of the assigned rule.</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>lexy::as_aggregate&lt;T&gt;</code> callback, collects all member and value pairs.
It then constructs an object of type <code>T</code> using value initialization and for each pair assigns the value to the specified member of it.
This works either as callback or a sink.
If a member is specified more than once, the final value is stored at the end.</p>
</div>
<details id="EMYGx1">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/EMYGx1" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Parses two integers separated by commas.
// The first integer is assigned to a member called `second`,
// the second integer is assigned to a member called `first`.
(LEXY_MEM(second) = dsl::integer&lt;int&gt;(dsl::digits&lt;&gt;))
+ dsl::comma
+ (LEXY_MEM(first) = dsl::integer&lt;int&gt;(dsl::digits&lt;&gt;))</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect2">
<h3 id="_context_sensitive_parsing">Context sensitive parsing</h3>
<div class="paragraph">
<p>All other parse rules don&#8217;t remember any state and thus can only be used for context free parsing.
The rules described in this section allow the creation of a stack of contextual information.
This can be used to parse context sensitive grammars like XML with matching open and close tags.</p>
</div>
<div class="paragraph">
<p>See <code>example/xml.cpp</code> for an example that uses the context sensitive parsing facilities.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
The context stack uses the same mechanism as the values produced by a rule.
If the rules that push to the stack aren&#8217;t matched by the rules that pop, context values will be passed to the value callback, which isn&#8217;t going to work.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslcontext_push" class="discrete"><code>lexy::dsl::context_push</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/context.hpp</code></div>
<div class="content">
<pre>context_push(rule) : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>context_push</code> rule pushes a context onto the context stack.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes <code>rule</code>.
A lexeme that contains everything consumed will be pushed to the context stack.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>All values produced by <code>rule</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised by <code>rule</code>.</p>
</td>
</tr>
</table>
</div>
<h4 id="_lexydslcontext_drop" class="discrete"><code>lexy::dsl::context_drop</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/context.hpp</code></div>
<div class="content">
<pre>context_drop : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>context_drop</code> rule removes the top context from the stack.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>It must be preceded by a <code>context_push</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>Matches and consumes nothing, but always succeeds.
The context that was pushed last is removed.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>None.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>n/a (it does not fail)</p>
</td>
</tr>
</table>
</div>
<h4 id="_lexydslcontext_top" class="discrete"><code>lexy::dsl::context_top</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/context.hpp</code></div>
<div class="content">
<pre>struct context_eq;
struct context_eq_length;

context_top&lt;Eq&gt;(rule) : Rule
context_top&lt;Eq&gt;(rule).error&lt;Tag&gt;() : Rule</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>context_top</code> rule asserts that the lexeme matched by <code>rule</code> is equal to the context on top of the stack.
Equality is determined using the <code>Eq</code> policy, which defaults to <code>context_eq</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires</dt>
<dd>
<p><code>Eq</code> is either <code>context_eq</code> or <code>context_eq_length</code>.</p>
</dd>
<dt class="hdlist1">Matches</dt>
<dd>
<p>Matches and consumes <code>rule</code>.
It then compares the consumed lexeme with the lexeme on top of the context stack using <code>Eq</code>.
If <code>Eq</code> is <code>context_eq</code>, the lexeme must contain the exact same characters.
If <code>Eq</code> is <code>context_eq_length</code>, the lexeme must have the same length.</p>
</dd>
<dt class="hdlist1">Values</dt>
<dd>
<p>All values produced by <code>rule</code>.</p>
</dd>
<dt class="hdlist1">Errors</dt>
<dd>
<p>All values raised by <code>rule</code>.
If the lexeme did not match the lexeme on top of the context, raises a generic error.
The tag is either the tag specified by calling <code>.error()</code>, or <code>lexy::context_mismatch</code> otherwise.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>rule</code> is usually the same as the rule passed to the matching <code>context_push</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>context_top</code> rule does not remove the context from the stack, use <code>context_pop</code> for that.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslcontext_pop" class="discrete"><code>lexy::dsl::context_pop</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/context.hpp</code></div>
<div class="content">
<pre>context_pop&lt;Eq&gt;(rule) : Rule
  = context_top&lt;Eq&gt;(rule) + context_drop

context_pop&lt;Eq&gt;(rule).error&lt;Tag&gt;() : Rule
  = context_top&lt;Eq&gt;(rule).error&lt;Tag&gt;() + context_drop</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>context_pop</code> rule is a convenience rule that is equivalent to <code>context_top</code> followed by <code>context_drop</code>.
It checks the top of the context stack and then removes it.
<code>Eq</code> defaults to <code>context_eq</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_raw_input">Raw input</h3>
<div class="paragraph">
<p>The following facilities are meant for parsing input that uses the <code>lexy::raw_encoding</code>, that is input consisting of bytes, not text.</p>
</div>
<h4 id="_lexydslbom" class="discrete"><code>lexy::dsl::bom</code></h4>
<div class="listingblock">
<div class="title"><code>lexy/dsl/bom.hpp</code></div>
<div class="content">
<pre>bom&lt;Encoding, Endianness&gt; : Token</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>bom</code> token matches the byte-order mark (BOM) for the given encoding and <code>lexy::encoding_endianness</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p><code>Endianness</code> is <code>lexy::encoding_endianness::little</code> or <code>lexy::encoding_endianness::big</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>If the encoding has a BOM, matches and consumes the BOM written in the given endianness.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>A <code>lexy::expected_char_class</code> error with the name <code>BOM.&lt;encoding&gt;-&lt;endianness&gt;</code> if the BOM was not matched.</p>
</td>
</tr>
</table>
</div>
<details id="xbnEYs">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/xbnEYs" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Matches the UTF-16 big endian BOM (0xFE, 0xFF).
dsl::bom&lt;lexy::utf16_encoding, lexy::encoding_endianness::big&gt;</code></pre>
</div>
</div>
</div>
</details>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a UTF-8 BOM, but it is the same regardless of endianness.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This rule is only necessary when you have a raw encoding that contains a BOM.
For example, <code>lexy::read_file()</code> already handles and deals with BOMs for you by default.
</td>
</tr>
</table>
</div>
<h4 id="_lexydslencode" class="discrete"><code>lexy::dsl::encode</code></h4>
<hr>
<div class="paragraph">
<p>encode&lt;Encoding, Endianness&gt;(rule) : Rule
---</p>
</div>
<div class="paragraph">
<p>The <code>encode</code> rule temporarily changes the encoding of the input.
The specified <code>rule</code> will be matched using a <code>Reader</code> whose encoding is <code>Encoding</code> converted from the raw bytes using the specified endianness.
If no <code>Endianness</code> is specified, the default is <code>lexy::encoding_endianness::bom</code>, and a BOM is matched on the input to determine the endianness.
If no BOM is present, big endian is assumed.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requires
</td>
<td class="hdlist2">
<p>The input&#8217;s encoding is a single-byte encoding (usually <code>lexy::raw_encoding</code>).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Matches
</td>
<td class="hdlist2">
<p>If the endianness is <code>lexy::encoding_endianness::bom</code>, matches and consumes an optional BOM to determine endianness.
Matches and consumes <code>rule</code>.
However, the input of rule are characters according to <code>Encoding</code> and <code>Endianness</code>, not the single bytes of the actual input.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Values
</td>
<td class="hdlist2">
<p>All values produced by the rule.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Errors
</td>
<td class="hdlist2">
<p>All errors raised by the rule.
The error type uses the original reader, not the encoded reader that does the input translation.</p>
</td>
</tr>
</table>
</div>
<details id="Y51r9v">
<summary class="title">Example</summary>
<div class="content">
<a href="https://godbolt.org/z/Y51r9v" target="_blank" rel="noopener">Try on Compiler Explorer</a>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Matches a UTF-8 code point, followed by an ASCII code point.
dsl::encode&lt;lexy::utf8_encoding&gt;(dsl::code_point)
    + dsl::encode&lt;lexy::ascii_encoding&gt;(dsl::code_point)</code></pre>
</div>
</div>
</div>
</details>
</div>
<div class="sect2">
<h3 id="_custom_rules">Custom rules</h3>
<div class="paragraph">
<p>The exact interface for the <code>Rule</code>, <code>Token</code> and <code>Branch</code> concepts is currently still experimental.
Refer to the existing rules if you want to add your own.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_glossary">Glossary</h2>
<div class="sectionbody">
<div class="dlist glossary">
<dl>
<dt>Branch</dt>
<dd>
<p>A rule that has an associated condition and will only be taken if the condition matches.
It is used to make decisions in the parsing algorithm.</p>
</dd>
<dt>Callback</dt>
<dd>
<p>A function object with a <code>return_type</code> member typedef.</p>
</dd>
<dt>Encoding</dt>
<dd>
<p>Set of pre-defined classes that define the text encoding of the input.</p>
</dd>
<dt>Error Callback</dt>
<dd>
<p>The callback used to report errors.</p>
</dd>
<dt>Grammar</dt>
<dd>
<p>An entry production and all productions referenced by it.</p>
</dd>
<dt>Input</dt>
<dd>
<p>Defines the input that will be parsed.</p>
</dd>
<dt>Production</dt>
<dd>
<p>Building-block of a grammar consisting of a rule and an optional callback that produces the parsed value.</p>
</dd>
<dt>Rule</dt>
<dd>
<p>Matches a specific input and then produces a value or an error.</p>
</dd>
<dt>Sink</dt>
<dd>
<p>A type with a <code>sink()</code> method that then returns a function object that can be called multiple times.</p>
</dd>
<dt>Token</dt>
<dd>
<p>A rule that is an atomic building block of the input.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-12-26 21:58:00 UTC
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>