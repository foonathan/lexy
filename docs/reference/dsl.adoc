== The rule DSL

The rule of a production is specified using a DSL built on top of C++ operator overloading.
Everything of the DSL is defined in the namespace `lexy::dsl::*` and every header available under `lexy/dsl/*`.
The umbrella header `lexy/dsl.hpp` includes all DSL headers.

A `Rule` is an object that defines a specific set of input to be parsed.
It first tries to match a set of characters from the input by comparing the character at the current reader position to the set of expected characters,
temporarily advancing the reader further if necessary.
If the matching was successful, a subset of matched characters are consumed by advancing the reader permanently.
The rule can then produce zero or more values, which are eventually forwarded to the value callback of its production.
If the matching was not successful, an error is produced instead.
With the exception of the `!`-rule, a failed rule does not consume any characters.

A `Pattern` is a special `Rule` that does not produce any value and can efficiently determine whether or not it will match at the current reader position without producing an error or consuming characters.
As such, they can be used as branch conditions.

A `Branch` is a special `Rule` that consists of a condition, which is a pattern, and a then, which is a rule.
If the branch condition would match on the current input, it is assumed that the then has to match as well.
They are required when the parsing algorithm has to decide between multiple rules.
Every `Pattern` is a `Branch` with an empty then.

=== Whitespace

[discrete]
==== `lexy::dsl::whitespaced`

.`lexy/whitespace.hpp`
----
whitespaced(rule, whitespace)    : Rule
whitespaced(pattern, whitespace) : Pattern
whitespaced(branch, whitespace)  : Branch
----

By default, no whitespace skipping is done.
Use `whitespaced()` to skip arbitrary long whitespace before parsing a rule.

[horizontal]
Requires::
  `whitespace` is a branch that does not produce any values
Equivalent to::
  `while_(whitespace) + rule`

[godbolt,cpp,id=r5b8Gb]
----
// Skips whitespace and then parses `abc`.
dsl::whitespaced(LEXY_LIT("abc"), dsl::ascii::space)
----

TIP: "whitespace" can mean literal space characters but also things like comments.

[discrete]
==== `Rule::operator[]`

----
rule[whitespace]    : Rule
pattern[whitespace] : Pattern
branch[whitespace]  : Branch
----

Some rules also provide an `operator[]` that does the same as `whitespaced()`.
They are here described as whitespace aware.

[horizontal]
Requires::
  `whitespace` is a branch that does not produce any values
Equivalent to::
  `whitespaced(rule, whitespace)`

[godbolt,cpp,id=sqdze6]
----
// Skips whitespace and then parses `abc`.
LEXY_LIT("abc")[dsl::ascii::space]
----

=== Primitives

[discrete]
==== `lexy::dsl::success`

.`lexy/dsl/sequence.hpp`
----
success : Pattern
----

The `success` pattern matches the empty string.

[horizontal]
Matches::
  Any input, but does not consume anything.
Error::
  n/a (it never fails)

[discrete]
==== `lexy::dsl::any`

.`lexy/dsl/any.hpp`
----
any : Pattern
----

The `any` pattern matches anything, i.e. all the remaining input.

[horizontal]
Matches::
  All the remaining input.
Error::
  n/a (it never fails)

NOTE: `any` is useful in combination with partial inputs such as the minus rule or `switch_`.

[discrete]
==== `lexy::dsl::lit`

.`lexy/dsl/literal.hpp`
----
lit_c<C> : Pattern
lit<Str> : Pattern

LEXY_LIT(Str) : Pattern
----

The literal pattern match the specified sequence of characters.
They are whitespace aware.

[horizontal]
Requires::
  * `C` is a character literal.
  * `Str` is a string literal.
+
In both cases, their encoding must be ASCII or match the encoding of the input.

Matches::
  The specified character or string of characters, which are consumed.
Error::
  `lexy::expected_literal` giving it the string and the index where the match failure occurred.

NOTE: `lit<Str>` requires C++20 support for extended NTTPs.
Use the `LEXY_LIT(Str)` macro if your compiler does not support them.

.`lexy/dsl/punctuator.hpp`
----
period    : Pattern = lit<".">
comma     : Pattern = lit<",">
colon     : Pattern = lit<":">
semicolon : Pattern = lit<";">

hyphen     : Pattern = lit<"-">
slash      : Pattern = lit<"/">
backslash  : Pattern = lit<"\\">
apostrophe : Pattern = lit<"'">

hash_sign   : Pattern = lit<"#">
dollar_sign : Pattern = lit<"$">
at_sign     : Pattern = lit<"@">
----

The header `lexy/dsl/punctuator.hpp` defines common punctuator literals.
They are equivalent to a literal matching the specified character.
They are whitespace aware.

=== Character classes

[discrete]
==== `lexy::dsl::eof`

.`lexy/dsl/eof.hpp`
----
eof : Pattern
----

The `eof` pattern matches EOF.
It is whitespace aware.

[horizontal]
Matches::
  Only if the reader is at the end of the input. It does not consume anything (it can't).
Error::
  `lexy::expected_char_class` with the name `EOF`.

[discrete]
==== `lexy::dsl::newline`

.`lexy/dsl/newline.hpp`
----
newline : Pattern
----

The `newline` pattern matches a newline.
It is whitespace aware.

[horizontal]
Matches::
   `\n` or `\r\n`, which is consumed.
Error::
  `lexy::expected_char_class` with the name `newline`.

[discrete]
==== `lexy::dsl::eol`

.`lexy/dsl/newline.hpp`
----
eol : Pattern
----

The `eol` pattern matches an end-of-line (EOL).
It is whitespace aware.

[horizontal]
Matches::
  `\n` or `\r\n`, which is consumed.
  Also matches EOF, which is not consumed.
Error::
  `lexy::expected_char_class` with the name `EOL`.

[discrete]
==== `lexy::dsl::ascii::*`

.`lexy/dsl/ascii.hpp`
----
namespace ascii
{
    control : Pattern // 0x00-0x1F, 0x7F

    blank       : Pattern // ' ' (space character) or '\t'
    newline     : Pattern // '\n' or '\r'
    other_space : Pattern // '\f' or '\v'
    space       : Pattern // `blank` or `newline` or `other_space`

    lower : Pattern // a-z
    upper : Pattern // A-Z
    alpha : Pattern // `lower` or `upper`

    digit : Pattern // 0-9
    alnum : Pattern // `digit` or `alpha`

    punct : Pattern // One of: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~

    graph : Pattern // `alnum` or `punct`
    print : Pattern // `graph` or ' ' (space characters)

    character : Pattern // 0x00-0x7F
}
----

All patterns defined in `lexy::dsl::ascii` match one of the categories of ASCII characters.

[horizontal]
Matches::
  Matches and consumes one of the set of ASCII characters indicated in the comments.
Errors::
  A `lexy::expected_char_class` error with name `ASCII.<pattern>`, where `<pattern>` is the name of the pattern.

NOTE: Every ASCII character except for the space character is in exactly one of `control`, `lower`, `upper`, `digit` or `punct`.

[discrete]
==== `lexy::dsl::code_point`

.`lexy/dsl/code_point.hpp`
----
code_point : Pattern

code_point.capture() : Rule
----

The `code_point` pattern will match and consume a well-formed Unicode code point according to the encoding of the input.
If `code_point.capture()` is used, the consumed code point will be produced as value.

[horizontal]
Requires::
  The encoding of the input is `lexy::ascii_encoding`, `lexy::utf8_encoding`, `lexy::utf16_encoding`, or `lexy::utf32_encoding`.
Matches::
  Matches and consumes all code units of the next code point.
  For ASCII and UTF-32 this is only one, but for UTF-8 and UTF-16 it can be multiple code units.
  If the code point is too big or a UTF-16 surrogate, it fails.
  For UTF-8, it also fails for overlong sequences.
Values::
  If `.capture()` was called, it will produce the matched code point as a `lexy::code_point`.
Errors::
  If it could not match a valid code point, it fails with a `lexy::expected_char_class` error with name `<encoding>.code_point`.

[godbolt,cpp,id=YYTfoe]
----
// Match and capture one arbitrary code point.
dsl::code_point.capture()
----

TIP: If you want to match a specific code point, use a literal rule instead.
This rule is useful for matching things like string literals that can contain arbitrary code points.

[discrete]
==== `lexy::dsl::operator-`

.`lexy/dsl/minus.hpp`
----
rule - except    : Rule
pattern - except : Pattern
----

The minus rule matches the given rule or pattern, but only if `except` does not match on the input the rule has consumed.

[horizontal]
Requires::
  `except` is a pattern.
Matches::
  Matches and consumes whatever `rule` or `pattern` match and consume.
  Then matches `except` on the same input.
  Matching fails, if `except` matches the entire input consumed by the rule.
Values::
  Whatever values are produced by `rule`.
Errors::
  Whatever errors are raised if `rule` or `pattern` are not matched.
  A generic error with tag `lexy::minus_failure` if `except` has matched.

TIP: Use a minus rule to exclude characters from a character class; e.g. `lexy::dsl::code_point - lexy::dsl::ascii::control` matches all code points except control characters.

NOTE: Minus rules can be chained. This is equivalent to specifying an alternative for `except`.

WARNING: `except` has to match _everything_ the rule has consumed before; partial matches don't count.
Use `except + lexy::dsl::any` if you want to allow a partial match.

=== Values

The following rules are used to produce additional values without any additional matching.

[discrete]
==== `lexy::dsl::value_*`

.`lexy/dsl/value.hpp`
----
value_c<Value> : Rule
value_f<Fn>    : Rule
value_t<T>     : Rule
value_str<Str> : Rule

LEXY_VALUE_STR(Str) : Rule
----

The `value_*` rules create a constant value without parsing anything.

[horizontal]
Requires::
  * `Value` is any constant.
  * `Fn` is a pointer to a function taking no arguments.
  * `T` is a default-constructible type.
  * `Str` is a string literal.
Matches::
  Any input, but does not consume anything.
Value::
  `value_c`::: The specified constant.
  `value_f`::: The result of invoking the function.
  `value_t`::: A default constructed object of the specified type.
  `value_str`::: The string literal as a pointer, followed by its size.
Error::
  n/a (it does not fail)

TIP: Use the `value_*` rules only to create symmetry between different branches.
Everything they do, can also be achieved using callbacks, which is usually a better solution.

WARNING: The function might not be called or the object might not be constructed in all situations. You cannot rely on their side effects.

NOTE: `value_str<Str>` requires C++20 support for extended NTTPs.
Use the `LEXY_VALUE_STR(Str)` macro if your compiler does not support them.

[discrete]
==== `lexy::dsl::nullopt`

.`lexy/dsl/option.hpp`
[source,cpp]
----
namespace lexy
{
    struct nullopt
    {
        template <typename T>
        constexpr operator T() const
        {
            return T();
        }
    };
}
----

.`lexy/dsl/option.hpp`
----
nullopt : Rule
----

The `nullopt` rule produces a value of type `lexy::nullopt` without parsing anything.

[horizontal]
Matches::
  Any input, but does not consume anything.
Value::
  An object of type `lexy::nullopt`, which is convertible to any other type.
Error::
  n/a (it does not fail)

NOTE: It is meant to be used for symmetry with together with the `opt()` rule.

[discrete]
==== `lexy::dsl::label` and `lexy::dsl::id`

.`lexy/dsl/label.hpp`
[source,cpp]
----
namespace lexy
{
    template <typename Tag>
    struct label
    {
        // only if Tag::value is well-formed
        consteval operator auto() const
        {
            return Tag::value;
        }
    };

    template <auto Id>
    using id = label<std::integral_constant<int, Id>>;
}
----

.`lexy/dsl/label.hpp`
----
label<Tag> : Rule
id<Id>     : Rule
----

The `label` and `id` rules are used to disambiguate between two branches that create otherwise the same values but should resolve to different callbacks.
They simply produce the empty tag object or the id to differentiate them without parsing anything.

[horizontal]
Requires::
  * `Tag` is any type.
  * `Id` is an integer constant.
Matches::
  Any input, but does not consume anything.
Value::
  `label<Tag>`::: A `lexy::label<Tag>` object.
  `id<Id>`::: A `lexy::id<Id>` object.
Error::
  n/a (it does not fail)

.`lexy/dsl/label.hpp`
----
label<Tag>(rule)   : Rule   = label<Tag> + rule
label<Tag>(branch) : Branch = /* as above, except as branch */

id<Id>(rule)   : Rule   = id<Id> + rule
id<Id>(branch) : Branch = /* as above, except as branch */
----

For convenience, `label` and `id` have function call operators.
They produce the label/id and then parse the rule.

[discrete]
==== `lexy::dsl::capture`

.`lexy/dsl/capture.hpp`
----
capture(rule) : Rule
----

The `capture()` rule takes an arbitrary rule and parses it, capturing everything it has consumed into a `lexy::lexeme`.
It is whitespace aware; preceding whitespace is not captured.

[horizontal]
Matches::
  Matches and consumes whatever `rule` matches.
Values::
  A `lexy::lexeme` which begins at the original reader position and ends at the reader position after `rule` has been parsed,
  followed by any other values produced by parsing the `rule` in the same order.
Errors::
  All errors raised by `rule`. It cannot fail itself.

[godbolt,cpp,id=77jfM5]
----
// Captures the entire input.
dsl::capture(dsl::any)
----

[discrete]
==== `lexy::dsl::position`

.`lexy/dsl/position.hpp`
----
position : Rule
----

The `position` rule creates as its value an iterator to the current reader position without consuming any input.

[horizontal]
Matches::
  Any input, but does not consume anything.
Value::
  An iterator to the current position of the reader.
Error::
  n/a (it does not fail)

[godbolt,cpp,id=Wh86vn]
----
// Parses the entire input and returns the final position.
dsl::any + dsl::position
----

TIP: Use `position` when creating an AST whose nodes are annotated with their original source position.

=== Errors

The following rules are used to customize/improve error messages.

[discrete]
==== `lexy::dsl::error`

.`lexy/dsl/error.hpp`
----
error<Tag>          : Pattern
error<Tag>(pattern) : Pattern
----

The `error` pattern always fails and produces an error with the given tag.
For the second version, the pattern is matched first to determine the error range.

[horizontal]
Matches::
  Nothing and always fails.
Error::
  An error object of the specified `Tag`.
  If the optional `pattern` is given, it will be matched.
  If it matched successfully, the previous and new reader position will be used to determine the error range.
  Otherwise, the error has no range.

TIP: Use it as the final branch of a choice rule to customize the `lexy::exhausted_choice` error.

[discrete]
==== `lexy::dsl::require` and `lexy::dsl::prevent`

.`lexy/dsl/error.hpp`
----
require<Tag>(pattern) : Pattern = if_(peek(!pattern) >> error<Tag>)
prevent<Tag>(pattern) : Pattern = if_(peek( pattern) >> error<Tag>)
----

The `require` and `prevent` pattern can be used to lookahead and fail if the input matches or does not match the pattern.

[horizontal]
Matches::
  Both match the `pattern` without consuming input.
  `require` fails if the `pattern` did not match; `prevent` fails if it did.
Error::
  An error object of the specified `Tag`.

[godbolt,cpp,id=W8E3c6]
----
// Parses a sequence of digits but raises an error with tag `forbidden_leading_zero` if a zero is followed by more digits.
// Note: this is already available as `dsl::digits<>.no_leading_zero()`.
dsl::lit_c<'0'> >> dsl::prevent<forbidden_leading_zero>(dsl::digits<>)
    | dsl::digits<>
----

TIP: Use `prevent` together with `times` to prevent the rule from matching more than the specified number of times.

[discrete]
==== `lexy::dsl::try`

.`lexy/dsl/error.hpp`
----
try<Tag>(pattern) : Pattern = if_(!pattern >> error<Tag>)
----

The `try` pattern tries to match the given pattern.
If that fails, it raises the specified error instead.

[horizontal]
Matches::
  The pattern and consumes it.
Error::
  An error object of the specified `Tag`.

=== Branch conditions

The following rules are designed to be used as branch condition.

[discrete]
==== `lexy::dsl::else_`

.`lexy/dsl/branch.hpp`
----
else_ >> rule : Branch = success >> rule
----

`else_` can only be used as a branch condition.
It adds a branch that will be taken if all previous branches did not match.

[discrete]
==== `lexy::dsl::peek`

.`lexy/dsl/peek.hpp`
----
peek(pattern) : Pattern
----

The `peek` pattern matches a pattern without consuming anything.
This can be used for simple lookahead in a branch condition.
It is whitespace aware; leading whitespace will be consumed.

[horizontal]
Matches::
  Whatever the pattern matches, but does not consume it.
Errors::
  All errors raised by `pattern` if it did not match.

CAUTION: Long lookahead can slow down parsing speed due to backtracking.

[discrete]
==== `lexy::dsl::lookahead`

.`lexy/dsl/lookahead.hpp`
----
lookahead(needle, end) : Pattern
----

The `lookahead` pattern performs arbitrary lookahead for a `needle` before `end` without consuming anything.
This can be used for complex lookahead in a branch condition.
It is whitespace aware; leading whitespace will be consumed.

[horizontal]
Requires::
  Both `needle` and `end` must be patterns.
Matches::
  Repeatedly tries to match `needle` until it matches.
  If it doesn't match, advances the reader by one code unit and tries again.
  This process stops if `end` is matched or EOF is reached.
  Does not consume any of the characters it has skipped over.
  Only succeeds, if it has matched the `needle`.
Error::
  A generic error with the tag `lexy::lookahead_failure` if it didn't find the `needle`.

CAUTION: Long lookahead can slow down parsing speed due to backtracking.

[discrete]
==== `lexy::dsl::operator!`

.`lexy/dsl/not.hpp`
----
!pattern : Pattern
----

The not pattern matches a pattern but flips its success and failure; only succeeding if the pattern did not match.

[horizontal]
Matches::
  Matches the pattern.
  If it succeeds, consumes it and fails.
  If it fails, consumes nothing and succeeds.
Error::
  A generic error with tag `lexy::unexpected` if the pattern succeeds.

[godbolt,cpp,id=dcr33a]
----
// Matches alpha characters followed by a semicolon.
// The EOF rule at the end shows that the semicolon was consumed when the while exits.
dsl::while_(!dsl::semicolon >> dsl::ascii::alpha) + dsl::eof
----

[discrete]
==== `lexy::dsl::match`

.`lexy/dsl/match.hpp`
----
match(rule) : Pattern
----

The `match` pattern turns an arbitrary rule into a pattern by parsing it and discarding all values it has produced.
It is whitespace aware.

[horizontal]
Matches::
  Whatever `rule` matches, which will be consumed.
Error::
  A generic error with tag `lexy::no_match` if the `rule` did not match.

NOTE: While `match()` is optimized to prevent any overhead created by constructing values that are later discarded, it still should only be used as a last resort for complex branch conditions.

CAUTION: When used in combination with `peek()`, long lookahead can slow down parsing speed due to backtracking.

=== Branches

[discrete]
==== `lexy::dsl::operator+`

.`lexy/dsl/sequence.hpp`
----
rule + rule       : Rule
pattern + pattern : Pattern
branch + rule     : Branch
----

A sequence rule matches multiple rules one after the other.

[horizontal]
Matches::
  Matches and consume the first rule, then matches and consumes the second rule, and so on.
  Only succeeds if all of them succeed.
Values::
  All the values produced by the rules in the same order as they were matched.
Errors::
  Whatever errors are raised by the individual rules.

[discrete]
==== `lexy::dsl::operator>>`

.`lexy/dsl/branch.hpp`
----
pattern >> rule : Branch
branch >> rule  : Branch = branch.condition() >> branch.then() + rule

branch.condition() : Pattern
branch.then()      : Rule
----

The `operator>>` is used to turn a rule into a branch by giving it a branch condition.
The first overload uses the pattern as the branch condition,
the second overload uses the condition of the branch itself.

If the branch is used as a normal rule or pattern, it first matches the condition followed by the then.
If it is used in a context that requires a branch, the condition is checked to determine whether the branch should be taken.

[discrete]
==== `lexy::dsl::if_`

.`lexy/dsl/if.hpp`
----
if_(branch)  : Rule    = branch | success
if_(pattern) : Pattern = pattern | success
----

The `if_` rule matches a branch only if its condition matches.

[horizontal]
Matches::
  First matches the branch condition.
  If that succeeds, consumes it and matches and consumes the rest of the branch.
  Otherwise, consumes nothing and succeeds anyway.
Values::
  Any values produced by the then of the branch.
Errors::
  Any errors produced by the then of the branch.
  It will only fail after the condition has been matched.

[godbolt,cpp,id=GaxjbP]
----
// Matches an optional C style comment.
dsl::if_(LEXY_LIT("/*") >> dsl::until(LEXY_LIT("*/")))
----

[discrete]
==== `lexy::dsl::opt`

.`lexy/dsl/opt.hpp`
----
opt(branch) : Rule = branch | else_ >> nullopt
----

The `opt` rule matches a branch only if its condition matches.
Unlike `if_`, if the branch was not taken, it produces a `lexy::nullopt`.

[horizontal]
Matches::
  First matches the branch condition.
  If that succeeds, consumes it and matches and consumes the rest of the branch.
  Otherwise, consumes nothing and succeeds anyway.
Values::
  If the branch condition matches, any values produced by the rule.
  Otherwise, a single object of type `lexy::nullopt`.
Errors::
  Any errors produced by the then of the branch.
  It will only fail after the condition has been matched.

[godbolt,cpp,id=nq33hY]
----
// Matches an optional list of alpha characters.
// (The id<0> is just there, so the sink will be invoked on each character).
// If no items are present, it will default construct the list type.
dsl::opt(dsl::list(dsl::ascii::alpha >> dsl::id<0>))
----

[discrete]
==== `lexy::dsl::operator|`

.`lexy/dsl/choice.hpp`
----
branch  | branch  : Rule
pattern | pattern : Pattern
----

A choice rule matches the first branch in order whose condition was matched.

[horizontal]
Matches::
  Tries to match the condition of each branch in the order they were specified.
  As soon as one branch condition matches, matches and consumes that branch without ever backtracking to try another branch.
  If no branch condition matched, fails without consuming anything.
Values::
  Any values produced by the selected branch.
Errors::
  Any errors raised by the then of the selected branch.
  If no branch condition matched, a generic error with tag `lexy::exhausted_choice`.

[godbolt,cpp,id=aaEnW7]
----
// A contrived example to illustrate the behavior of choice.
// Note that branch with id 1 will never be taken, as branch 0 takes everything starting with a and then fails if it isn't followed by bc.
// The correct behavior is illustrated with 2 and 3, there the branch with the longer condition is listed first.
dsl::id<0>(LEXY_LIT("a") >> LEXY_LIT("bc"))
  | dsl::id<1>(LEXY_LIT("a") >> LEXY_LIT("b"))
  | dsl::id<2>(LEXY_LIT("bc"))
  | dsl::id<3>(LEXY_LIT("b"))
----

NOTE: The C++ operator precedence is specified in such a way that `condition >> a | else_ >> b` works.
The compiler might warn that the precedence is not intuitive without parentheses, but in the context of this DSL it is the expected result.

TIP: Use `â€¦ | error<Tag>` to raise a custom error instead of `lexy::exhausted_choice`.

[discrete]
==== `lexy::dsl::operator/`

.`lexy/dsl/alternative.hpp`
----
pattern / pattern : Pattern
----

An alternative rule tries to match each pattern in order, backtracking if necessary.

[horizontal]
Matches::
  Tries to match each pattern in the order they were specified.
  As soon as one pattern matches, consumes it and succeeds.
  If no pattern matched, fails without consuming anything.
Errors::
  A generic error with tag `lexy::exhausted_alternatives` if no pattern matched.

CAUTION: Even if the pattern of an alternative is actually a branch, it will not be treated as a branch but it tries the entire pattern, backtracking if necessary.
Use a choice rule with a suitable condition to avoid long backtracking instead.

[discrete]
==== `lexy::dsl::switch_`

.`lexy/dsl/switch.hpp`
----
switch_(rule) : Rule

switch_(rule).case_(branch)  : Rule
switch_(rule).default_(rule) : Rule = switch_(rule).case_(else_ >> rule)
switch_(rule).error<Tag>()   : Rule = switch_(rule).case_(error<Tag>(any))
----

The `switch_` rule matches a rule and then switches over the input the rule has consumed.
Switch cases can be added by calling `.case_()`; they are tried in order.
A default case is added using `.default_()`; it is taken unconditionally.
Alternatively, an error case can be added using `.error<Tag>()`; it produces an error if no previous case has matched.

[horizontal]
Matches::
  First matches and consumes the switched rule.
  What the rule has consumed is then taken as the entire input for matching the switch cases.
  Then it tries to match the branch conditions of each case in order.
  When a branch condition matches, that case is taken and its then is matched.
  If no case has matched, it fails.
Values::
  Any values produced by the switched rule followed by any values produced by the selected case.
Errors::
  If the switched rule fails to match, any errors raised by it.
  If the branch condition of a case has matched, any errors raised by the then.
  If the switch had an error case, a generic error with the specified `Tag` is raised whose range is everything consumed by the switched rule.
  Otherwise, a generic error with tag `lexy::exhausted_switch` is raised.

[godbolt,cpp,id=G87Mqf]
----
// Parse identifiers (one or more alpha numeric characters) but detect the three reserved keywords.
// We use `+ dsl::eof` in the case condition to ensure that `boolean` is not matched as `bool`.
dsl::switch_(dsl::while_one(dsl::ascii::alnum))
    .case_(LEXY_LIT("true")  + dsl::eof >> dsl::id<1>)
    .case_(LEXY_LIT("false") + dsl::eof >> dsl::id<2>)
    .case_(LEXY_LIT("bool")  + dsl::eof >> dsl::id<3>)
    .default_(dsl::id<0>) // It wasn't a reserved keyword but a normal identifier.

// Note: a more efficient and convenient method for handling keywords is planned.
----

NOTE: It does not matter if the then of a case does not consume everything the original rule has consumed.
As soon as the then has matched everything parsing continues from the reader position after the switched rule has been matched.

=== Loops

[discrete]
==== `lexy::dsl::until`

.`lexy/dsl/until.hpp`
----
until(pattern)          : Pattern
until(pattern).or_eof() : Pattern = until(pattern / eof)
----

The `until` pattern consumes all input until the specified `pattern` matches, then consumes that.

[horizontal]
Matches::
  If the closing `pattern` matches, consumes it and succeeds.
  Otherwise, consumes one code unit and tries again.
  If EOF is reached, fails, unless `.or_eof()` was called, in which case it also succeeds having consumed everything until the end of the input.
Errors::
  It can only fail if the reader has reached the end of the input without matching the condition.
  Then it raises the same error as raised if one tries to match the pattern at EOF.

[godbolt,cpp,id=Yn4WTj]
----
// Matches a C style comment.
// Note that we don't care what it contains.
LEXY_LIT("/*") >> dsl::until(LEXY_LIT("*/"))
----

NOTE: `until` includes the `pattern`, use `until(peek(pattern))` if it should not consume the pattern.
This was done because it is more efficient than the other way round.

[discrete]
==== `lexy::dsl::loop`

.`lexy/dsl/loop.hpp`
----
loop(rule) : Rule

break_ : Rule
----

The `loop` rule matches the given rule repeatedly until it either fails to match or a `break_` rule was matched.

[horizontal]
Requires::
  `rule` must not produce any values.
  `break_` must be used inside a loop.
Matches::
  While the rule matches, consumes it and repeats.
  If a `break_` is matched, parsing will stop immediately and it succeeds.
  If the rule does not match, it fails.
Values::
  No values are produced.
Errors::
  Any errors raised when the rule fails to match.

NOTE: The `loop` rule is mainly used to implement other rules.
It is unlikely that you are going to need it yourself.

WARNING: If `rule` contains a branch that will not consume any characters but does not break, `loop` will loop forever.

[discrete]
==== `lexy::dsl::while_`

.`lexy/dsl/while.hpp`
----
while_(branch)  : Rule
while_(pattern) : Pattern
----

The `while` rule matches a branch as long as it condition has matched.

[horizontal]
Requires::
  `branch` must not produce any values.
Matches::
  While the branch condition matches, matches and consumes the then then repeats.
  If the branch condition does not match anymore, succeeds without consuming additional input.
Values::
  No values are produced.
Errors::
  The rule can only fail if the then of the branch fails.
  Then it will raise its error unchanged.

WARNING: If the branch does not consume any characters, `while_` will loop forever.

'''

.`lexy/dsl/while.hpp`
----
while_(choice)         : Rule = loop(choice | else_ >> break_)
while_(choice_pattern) : Pattern
----

This version of the `while_` rule repeatedly matches a choice as long as one branch matches.

[horizontal]
Requires::
  `choice` most not produce any values.
Matches::
  While one branch condition of the choice matches, consumes it and the rest of the branch.
  If no branch matches anymore, succeeds without consuming additional input.
Values::
  No values are produced.
Errors::
  The rule can only fail if the then of one of the choice branches fails.
  Then it will raise its error unchanged.

WARNING: If the choice has an else branch already, it will loop until an error is raised.

[discrete]
==== `lexy::dsl::while_one()`

.`lexy/dsl/while.hpp`
----
while_one(branch) : Branch
    = branch.condition() >> branch.then() + while_(branch)

while_one(pattern) : Pattern = pattern + while_(pattern)
----

The `while_one` rule matches a rule one or more times.

[discrete]
==== `lexy::dsl::do_while()`

.`lexy/dsl/while.hpp`
----
do_while(rule, pattern) : Rule = rule + while_(pattern >> rule)

do_while(branch, pattern) : Branch
    = branch.condition() >> branch.then() + while_(pattern >> branch)
----

The `do_while` rule matches a rule first unconditionally, and then again repeatedly while the pattern matches.

[godbolt,cpp,id=4dzEK7]
----
// Equivalent to `dsl::list(dsl::ascii::alpha, dsl::sep(dsl::comma))` but does not produce a value.
dsl::do_while(dsl::ascii::alpha, dsl::comma)
----

[discrete]
==== `lexy::dsl::sep` and `lexy::dsl::trailing_sep`

.`lexy/dsl/separator.hpp`
----
sep(pattern)
trailing_sep(pattern)

sep(pattern).capture()
trailing_sep(pattern).capture()
----

`sep` and `trailing_sep` are used to specify a separator between repeated items; they are not rules that can be parsed directly.

Use `sep(pattern)` to indicate that `pattern` has to be consumed between two items.
If it would match after the last item, it is not consumed by the rule.

Use `trailing_sep(pattern)` to indicate that `pattern` has to be consumed between two items and can occur after the final item.
If it matches after the last item, it is consumed as well.

By calling `.capture()`, the matched separator will be captured as a `lexy::lexeme`.

[discrete]
==== `lexy::dsl::times`

.`lexy/dsl/times.hpp`
[source,cpp]
----
namespace lexy
{
    template <std::size_t N, typename T>
    using times = T (&)[N];

    template <typename T>
    using twice = times<2, T>;
}
----

.`lexy/dsl/times.hpp`
----
times<N>(rule)      : Rule
times<N>(rule, sep) : Rule

twice(rule)      : Rule = times<2>(rule)
twice(rule, sep) : Rule = times<2>(rule, sep)
----

The `times` rule repeats the rule `N` times with optional separator in between and collects all produced values into an array.
The `twice` rule is a convenience alias for `N = 2`.

[horizontal]
Requires::
  The separator must not be captured and all values produced by the parsing the rule must have a common type.
  In particular, the rule must only produce one value.
Matches::
  If no separator is specified, matches and consumes `rule` `N` times.
  If a separator is specified, matches and consumes `rule` `N` times, consuming the separator between two items and potentially after all items if the separator is trailing.
Values::
  Produces a single array containing `N` items which are all the values produced by each repetition.
  The typedef `lexy::times` or `lexy::twice` can be used to process that array.
Errors::
  All errors raised by matching the rule or separator.

[godbolt,cpp,id=hrTKaT]
----
// Parses an IPv4 address (4 uint8_t's seperated by periods).
dsl::times<4>(dsl::integer<std::uint8_t>(dsl::digits<>), dsl::sep(dsl::period))
----

[discrete]
==== `lexy::dsl::build_list` and `lexy::dsl::item`

.`lexy/dsl/list.hpp`
----
build_list(rule) : Rule

item(rule)   : Rule
item(branch) : Branch
----

Using the `build_list` and `item` rule allows using a sink callback instead of a regular callback.
The `build_list` rule starts a sinks, parses the given rule and then finishes the sink.
If the given rule contains an `item` rule, all values produced by the rule of the `item` are passed to the sink.

[horizontal]
Requires::
  The `item` rule must be used inside of `build_list()`.
  A production whose rule contains `build_list()` must provide a sink.
Matches::
  For the purposes of matching and consumption, `build_list(rule)` and `item(rule)` are equivalent to `rule`.
Values::
  `item(rule)` produces all values of `rule`, but as sink arguments, not as callback arguments.
  `build_list(rule)` produces all values of `rule`, followed by the finalized sink.
Errors::
  Any errors raised by the respective rules.

[godbolt,cpp,id=bdE3Wa]
----
// We build a list that contains two items, `lexy::id<1>` and `lexy::id<2>`.
// Only `abc` is matched.
dsl::build_list(dsl::item(dsl::id<1>) + LEXY_LIT("abc") + dsl::item(dsl::id<2>))
----

NOTE: The `build_list` and `item` rules are mainly used to implement the `list` rule.
It is unlikely that you are going to need it yourself.

[discrete]
==== `lexy::dsl::list`

.`lexy/dsl/list.hpp`
----
list(rule)   : Rule
list(branch) : Branch

list(rule, sep)   : Rule
list(branch, sep) : Branch
----

The `list` rule matches a rule one or more times, optionally separated by a separator.
Values produced by the list items are forwarded to a sink callback.

[horizontal]
Requires::
  The item rule must be a branch or a choice rule unless a non-trailing separator is used (in that case the separator pattern can be used as condition).
  A production whose rule contains `list()` must provide a sink.
Matches::
  Matches and consumes the item rule one or more times.
  In between items and potentially after the final item, a separator is matched and consumed if provided according to its rules.
  If the separator is provided and non-trailing, the existence of a separator determines whether or not the rule should be matched again.
  Otherwise, the branch condition of the branch rule or an added else branch of the choice rule is used to determine that.
Values::
  Only a single value, which is the result of the finished sink.
  Every time the item rule is parsed, all values it produces are passed to the sink which is invoked once per iteration.
  If the separator is captured, its lexeme is also passed to the sink, but in a separate invocation.
Errors::
  All errors raised when parsing the item rule or separator.

[godbolt,cpp,id=fod3vY]
----
// Parses a list of integers seperated by (a potentially trailing) comma.
// As the separator is trailing, it cannot be used to determine the end of the list.
// As such we peek whether the input contains a digit in our item condition.
// The sink is invoked with each integer.
dsl::list(dsl::peek(dsl::digit<>) >> dsl::integer<int>(dsl::digits<>),
          dsl::trailing_sep(dsl::comma))
----

TIP: Use one of the bracketing rules if your list item does not have an easy condition and the list is surrounded by given patterns anyway.

[discrete]
==== `lexy::dsl::combination`

.`lexy/dsl/combination.hpp`
----
combination(branch1, branch2, ...) : Rule
combination<Tag>(branch1, branch2, ...) : Rule
----

The `combination` rule matches each of the sub-rules exactly once but in any order.
Values produced by the rules are forwarded to a sink.

[horizontal]
Requires::
  A production whose rule contains `combination()` must provide a sink.
Matches::
  Matches and consumes all rules in an arbitrary order.
  This is done by parsing the choice created from the branches exactly `N` times.
  Branches that have already been taken are not excluded on future iterations.
  If they are taken again, the rule fails.
Values::
  Only a single value, which is the result of the finished sink.
  All values produced by the branches are passed to the sink which is invoked once per iteration.
Errors::
  All errors raised by parsing the branches.
  If no branch is matched, but there are still missing branches,
  a generic error with tag `lexy::exhausted_choice` is raised.
  If a branch is matched twice, a generic error is raised.
  It has the specified tag or `lexy::combination_duplicate` if none was specified.

[godbolt,cpp,id=bjKqvj]
----
// Matches 'a', 'b', or 'c', in any order.
dsl::combination(dsl::lit_c<'a'>, dsl::lit_c<'b'>, dsl::lit_c<'c'>)
----

WARNING: The branches are tried in order. If an earlier branch always takes precedence over a later one, the combination can never be successful.

[discrete]
==== `lexy::dsl::partial_combination`

.`lexy/dsl/combination.hpp`
----
partial_combination(branch1, branch2, ...) : Rule
partial_combination<Tag>(branch1, branch2, ...) : Rule
----

The `partial_combination` rule matches each of the sub-rules at most once but in any order.
Values produced by the rules are forwarded to a sink.

[horizontal]
Requires::
  A production whose rule contains `partial_combination()` must provide a sink.
Matches::
  Matches and consumes a subset of the rules in an arbitrary order.
  This is done by parsing the choice created from the branches exactly `N` times.
  Branches that have already been taken are not excluded on future iterations.
  If they are taken again, the rule fails.
  If no branch is taken, the rule succeeds.
Values::
  Only a single value, which is the result of the finished sink.
  All values produced by the branches are passed to the sink which is invoked once per iteration.
Errors::
  All errors raised by parsing the branches.
  If a rule is matched twice, a generic error is raised.
  It has the specified tag or `lexy::combination_duplicate` if none was specified.

[godbolt,cpp,id=85dv9W]
----
// Matches a subset of 'a', 'b', or 'c', in any order.
dsl::partial_combination(dsl::lit_c<'a'>, dsl::lit_c<'b'>, dsl::lit_c<'c'>)
----

WARNING: The branches are tried in order. If an earlier branch always takes precedence over a later one, the combination can never be successful.

=== Productions

Every rule is owned by a production.
The following rules allow interaction with other productions.

[discrete]
==== `lexy::dsl::p` and `lexy::dsl::recurse`

.`lexy/dsl/production.hpp`
----
p<Production> : Rule or Branch
recurse<Production> : Rule
----

The `p` and `recurse` rules parses the rule of another production.
The `p` rule is a branch, if the rule of the other production is a branch.
Both are whitespace aware.

[horizontal]
Requires::
  For `p`, the `Production` is a complete type at the point of the rule definition.
  The `recurse` rule has no such limitations.
Matches::
  Matches and consumes `Production::rule`.
Values::
  A single value, which is the result of parsing the production.
  All values produced by parsing its rule are forwarded to the productions value callback.
Errors::
  If matching fails, `Production::rule` will raise an error which is handled in the context of `Production`.
  This results in a failed result object, which is converted to our result type and returned.

[godbolt,cpp,id=oj9T3n]
----
// Parse a sub production followed by an exclamation mark.
dsl::p<sub_production> + dsl::lit_c<'!'>
----

TIP: While `recurse` can be used to implement direct recursion (e.g. `prefix >> dsl::p<current_production> | dsl::else_ >> end` to match zero or more `prefix` followed by `end`), it is better to use loops instead.

WARNING: Left recursion will create an infinite loop.

[discrete]
==== `lexy::dsl::return_`

.`lexy/dsl/return.hpp`
----
return_ : Rule
----

Conceptually, each production has an associated function that parses the specified rule.
The `return_` rule will exit that function early, without parsing subsequent rules.

[horizontal]
Requires::
  It must not be used inside loops.
Matches::
  Any input, but does not consume anything.
  Subsequent rules are not matched further.
Values::
  It does not produce any values, but all values produced so far are forwarded to the callback.
Errors::
  n/a (it does not fail)

[godbolt,cpp,id=zrbcaq]
----
// Match an opening parenthesis followed by 'a' or 'b'.
// If it is followed by 'b', the closing parenthesis is not matched anymore.
dsl::parenthesized(dsl::lit_c<'a'> | dsl::lit_c<'b'> >> dsl::return_)
----

CAUTION: When using `return_` together with the context sensitive parsing facilities, remember to pop all context objects before the return.

=== Brackets and parentheses

.`lexy/dsl/brackets.hpp`
----
brackets(open_branch, close_branch)
brackets(open_branch, close_branch).open()  : Branch = open_branch
brackets(open_branch, close_branch).close() : Branch = close_branch
----

A set of open and close brackets can be specified using `brackets()`.
The result is not a rule, but a DSL for specifying that a rule is surrounded by brackets.
The open and close brackets are defined using branches; they are returned by calling `.open()` and `.close()`.

.`lexy/dsl/brackets.hpp`
----
b[rule]
----

Whitespace can be added by writing `b[rule]`, where `b` is the result of a `brackets()` call.
It will skip whitespace before matching the open and close branch.
If whitespace is added, this is also reflected by `.open()` and `.close()`.

.`lexy/dsl/brackets.hpp`
----
b(rule) : Branch = b.open() >> rule + b.close()
----

Calling `b(rule)`, where `b` is the result of a `brackets()` call, results in a rule that parses the given `rule` surrounded by brackets.
The rule is a branch that uses the opening bracket as a branch condition.

.`lexy/dsl/brackets.hpp`
----
b.opt(rule) : Branch

b.list(rule) : Branch
b.list(rule, sep) : Branch

b.opt_list(rule) : Branch
b.opt_list(rule, sep) : Branch
----

Using `b.opt()`, `b.list()`, or `b.opt_list()`, where `b` is the result of a `brackets()` call, results in a branch that parses `opt(rule)`, `list(rule)` and `opt(list(rule))`, respectively, but surrounded as brackets.
The `rule` does not need to be a branch as the closing brackets is used as the branch condition for the `opt()` and `list()` rule.

.`lexy/dsl/brackets.hpp`
----
round_bracketed  = brackets(lit_c<'('>, lit_c<')'>)
square_bracketed = brackets(lit_c<'['>, lit_c<']'>)
curly_bracketed  = brackets(lit_c<'{'>, lit_c<'}'>)
angle_bracketed  = brackets(lit_c<'<'>, lit_c<'>'>)

parenthesized = round_bracketed
----

Common sets of open and close brackets are pre-defined.

[godbolt,cpp,id=dzMTnx]
----
// Parses a list of integers seperated by (a potentially trailing) comma surrounded by parentheses.
// The same example without the parentheses was also used for list,
// but we required a list condition that needed to perform lookahead.
// Now, the closing parentheses is used as the condition and we don't need to lookahead.
dsl::parenthesized.list(dsl::integer<int>(dsl::digits<>),
                        dsl::trailing_sep(dsl::comma))
----

=== Numbers

The facilities for parsing integers are split into the digits pattern,
which do not produce any values, and the `integer` rule, which matches a digit pattern and converts it into an integer.
The integer conversion has to be done during and parsing and not as a callback, as overflow creates a parse error.

[discrete]
==== Base

.`lexy/dsl/digit.hpp`
[source,cpp]
----
namespace lexy::dsl
{
    struct binary;
    struct octal;
    struct decimal;
    struct hex_lower;
    struct hex_upper;
    struct hex;
}
----

The set of allowed digits and their values is specified using a `Base`, which is a policy class passed to the rules.

`binary`::
  Matches the base 2 digits `0` and `1`.
`octal`::
  Matches the base 8 digits `0-7`.
`decimal`::
  Matches the base 10 digits `0-9`. If no base is specified, this is the default.
`hex_lower`::
  Matches the lower-case base 16 digits `0-9` and `a-f`.
`hex_upper`::
  Matches the upper-case base 16 digits `0-9` and `A-F`.
`hex`::
  Matches the base 16 digits `0-9`, `A-F`, and `a-f`.

[discrete]
==== `lexy::integer_traits`

.`lexy/dsl/integer.hpp`
----
namespace lexy
{
    template <typename T>
    struct integer_traits
    {
        using type = T;

        static constexpr bool is_bounded;

        template <int Radix>
        static constexpr std::size_t max_digit_count;

        template <int Radix>
        static constexpr void add_digit_unchecked(type& result, unsigned digit);
        template <int Radix>
        static constexpr bool add_digit_checked(type& result, unsigned digit)
    };

    template <>
    struct integer_traits<lexy::code_point>;

    template <typename T>
    struct unbounded
    {};
    template <typename T>
    struct integer_traits<unbounded<T>>
    {
        using type                       = typename integer_traits<T>::type;
        static constexpr bool is_bounded = false;

        template <int Radix>
        static constexpr void add_digit_unchecked(type& result, unsigned digit);
    };
}
----

The `lexy::integer_traits` are used for parsing an integer.
It controls its maximal value and abstracts away the required integer operations.

The `type` member is the actual type that will be returned by the parse operation. It is usually `T`.
The parsing algorithm does not require that `type` is an integer type, it only needs to have a constructor that initializes it from an `int`.
If `is_bounded` is `true`, parsing requires overflow checking.
Otherwise, parsing does not require overflow checking and `max_digit_count` and `add_digit_checked` are not required.
`max_digit_count` returns the number of digits necessary to express the bounded integers maximal value in the given radix.
It must be bigger than `1`.
`add_digit_unchecked` and `add_digit_checked` add `digit` to result by doing the equivalent of `result = result * Radix + digit`.
The `_checked` version returns `true` if that has lead to an integer overflow.

The primary template works with any integer type and there is a specialization for `lexy::code_point`.
By wrapping your integer type in `lexy::unbounded`, you can disable bounds checking during parsing.
It specialization of `lexy::integer_traits` is built on top of the specialization of `lexy::integer_traits<T>`,
but disables all bounds checking.
You can specialize `lexy::integer_traits` for your own integer types.

[discrete]
==== `lexy::dsl::digit`

.`lexy/dsl/digit.hpp`
----
digit<Base> : Pattern

digit<Base>.zero()     : Pattern
digit<Base>.non_zero() : Pattern
----

The `digit` pattern matches a digit of the specified base or `decimal` if no base was specified.
The `zero()` and `non_zero()` patterns match zero or a non-zero digit respectively.

[horizontal]
Matches::
  `digit`:::
    Matches and consumes any of the valid digits of the base.
  `digit.zero()`:::
    Matches and consumes the zero digit of the base (it is the same for all of them).
  `digit.non_zero()`:::
    Matches and consumes any of the valid digits of the base except zero.
Errors::
  `digit`:::
    Raises a `lexy::expected_char_class` error with the name `digit.<base>`, where `<base>` is `binary`, `hex-lower`, etc.
  `digit.zero()`:::
    Raises a `lexy::expected_char_class` error with the name `digit.zero`.
  `digit.non_zero()`:::
    If it didn't match any valid digit, raises the same error as `digit`.
    Otherwise, raises a `lexy::expected_char_class` error with the name `digit.non-zero`.

[discrete]
==== `lexy::dsl::digits`

.`lexy/dsl/digit.hpp`
----
digits<Base> : Pattern

digits<Base>.sep(pattern)      : Pattern
digits<Base>.no_leading_zero() : Pattern
----

The `digits` pattern matches a non-empty sequence of digits in the specified base or `decimal` if no base was specified.
Calling `.sep()` allows adding a digit separator pattern that can be present at any point between two digits, but is not required.
Calling `.no_leading_zero()` raises an error if one or more leading zeros are encountered.
The calls to `.sep()` and `.no_leading_zero()` can be chained.

[horizontal]
Matches::
  Matches and consumes one or more digits of the specified base.
  If a separator was added, it tries to match it after every digit.
  It is consumed if it was matched, but it does not fail if no separator was present.
  If a separator is matched without a following digit, it fails.
  If `.no_leading_zero()` was called, fails if the first digit was zero and it is followed by another digit or separator.
  If it could not match any more digits after the initial one, matching succeeds.
Errors::
  All errors raised by `digit<Base>`, which can only happen for the initial digit.
  Raises a generic error with tag `lexy::forbidden_leading_zero` if a leading zero was matched.

[godbolt,cpp,id=Kq1vez]
----
// Matches upper-case hexadecimal digits seperated by ' without leading zeroes.
dsl::digits<dsl::hex_upper>.sep(dsl::digit_sep_tick).no_leading_zero()
----

NOTE: The separator can be placed at any point between two digits.
There is no validation of rules to ensure it is a thousand separator or similar conventions.

'''

.`lexy/dsl/digit.hpp`
----
digit_sep_underscore : Pattern = lit<"_">
digit_sep_tick       : Pattern = lit<"'">
----

For convenience, two common digit separators `_` and `'` are predefined as `digit_sep_underscore` and `digit_sep_tick` respectively.
However, the digit separator can be an arbitrarily complex pattern.

[discrete]
==== `lexy::dsl::n_digits`

.`lexy/dsl/digit.hpp`
----
n_digits<N, Base> : Pattern

n_digits<N, Base>.sep(pattern)      : Pattern
----

The `n_digits` pattern matches exactly `N` digits in the specified base or `decimal` if no base was specified.
Calling `.sep()` allows adding a digit separator pattern that can be present at any point between two digits, but is not required.

[horizontal]
Matches::
  Matches and consumes exactly `N` digits of the specified base.
  If a separator was added, it tries to match it after every digit.
  It is consumed if it was matched, but it does not fail if no separator was present.
  If a separator is matched without a following digit, it fails.
  Separators do not count towards the digit count.
Errors::
  All errors raised by `digit<Base>`, which can happen if less than `N` digits are available.
  Raises a generic error with tag `lexy::forbidden_leading_zero` if a leading zero was matched.

[godbolt,cpp,id=1YcrGa]
----
// Matches 4 upper-case hexadecimal digits seperated by '.
dsl::n_digits<4, dsl::hex_upper>.sep(dsl::digit_sep_tick)
----

[discrete]
==== `lexy::dsl::integer`

.`lexy/dsl/integer.hpp`
----
integer<T, Base>(pattern) : Rule
----

The `integer` rule converts the lexeme matched by the `pattern` into an integer of type `T` using the given base.
The `Base` can be omitted if the pattern is `digits` or `n_digits`.
It will then be deduced from the pattern.

[horizontal]
Matches::
  Matches and consumes what `pattern` matches.
Values::
  An integer of type `T` that is created by the characters the pattern has consumed.
  If the pattern matches characters that are not valid digits of the base (e.g. a digit separator), those characters are skipped.
  Otherwise, the character is converted to a digit and added to the resulting integer using the `lexy::integer_traits`.
Errors::
  Any errors raised by matching the pattern.
  If the integer type `T` is bounded and the integer value would overflow, a generic error with tag `lexy::integer_overflow` is raised.

[godbolt,cpp,id=6ThWPn]
----
// Matches upper-case hexadecimal digits seperated by ' without leading zeroes.
// Converts them into an integer, the base is deduced from the pattern.
dsl::integer<int>(dsl::digits<dsl::hex_upper>
                        .sep(dsl::digit_sep_tick).no_leading_zero())
----

[discrete]
==== `lexy::dsl::code_point_id`

.`lexy/dsl/integer.hpp`
----
code_point_id<N, Base> : Rule = integer<lexy::code_point>(n_digits<N, Base>)
----

The `code_point_id` rule is a convenience rule that parses a code point.
It matches `N` digits in the specified base, which defaults to `hex`, and converts it into a code point.

[horizontal]
Matches::
  Matches and consumes exactly `N` digits of the specified base.
Values::
  The `lexy::code_point` that is specified using those digits.
Errors::
  The same error as `digit<Base>` if fewer than `N` digits are available.
  A generic error with tag `lexy::integer_overflow` if the code point value would exceed the maximum code point.

[discrete]
==== `lexy::dsl::plus_sign`, `lexy::dsl::minus_sign`, and `lexy::dsl::sign`

.`lexy/dsl/sign.hpp`
----
plus_sign  : Rule
minus_sign : Rule

sign : Rule
----

The `plus_sign`, `minus_sign`, and `sign` rule match an optional sign.

[horizontal]
Matches::
  `plus_sign`:::
    Matches and consumes a `+` character, if there is one.
  `minus_sign`:::
    Matches and consumes a `-` character, if there is one.
  `sign`:::
    Matches and consumes a `+` or `-` character, if there is one.
Values:::
  If a `+` sign was consumed, the value is `+1`.
  If a `-` sign was consumed, the value is `-1`.
  If no sign was consumed, the value is `+1`.
Errors::
  n/a (they don't fail)

[godbolt,cpp,id=7exP55]
----
// Parse a decimal integer with optional minus sign.
dsl::minus_sign + dsl::integer<int>(dsl::digits<>)
----

TIP: The callback `lexy::as_integer` takes the value produced by the sign rules together with an integer produced by the `integer` rule and negates it if necessary.

=== Delimited and quoted

.`lexy/dsl/delimited.hpp`
----
delimited(open_branch, close_branch)
delimited(open_branch, close_branch).open()  : Branch = open_branch
delimited(open_branch, close_branch).close() : Branch = close_branch
----

A set of open and close delimiters can be specified using `delimited()`.
The result is not a rule, but a DSL for specifying a sequence of code points to be matched between the delimiters.
The open and close delimiters are defined using branches; they are returned by calling `.open()` and `.close()`.

.`lexy/dsl/delimited.hpp`
----
delimited(branch) = delimited(branch, branch)
----

There is a convenience overload if the same rule is used for the open and closing delimiters.

.`lexy/dsl/delimited.hpp`
----
d[rule]
----

Whitespace can be added by writing `d[pattern]`, where `d` is the result of a `delimiter()` call.
It will skip whitespace before the opening delimiter only.
If whitespace is added, this is also reflected by `.open()`.

.`lexy/dsl/delimited.hpp`
----
quoted        = delimited(lit<"\"">)
triple_quoted = delimited(lit<"\"\"\"">)

single_quoted = delimited(lit<"'">)

backticked        = delimited(lit<"`">)
double_backticked = delimited(lit<"``">)
triple_backticked = delimited(lit<"```">)
----

Common delimiters are predefined.

NOTE: The naming of `quoted`, `triple_quoted` and `single_quoted` is not very logical, but reflects common usage.

[discrete]
==== Simple delimited

.`lexy/dsl/delimited.hpp`
----
d(rule)    : Rule
d(pattern) : Rule = d(capture(pattern))
----

Calling `d(rule)`, where `d` is the result of a `delimiter()` call, results in a rule that matches `rule` as often as possible surrounded by the delimiters.
Values produced by the `rule` are forwarded to a sink callback.

For convenience, if passing a pattern, the pattern is captured.
Otherwise, nothing would be passed to the sink.

[horizontal]
Requires::
  A production whose rule contains a delimited rule must provide a sink.
Matching::
  Matches and consumes the opening delimiter, followed by zero or more occurrences of `rule`, followed by the closing delimiter.
  It determines whether or not to parse another instance of `rule` using the condition of the closing delimiter.
Values::
  Values produced by the opening delimiter, the finished sink (which might be empty), and values produced by the closing delimiter.
  Every time the rule is parsed, all values produced by it are passed to the sink.
Errors::
  All errors raised when matching the opening delimiter and the rule.
  If EOF is reached without a closing delimiter, a generic error with tag `lexy::missing_delimiter` is raised.

[godbolt,cpp,id=WPzos5]
----
// Match a string consisting of code points that aren't control characters.
dsl::quoted(dsl::code_point - dsl::ascii::control)
----

[discrete]
==== Delimited with escape sequences

.`lexy/dsl/delimited.hpp`
----
d(rule, escape_branch)    : Rule
  = d(escape_branch | else_ >> rule)
d(pattern, escape_branch) : Rule
  = d(escape_branch | else_ >> capture(rule))

d(rule, escape_choice)    : Rule
  = d(escape_choice | else_ >> rule)
d(pattern, escape_choice) : Rule
  = d(escape_choice | else_ >> capture(rule))
----

There is a convenience overload to specify escape sequences in the delimited.
The `choice` matches all appropriate escape sequences and produces their values.

Calling `d(rule, escape)`, where `d` is the result of a `delimiter()` call, is equivalent to `d(escape | else_ >> rule)`, so it results in a rule that matches `escape | else_ >> rule` as often as possible surrounded by the delimiters.
Values produced by the `rule` or `escape` are forwarded to a sink callback.

For convenience, if passing a pattern, the pattern is captured.
Otherwise, nothing would be passed to the sink.

[godbolt,cpp,id=7ed5Wc]
----
// Match a string consisting of code points that aren't control characters.
// `\"` can be used to add a `"` to the string.
dsl::quoted(dsl::code_point - dsl::ascii::control,
            LEXY_LIT("\\\"") >> dsl::value_c<'"'>)
----

NOTE: The closing delimiter is used as termination condition here as well.
If the escape sequence starts with a closing delimiter, it will not be matched.

[discrete]
==== `lexy::dsl::escape()`

.`lexy/dsl/delimited.hpp`
----
escape(pattern) : Rule
----

For convenience, the `escape` rule can be used to specify the escape pattern.

An escape rule consists of a leading pattern that matches the escape character (e.g. `\`), and zero or more alternatives for characters that can be escaped.
It then is equivalent to `pattern >> (alt0 | alt1 | alt2 | else_ >> error<lexy::invalid_escape_sequence>)`.
It will only be considered after the leading pattern has been matched and then tries to match one of the alternatives.
If no alternative matches, it raises a generic error with tag `lexy::invalid_escape_sequence`.

.`lexy/dsl/delimited.hpp`
----
e.rule(branch) : Rule
  = escape_pattern >> ( ... | branch
                      | else_ >> error<lexy::invalid_escape_sequence>)
----

Calling `e.rule(branch)`, where `e` is an escape rule, adds `branch` to the end of the choice.

.`lexy/dsl/delimited.hpp`
----
e.capture(pattern) : Rule
  = escape_pattern >> (... | peek(pattern) >> capture(pattern)
                      | else_ >> error<lexy::invalid_escape_sequence>)
----

Calling `e.capture(pattern)`, where `e` is an escape rule, adds an escape sequence that matches and captures pattern to the end of the choice.

.`lexy/dsl/delimited.hpp`
----
e.lit<Str>(rule) : Rule
  = escape_pattern >> (... | lit<Str> >> rule
                      | else_ >> error<lexy::invalid_escape_sequence>)
e.lit<Str>() : Rule
  = e.lit<Str>(value_str<Str>)

e.lit_c<C>(rule) : Rule
  = escape_pattern >> (... | lit_c<C> >> rule
                      | else_ >> error<lexy::invalid_escape_sequence>)
e.lit_c<C>() : Rule
  = e.lit_c<C>(value_c<C>)
----

Calling `e.lit()` or `e.lit_c()`, where `e` is an escape rule, adds an escape sequences that matches the literal and produces the values of the rule to the end of the choice.
If no rule is specified, it defaults to producing the literal itself.

.`lexy/dsl/delimited.hpp`
----
backslash_escape = escape(lit_c<'\\'>)
dollar_escape    = escape(lit_c<'$'>)
----

Common escape characters are predefined.

[godbolt,cpp,id=aajf7c]
----
// Match a string consisting of code points that aren't control characters.
// `\"` can be used to add a `"` to the string.
// `\uXXXX` can be used to add the code point with the specified value.
dsl::quoted(dsl::code_point - dsl::ascii::control,
            dsl::backslash_escape
              .lit_c<'"'>()
              .rule(dsl::lit_c<'u'> >> dsl::code_point_id<4>)
----

=== Aggregates

.`lexy/dsl/member.hpp`
----
member<MemPtr> = rule   : Rule
member<MemPtr> = branch : Branch

LEXY_MEM(Name) = rule   : Rule
LEXY_MEM(Name) = branch : Branch
----

The `member` rule together with the `lexy::as_aggregate<T>` callback assigns the values produced by the rule given to it via `=` to the specified member of the aggregate `T`.

[horizontal]
Requires::
  A production that contains a member rule needs to use `lexy::as_aggregate<T>` as sink or callback.
  The rule must produce exactly one value.
Matches::
  Matches and consumes the `rule` given to it via `=`.
Values::
  Produces two values.
  The first value identifiers the targeted member.
  For `member<MemPtr>`, this is the member pointed to by the member pointer.
  For `LEXY_MEM(Name)`, it is the member with the given `Name`.
  The second value is the value produced by the rule.
Errors::
  All errors raised during parsing of the assigned rule.

The `lexy::as_aggregate<T>` callback, collects all member and value pairs.
It then constructs an object of type `T` using value initialization and for each pair assigns the value to the specified member of it.
This works either as callback or a sink.
If a member is specified more than once, the final value is stored at the end.

[godbolt,cpp,id=EMYGx1]
----
// Parses two integers separated by commas.
// The first integer is assigned to a member called `second`,
// the second integer is assigned to a member called `first`.
(LEXY_MEM(second) = dsl::integer<int>(dsl::digits<>))
+ dsl::comma
+ (LEXY_MEM(first) = dsl::integer<int>(dsl::digits<>))
----

=== Context sensitive parsing

All other parse rules don't remember any state and thus can only be used for context free parsing.
The rules described in this section allow the creation of a stack of contextual information.
This can be used to parse context sensitive grammars like XML with matching open and close tags.

See `example/xml.cpp` for an example that uses the context sensitive parsing facilities.

CAUTION: The context stack uses the same mechanism as the values produced by a rule.
If the rules that push to the stack aren't matched by the rules that pop, context values will be passed to the value callback, which isn't going to work.

[discrete]
==== `lexy::dsl::context_push`

.`lexy/dsl/context.hpp`
----
context_push(rule) : Rule
----

The `context_push` rule pushes a context onto the context stack.

[horizontal]
Matches::
  Matches and consumes `rule`.
  A lexeme that contains everything consumed will be pushed to the context stack.
Values::
  All values produced by `rule`.
Errors::
  All errors raised by `rule`.

[discrete]
==== `lexy::dsl::context_drop`

.`lexy/dsl/context.hpp`
----
context_drop : Rule
----

The `context_drop` rule removes the top context from the stack.

[horizontal]
Requires::
  It must be preceded by a `context_push`.
Matches::
  Matches and consumes nothing, but always succeeds.
  The context that was pushed last is removed.
Values::
  None.
Errors::
  n/a (it does not fail)

[discrete]
==== `lexy::dsl::context_top`

.`lexy/dsl/context.hpp`
----
struct context_eq;
struct context_eq_length;

context_top<Eq>(rule) : Rule
context_top<Eq>(rule).error<Tag>() : Rule
----

The `context_top` rule asserts that the lexeme matched by `rule` is equal to the context on top of the stack.
Equality is determined using the `Eq` policy, which defaults to `context_eq`.

Requires::
  `Eq` is either `context_eq` or `context_eq_length`.
Matches::
  Matches and consumes `rule`.
  It then compares the consumed lexeme with the lexeme on top of the context stack using `Eq`.
  If `Eq` is `context_eq`, the lexeme must contain the exact same characters.
  If `Eq` is `context_eq_length`, the lexeme must have the same length.
Values::
  All values produced by `rule`.
Errors::
  All values raised by `rule`.
  If the lexeme did not match the lexeme on top of the context, raises a generic error.
  The tag is either the tag specified by calling `.error()`, or `lexy::context_mismatch` otherwise.

NOTE: The `rule` is usually the same as the rule passed to the matching `context_push`.

NOTE: The `context_top` rule does not remove the context from the stack, use `context_pop` for that.

[discrete]
==== `lexy::dsl::context_pop`

.`lexy/dsl/context.hpp`
----
context_pop<Eq>(rule) : Rule
  = context_top<Eq>(rule) + context_drop

context_pop<Eq>(rule).error<Tag>() : Rule
  = context_top<Eq>(rule).error<Tag>() + context_drop
----

The `context_pop` rule is a convenience rule that is equivalent to `context_top` followed by `context_drop`.
It checks the top of the context stack and then removes it.
`Eq` defaults to `context_eq`.

=== Raw input

The following facilities are meant for parsing input that uses the `lexy::raw_encoding`, that is input consisting of bytes, not text.

[discrete]
==== `lexy::dsl::bom`

.`lexy/dsl/bom.hpp`
----
bom<Encoding, Endianness> : Pattern
----

The `bom` pattern matches the byte-order mark (BOM) for the given encoding and `lexy::encoding_endianness`.

[horizontal]
Requires::
  `Endianness` is `lexy::encoding_endianness::little` or `lexy::encoding_endianness::big`.
Matches::
  If the encoding has a BOM, matches and consumes the BOM written in the given endianness.
Errors::
  A `lexy::expected_char_class` error with the name `BOM.<encoding>-<endianness>` if the BOM was not matched.

[godbolt,cpp,id=xbnEYs]
----
// Matches the UTF-16 big endian BOM (0xFE, 0xFF).
dsl::bom<lexy::utf16_encoding, lexy::encoding_endianness::big>
----

NOTE: There is a UTF-8 BOM, but it is the same regardless of endianness.

NOTE: This rule is only necessary when you have a raw encoding that contains a BOM.
For example, `lexy::read_file()` already handles and deals with BOMs for you by default.

[discrete]
==== `lexy::dsl::encode`

.`lexy/dsl/encode.hpp`
---
encode<Encoding, Endianness>(rule) : Rule
---

The `encode` rule temporarily changes the encoding of the input.
The specified `rule` will be matched using a `Reader` whose encoding is `Encoding` converted from the raw bytes using the specified endianness.
If no `Endianness` is specified, the default is `lexy::encoding_endianness::bom`, and a BOM is matched on the input to determine the endianness.
If no BOM is present, big endian is assumed.

[horizontal]
Requires::
  The input's encoding is a single-byte encoding (usually `lexy::raw_encoding`).
Matches::
  If the endianness is `lexy::encoding_endianness::bom`, matches and consumes an optional BOM to determine endianness.
  Matches and consumes `rule`.
  However, the input of rule are characters according to `Encoding` and `Endianness`, not the single bytes of the actual input.
Values::
  All values produced by the rule.
Errors::
  All errors raised by the rule.
  The error type uses the original reader, not the encoded reader that does the input translation.

[godbolt,cpp,id=Y51r9v]
----
// Matches a UTF-8 code point, followed by an ASCII code point.
dsl::encode<lexy::utf8_encoding>(dsl::code_point)
    + dsl::encode<lexy::ascii_encoding>(dsl::code_point)
----

=== Custom rules

The exact interface for the `Rule`, `Pattern` and `Branch` concepts is currently still experimental.
Refer to the existing rules if you want to add your own.

