<!doctype html><html lang=en-us><head><meta name=generator content="Hugo 0.83.1"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>lexy: C++ parser combinator library</title><style>:root{--white:white;--header-white:rgba(255, 255, 255, .75);--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#020202;--header-white:rgba(2, 2, 2, .75);--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1200px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;margin:0 auto;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a{color:var(--link-color);transition:color ease .3s}a:hover{color:var(--highlight-color)}a:focus{outline:none}br{margin:1em}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home li{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .patreon{text-align:center}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1200px){aside.toc{display:initial;position:sticky;top:1em;float:left;width:300px}aside.toc header{font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.5em}aside.toc a{text-decoration:none}aside.toc~article{padding-left:300px}}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{width:75px;font-weight:700;border-right:1px solid var(--gray-highlight-color);padding:.5em}article .admonitionblock td.content{padding-left:.5em}article details{padding-bottom:1em}article details summary{font-weight:700}article dl dt{font-weight:700}article dl dd{margin-top:-.9em}article dl dd dt{margin-top:.9em}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article :not(td)>div.title{font-style:italic;margin-bottom:-.9em}article code{font-family:Inconsolata,monospace,sans-serif}article pre{overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}article .highlight{}article .highlight .c{color:#998;font-style:italic}article .highlight .k{color:#458;font-weight:700}article .highlight .o{color:red}article .highlight .p{color:red}article .highlight .err{color:red}article .highlight .cm{color:#998;font-style:italic}article .highlight .cp{color:green;font-weight:700}article .highlight .c1{color:#998;font-style:italic}article .highlight .cs{color:#999;font-weight:700;font-style:italic}article .highlight .gd{color:#000;background-color:#fdd}article .highlight .gd .x{color:#000;background-color:#faa}article .highlight .ge{font-style:italic}article .highlight .gr{color:#a00}article .highlight .gh{color:#999}article .highlight .gi{color:#000;background-color:#dfd}article .highlight .gi .x{color:#000;background-color:#afa}article .highlight .go{color:#888}article .highlight .gp{color:#555}article .highlight .gs{font-weight:700}article .highlight .gu{color:#aaa}article .highlight .gt{color:#a00}article .highlight .kc{color:#458;font-weight:700}article .highlight .kd{color:#458;font-weight:700}article .highlight .kp{color:#458;font-weight:700}article .highlight .kr{color:#458;font-weight:700}article .highlight .kt{color:#458;font-weight:700}article .highlight .m{color:#ff8000}article .highlight .s{color:green}article .highlight .ow{font-weight:700}article .highlight .w{color:#bbb}article .highlight .mf{color:#ff8000}article .highlight .mh{color:#ff8000}article .highlight .mi{color:#ff8000}article .highlight .mo{color:#ff8000}article .highlight .sb{color:#d14}article .highlight .sc{color:#d14}article .highlight .sd{color:#d14}article .highlight .s2{color:#d14}article .highlight .se{color:#d14}article .highlight .sh{color:#d14}article .highlight .si{color:#d14}article .highlight .sx{color:#d14}article .highlight .sr{color:#009926}article .highlight .s1{color:#d14}article .highlight .ss{color:#990073}article .highlight .bp{color:#999}article .highlight .vc{color:teal}article .highlight .vg{color:teal}article .highlight .vi{color:teal}article .highlight .il{color:#099}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/>lexy: C++ parser combinator library</a></li></ul><ul id=main><li><a href=/tutorial/>Tutorial</a></li><li><a href=/reference/>Reference</a></li><li><a href=/playground/>Playground</a></li><li><a href=https://github.com/foonathan/lexy>GitHub</a></li></ul></nav><main><article><div id=preamble><div class=sectionbody><div class=paragraph><p><span class=image><a class=image href=https://www.jonathanmueller.dev/project/><img src="https://img.shields.io/endpoint?url=https%3A%2F%2Fwww.jonathanmueller.dev%2Fproject%2Flexy%2Findex.json" alt="Project Status"></a></span>
<span class=image><img src=https://github.com/foonathan/lexy/workflows/Main%20CI/badge.svg alt="Build Status"></span>
<span class=image><a class=image href=https://codecov.io/gh/foonathan/lexy><img src="https://codecov.io/gh/foonathan/lexy/branch/main/graph/badge.svg?token=3K4YNK41S9" alt=codecov></a></span>
<span class=image><a class=image href=https://lexy.foonathan.net/playground><img src=https://img.shields.io/badge/try-online-blue alt=Playground></a></span></p></div><div class=paragraph><p><code>lexy</code> is a parser combinator library for C++17 and onwards.
It allows you to write a parser by specifying it in a convenient C++ DSL,
which gives you all the flexibility and control of a handwritten parser without all the manual work.</p></div><div class=paragraph><p>Documentation: <a href=https://lexy.foonathan.net/>lexy.foonathan.net</a></p></div><div class=listingblock><div class=title>IPv4 address parser: try it on <a href=https://godbolt.org/z/b83Gsr>Compiler Explorer</a></div><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>#include &lt;lexy/dsl.hpp&gt;

namespace dsl = lexy::dsl;

// Parse an IPv4 address into a `std::uint32_t`.
struct ipv4_address
{
    // What is being matched.
    static constexpr auto rule = []{
        // Match a sequence of (decimal) digits and convert it into a std::uint8_t.
        auto octet = dsl::integer&lt;std::uint8_t&gt;(dsl::digits&lt;&gt;);

        // Match four of them separated by periods.
        return dsl::times&lt;4&gt;(octet, dsl::sep(dsl::period)) + dsl::eof;
    }();

    // How the matched output is being stored.
    static constexpr auto value
        = lexy::callback&lt;std::uint32_t&gt;([](lexy::times&lt;4, std::uint8_t&gt; octets) {
              std::uint32_t result = 0;
              for (auto o : octets)
              {
                  result &lt;&lt;= 8;
                  result |= o;
              }
              return result;
          });
};</code></pre></div></div><div class=paragraph><p>See <a href=https://github.com/foonathan/lexy/tree/main/examples>examples/</a> for more examples, such as a fully conforming JSON parser,
a (subset of) XML parser, or an interactive REPL for a bash-like language, among others.
Or jump directly to the <a href=https://lexy.foonathan.net/tutorial/>tutorial</a> to learn how to write your own grammars.</p></div></div></div><div class=sect1><h2 id=_features>Features</h2><div class=sectionbody><div class=dlist><dl><dt class=hdlist1>Describe the parser, not some abstract grammar</dt><dd><p>Unlike parser generators that use some table driven magic for parsing, `lexy’s grammar is just syntax sugar for a hand-written recursive descent parser.
The parsing algorithm does exactly what you’ve instructed it to do.
No more ambiguities or weird shift/reduce errors!</p></dd><dt class=hdlist1>A pure C++ DSL</dt><dd><p>No need to use an external grammar file, embed the DSL directly in your C++ using operator overloading and functions.</p></dd><dt class=hdlist1>No implicit backtracking or lookahead</dt><dd><p>It will only backtrack when you say it should, and only lookahead when and how far you want it.
Don’t worry about rules that have side-effects, they won’t be executed unnecessarily thanks to the user-specified lookahead conditions.</p></dd><dt class=hdlist1>Bring your own data structures</dt><dd><p>The input is parsed into the data structures you’ve provided.
It will not do heap allocations to store output unless you’ve instructed it to do so.
You can even evaluate the input on the fly, without storing anything.</p></dd><dt class=hdlist1>Good error reporting</dt><dd><p>On a parse error, it will invoke a user-defined callback with information about what went wrong and during which production.
Custom error messages can be injected using the special <code>dsl::error</code>, <code>dsl::require</code> and <code>dsl::prevent</code> error.
Write parse rules that detect common mistakes and issue appropriate diagnostics!</p></dd><dt class=hdlist1>Error recovery (experimental)</dt><dd><p>Log an error, recover, and continue parsing!</p></dd><dt class=hdlist1>Unicode support</dt><dd><p>You can parse UTF-8, UTF-16, or UTF-32.
<code>lexy</code> takes care of code point encoding and decoding as necessary, as well as endianness and byte-order marks.
Want to match a string literal containing arbitrary Unicode code points or <code>\u21D4</code> and store the result in a <code>std::string</code>?
You can do so out of the box.</p></dd><dt class=hdlist1>Keyword and identifier parsing</dt><dd><p>Reserve a set of keywords that won’t be matched as regular identifiers. <a href="https://lexy.foonathan.net/playground/?id=7boh7TGss">Try it online</a>.</p></dd><dt class=hdlist1>Fully <code>constexpr</code> parsing</dt><dd><p>You want to parse a string literal at compile-time? You can do so.</p></dd><dt class=hdlist1>Minimal standard library dependencies</dt><dd><p>The core parsing library only depends on the required headers such as <code>&lt;type_traits></code> or <code>&lt;cstddef></code>.
Some input classes required <code>&lt;cstdio></code>.</p></dd><dt class=hdlist1>Header-only core library</dt><dd><p>By necessity, not by choice — it’s <code>constexpr</code> after all.</p></dd></dl></div></div></div><div class=sect1><h2 id=_planned_features>Planned features</h2><div class=sectionbody><div class=paragraph><p>The following features are in various stages of development and will be added before the 1.0.0 release.</p></div><div class=dlist><dl><dt class=hdlist1>Debug facility</dt><dd><p>Figure out why the grammar isn’t working the way you want it to.</p></dd><dt class=hdlist1>Operator parsing</dt><dd><p>Parse operators with different precedences using Pratt parsing.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content><code>lexy</code> is under active development and especially currently undocumented features (such as the internal rule interface) are subject to change.
All breaking changes with migration strategies are documented in the change log and big breaks are announced in advance as an issue.</td></tr></tbody></table></div></div></div><div class=sect1><h2 id=_faq>FAQ</h2><div class=sectionbody><div class=dlist><dl><dt class=hdlist1>Why should I use <code>lexy</code> over XYZ?</dt><dd><p><code>lexy</code> is closest to other PEG parsers.
However, they usually do more implicit backtracking, which can hurt performance and you need to be very careful with rules that have side-effects.
This is not the case for <code>lexy</code>, where backtracking is controlled using branch conditions.
<code>lexy</code> also gives you a lot of control over error reporting and supports error recovery.</p><div class=dlist><dl><dt class=hdlist1><a href=http://boost-spirit.com/home/>Boost.Spirit</a></dt><dd><p>The main difference: it is not a Boost library.
Otherwise, it is just a different implementation with a different flavor.
Use <code>lexy</code> if you like <code>lexy</code> more.</p><div class=paragraph><p>For reference, this is an IPv4 parser implemented in Boost.Spirit: <a href=https://godbolt.org/z/Pv53Y8 class=bare>https://godbolt.org/z/Pv53Y8</a></p></div></dd><dt class=hdlist1><a href=https://github.com/taocpp/PEGTL>PEGTL</a></dt><dd><p>PEGTL is very similar and was a big inspiration.
The biggest difference is that <code>lexy</code> uses an operator based DSL instead of inheriting from templated classes as PEGTL does;
depending on your preference this can be an advantage or disadvantage.</p></dd><dt class=hdlist1>Handwritten Parsers</dt><dd><p>Writing a handwritten parser is more manual work and error prone.
<code>lexy</code> automates that away without having to sacrifice control.
You can use it to quickly prototype a parser and then slowly replace more and more with a handwritten parser over time.</p></dd></dl></div></dd><dt class=hdlist1>How bad are the compilation times?</dt><dd><p>They’re not as bad as you might expect (in debug mode, that is).</p><div class=paragraph><p>Compiling the example JSON parser with any of the lexy specific things removed,
i.e. just the datastructure built using <code>std::variant</code> and <code>std::map</code>, takes about one second on my machine.
The entire parser takes about two seconds if you disable force inline on the parse productions.
With force inline, it takes about five seconds.</p></div><div class=paragraph><p>Compile time benchmarks and optimizations are planned.
Keep in mind, that you can fully isolate <code>lexy</code> in a single translation unit that only needs to be touched when you change the parser.</p></div></dd><dt class=hdlist1>How bad are the C++ error messages if you mess something up?</dt><dd><p>They’re certainly worse than the error message <code>lexy</code> gives you.
The big problem here is that the first line gives you the error, followed by dozens of template instantiations, which end at your <code>lexy::parse</code> call.
Besides providing an external tool to filter those error messages, there is nothing I can do about that.</p></dd><dt class=hdlist1>How fast is it?</dt><dd><p>Benchmarks are available in the <code>benchmarks/</code> directory.
A sample result of the JSON validator benchmark which compares the example JSON parser with various other implementations is available <a href=https://lexy.foonathan.net/benchmark_json/>here</a>.</p></dd><dt class=hdlist1>Why is it called lexy?</dt><dd><p>I previously had a tokenizer library called <code>foonathan/lex</code>.
I’ve tried adding a parser to it, but found that the line between pure tokenization and parsing has become increasingly blurred.
<code>lexy</code> is a re-imagination on of the parser I’ve added to <code>foonathan/lex</code>, and I’ve simply kept a similar name.</p></dd></dl></div></div></div><div class=sect1><h2 id=_building>Building</h2><div class=sectionbody><div class=paragraph><p>The library uses CMake as its build system.
Simply put it somewhere and use <code>add_subdirectory()</code> to make the following targets available</p></div><div class=dlist><dl><dt class=hdlist1><code>foonathan::lexy::core</code></dt><dd><p>This target is required.
It is an <code>INTERFACE</code> target that sets the required include path and C++ standard flags.</p></dd><dt class=hdlist1><code>foonathan::lexy::file</code></dt><dd><p>Link to this library if you want to use the (not header only) <code>lexy::read_file()</code> functionality.</p></dd><dt class=hdlist1><code>foonathan::lexy</code></dt><dd><p>Umbrella target that links to all other targets.</p></dd></dl></div><div class=paragraph><p>Configuration is supported by providing a <code>lexy_user_config.hpp</code> somewhere in the include search path,
or setting the <code>LEXY_USER_CONFIG_HEADER</code> CMake option to a header path.
This header can then override many of the detections in <code>lexy/_detail/config.hpp</code>.
Refer to that header for details.</p></div><div class=paragraph><p>The library is continuously tested on GCC 7 or higher, clang 6 or higher, as well as MSVC and clang-cl.
It requires C++17 support, but works best with C++20.</p></div></div></div></article></main><footer id=page-footer><section class=copyright>&copy; 2020-2021</section><section class=patreon><a target=_blank href=https://jonathanmueller.dev/support-me/>Support me!</a>.</section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a>.</section></footer></body></html>