<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Warming up — the first parser — lexy</title><style>:root{--white:white;--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#202020;--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1250px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px;display:flex;justify-content:center}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a,a svg,button svg{color:var(--link-color);fill:var(--link-color);stroke:var(--link-color);transition:color ease .3s}a:hover,button:hover{color:var(--highlight-color)}a:hover svg,button:hover svg{color:var(--highlight-color);fill:var(--highlight-color);stroke:var(--highlight-color)}a:focus,button:focus{outline:none}br{margin:1em}article{flex:1;min-width:0}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a svg{height:1em}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home .title{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1100px){aside.toc{display:initial;position:sticky;top:0;min-width:200px;max-width:350px;padding-right:1em;align-self:flex-start;hyphens:auto}aside.toc header{margin-top:1em;font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.2em}aside.toc ul li{padding-bottom:.2em}aside.toc a{text-decoration:none}}article form svg,article a svg,article i svg{height:1em;position:relative;top:2px;padding-right:3px}article p svg:not(:first-child){padding-left:.25em}article header{margin-top:1em;margin-bottom:1em}article header nav{display:flex;flex-wrap:wrap}article header nav a{text-decoration:none;padding-right:7px}@media(min-width:700px){article header nav form.search{margin-left:auto}}article header nav form.search input[type=search]{padding:2px;width:250px}article header nav form.search input[type=search]:focus{border-color:var(--highlight-color);outline:solid var(--highlight-color)1px}article header nav form.search button[type=submit]{margin-left:-25px;border:none;background:initial}article .lead p{font-weight:500;font-size:1.1em}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{font-weight:700}article .admonitionblock td.content div:first-child p{margin-top:0}article .admonitionblock td.content div:last-child p{margin-bottom:0}@media(max-width:600px){article .admonitionblock tr{display:block;float:left;padding-left:.5em;padding-right:.5em}article .admonitionblock tr td{display:block}}@media(min-width:600px){article .admonitionblock td.icon{width:75px;text-align:center;border-right:1px solid var(--gray-highlight-color)}article .admonitionblock td.content{padding-left:.5em}}article .exampleblock{margin-top:1em;margin-bottom:1em}article .exampleblock .title{font-style:italic}article a.github-example{text-decoration:none}article a.github-example svg{height:.8em;position:relative;top:2px}article .playground-example .title,article .godbolt-example .title{position:relative}article .playground-example .title a,article .godbolt-example .title a{position:absolute;top:7px;right:7px}article .playground-example .title a svg,article .godbolt-example .title a svg{height:1em}article details{margin-bottom:1em}article details summary{font-style:italic}article ul p,article ol p{margin:.2em}article div ul:not(:first-child),article div ol:not(:first-child){margin-top:0}article dl dt{margin-top:.5em;font-weight:700}article dl dd p,article dl dd div:only-child ul{margin:0;padding:0}article div dl:not(:first-child){margin-top:0}article table.tableblock{background:var(--white);margin:0 auto;border-collapse:collapse}article table.tableblock td,article table.tableblock th{border:1px solid var(--gray-highlight-color);padding:5px;text-align:left}article table.tableblock td p,article table.tableblock th p{margin:0}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article code{font-family:Inconsolata,monospace,sans-serif}article pre{margin-top:0;overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}.highlight .c,.highlight .cm,.highlight .cp,.highlight .c1,.highlight .cs,.ace_editor .c,.ace_editor .cm,.ace_editor .cp,.ace_editor .c1,.ace_editor .cs{color:#998;font-style:italic;font-weight:initial}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kp,.highlight .kr,.highlight .kt,.highlight .ace_storage,.highlight .ace_keyword,.ace_editor .k,.ace_editor .kc,.ace_editor .kd,.ace_editor .kp,.ace_editor .kr,.ace_editor .kt,.ace_editor .ace_storage,.ace_editor .ace_keyword{color:#458;font-style:initial;font-weight:700}.highlight .o,.highlight .p,.highlight .ace_keyword.ace_operator,.highlight .ace_paren,.highlight .ace_punctuation,.ace_editor .o,.ace_editor .p,.ace_editor .ace_keyword.ace_operator,.ace_editor .ace_paren,.ace_editor .ace_punctuation{color:red;font-style:initial;font-weight:initial}.highlight .ace_dsl,.ace_editor .ace_dsl{pointer-events:auto}.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .ace_constant,.ace_editor .m,.ace_editor .mf,.ace_editor .mh,.ace_editor .mi,.ace_editor .mo,.ace_editor .ace_constant{color:#ff8000;font-style:initial;font-weight:initial}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .s3,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss,.highlight .se,.highlight .ace_string,.ace_editor .s,.ace_editor .sb,.ace_editor .sc,.ace_editor .sd,.ace_editor .s2,.ace_editor .s3,.ace_editor .sh,.ace_editor .si,.ace_editor .sx,.ace_editor .sr,.ace_editor .s1,.ace_editor .ss,.ace_editor .se,.ace_editor .ace_string{color:green;font-style:initial;font-weight:initial}.highlight .cp,.highlight .cpf,.ace_editor .cp,.ace_editor .cpf{color:green;font-style:initial;font-weight:700}.highlight .err,.highlight .ace_invalid,.ace_editor .err,.ace_editor .ace_invalid{color:red;font-style:initial;font-weight:initial}.highlight strong,.ace_editor strong{font-weight:initial}.highlight strong:not(:empty)::before,.ace_editor strong:not(:empty)::before{content:"*";color:red}.highlight strong:not(:empty)::after,.ace_editor strong:not(:empty)::after{content:"*";color:red}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/><span class=title>lexy:</span> C++ parsing DSL</a></li></ul><ul id=main><li><a href=/learn/>Learn</a></li><li><a href=/reference/>Reference</a></li><li><a href=/playground/>Playground</a></li><li><a href=/download/>Download</a></li><li><a href=https://github.com/foonathan/lexy title=GitHub><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li></ul></div></nav><main><aside class=toc><header><a href=#>Table of Contents</a></header><nav id=TableOfContents><ul><li><a href=#_1_define_the_grammar>1. Define the grammar</a></li><li><a href=#_2_create_an_input>2. Create an input</a></li><li><a href=#_3_call_a_parse_action>3. Call a parse action</a></li><li><a href=#_putting_it_all_together>Putting it all together</a></li></ul></nav></aside><article><header><h1>Warming up — the first parser</h1><nav><a href="https://github.com/foonathan/lexy/issues/new?title="><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bug" class="svg-inline--fa fa-bug fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M511.988 288.9c-.478 17.43-15.217 31.1-32.653 31.1H424v16c0 21.864-4.882 42.584-13.6 61.145l60.228 60.228c12.496 12.497 12.496 32.758.0 45.255-12.498 12.497-32.759 12.496-45.256.0l-54.736-54.736C345.886 467.965 314.351 480 280 480V236c0-6.627-5.373-12-12-12h-24c-6.627.0-12 5.373-12 12v244c-34.351.0-65.886-12.035-90.636-32.108l-54.736 54.736c-12.498 12.497-32.759 12.496-45.256.0-12.496-12.497-12.496-32.758.0-45.255l60.228-60.228C92.882 378.584 88 357.864 88 336v-16H32.666C15.23 320 .491 306.33.013 288.9-.484 270.816 14.028 256 32 256h56v-58.745l-46.628-46.628c-12.496-12.497-12.496-32.758.0-45.255 12.498-12.497 32.758-12.497 45.256.0L141.255 160h229.489l54.627-54.627c12.498-12.497 32.758-12.497 45.256.0 12.496 12.497 12.496 32.758.0 45.255L424 197.255V256h56c17.972.0 32.484 14.816 31.988 32.9zM257 0c-61.856.0-112 50.144-112 112h224C369 50.144 318.856.0 257 0z"/></svg> Report an issue
</a><a href=https://github.com/foonathan/lexy/edit/main/docs/content/learn/warmup.adoc><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="edit" class="svg-inline--fa fa-edit fa-w-18" role="img" viewBox="0 0 576 512"><path fill="currentcolor" d="M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8.0zm162-22.9-48.8-48.8c-15.2-15.2-39.9-15.2-55.2.0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8.0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2.0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5.0 112v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"/></svg> Edit this page</a></nav></header><div class=paragraph><p>Using lexy takes three steps:</p></div><div class="olist arabic"><ol class=arabic><li><p>Define the grammar.</p></li><li><p>Create an input.</p></li><li><p>Call a parse action.</p></li></ol></div><div class=paragraph><p>Let’s apply it to parse HTML colors such as <code>#FF00FF</code> into the following struct:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>Color</span>
<span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span> <span class=n>r</span><span class=p>,</span> <span class=n>g</span><span class=p>,</span> <span class=n>b</span><span class=p>;</span>
<span class=p>}</span><span class=o>:</span></code></pre></div></div><div class=sect1><h2 id=_1_define_the_grammar>1. Define the grammar</h2><div class=sectionbody><div class=paragraph><p>A <em>grammar</em> consists of <em>productions</em>.
Each production defines a <em>rule</em>, which controls what is being parsed, and produces a <em>value</em>.
In lexy, productions are structs with a <code>static constexpr</code> member called <code>rule</code>.
The rule is defined by the DSL: lexy provides simple rules that can be composed to parse more complex things.
A grammar consists of multiple of those structs; it is recommended to put them all in a separate namespace:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;lexy/dsl.hpp&gt;</span><span class=c1> </span><span class=cp><b class=conum>(1)</b>
</span>
<span class=k>namespace</span>
<span class=p>{</span>
<span class=k>namespace</span> <span class=n>grammar</span> <b class=conum>(2)</b>
<span class=p>{</span>
    <span class=k>namespace</span> <span class=n>dsl</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>dsl</span><span class=p>;</span> <b class=conum>(3)</b>

    <span class=k>struct</span> <span class=nc>color</span> <span class=p>{</span> <span class=err>…</span> <span class=p>};</span> <b class=conum>(4)</b>
<span class=p>}</span>
<span class=p>}</span></code></pre></div></div><div class="colist arabic"><ol><li><p>All DSL objects are defined in <code>lexy/dsl.hpp</code>.</p></li><li><p>We use a designated namespace to define our grammar.
Since the grammar isn’t meant to be visible outside the current translation unit, we also put it in an anonymous namespace.
This can encourage the compiler to do more aggressive inlining during parsing.</p></li><li><p>For convenience, we alias the namespace of the DSL objects.</p></li><li><p>Productions are structs.</p></li></ol></div><div class=paragraph><p>Let’s start simple by parsing a single color channel, that is, two hex digits.
For that, there is the rule <a href=/reference/dsl/digit/#n_digits><code>lexy::dsl::n_digits</code> </a>:
it parses <code>N</code> digits in the specified base.
As such, a production that parses two hex digits looks like so:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>channel</span> <b class=conum>(1)</b>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>n_digits</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hex</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(2)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>We define a new production <code>channel</code>…​</p></li><li><p>…​ that matches 2 hex digits.</p></li></ol></div><div class=paragraph><p>A color then consists of a hash sign followed by three channels.
A hash sign can be parsed by <a href=/reference/dsl/punctuator/#doc><code>lexy::dsl::hash_sign</code> </a> (which is just a convenience alias for the general <a href=/reference/dsl/literal/#lit><code>lexy::dsl::lit</code> </a> rule which parses a fixed string);
the channel can be parsed by <a href=/reference/dsl/production/#p><code>lexy::dsl::p</code> </a>, which parses another production.
If we want to parse two or more rules in sequence we can use <a href=/reference/dsl/sequence/#sequence><code>lexy::dsl::operator+</code> </a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>color</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hash_sign</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel</span><span class=o>&gt;</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel</span><span class=o>&gt;</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel</span><span class=o>&gt;</span><span class=p>;</span>
<span class=p>};</span></code></pre></div></div><div class=paragraph><p>That’s a lot of repetition, so we can use <a href=/reference/dsl/times/#times><code>lexy::dsl::times</code> </a>, which parses another rule <code>N</code> times in sequence.
The grammar as written also allows arbitrary stuff after the last channel, such as <code>#FF00FF Hello World!</code>.
To prevent that, we need to match <a href=/reference/dsl/eof/#eof><code>lexy::dsl::eof</code> </a> after the last channel, which only succeeds if we are at EOF.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>color</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hash_sign</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>eof</span><span class=p>;</span>
<span class=p>};</span></code></pre></div></div><div class=paragraph><p>Putting it together, we have a simple grammar that parses an HTML color.</p></div><div class=exampleblock><div class=title>Example 1. Parse an HTML color</div><div class=content><div class="listingblock playground-example"><div class=title><a href="/playground?example=color&amp;mode=tree" title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>channel</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>n_digits</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hex</span><span class=o>&gt;</span><span class=p>;</span>
<span class=p>};</span>

<span class=k>struct</span> <span class=nc>color</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hash_sign</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>eof</span><span class=p>;</span>
<span class=p>};</span>

<span class=k>using</span> <span class=n>production</span> <span class=o>=</span> <span class=n>color</span><span class=p>;</span></code></pre></div></div></div></div></div></div><div class=sect1><h2 id=_2_create_an_input>2. Create an input</h2><div class=sectionbody><div class=paragraph><p>You can’t just directly parse something; you have to use one of the provided input classes.
They also take care of <a href=/reference/encoding/#doc>encoding</a> if necessary.</p></div><div class=dlist><dl><dt class=hdlist1>Strings (<a href=/reference/input/string_input/#string_input><code>lexy::string_input</code> </a>)</dt></dl></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;lexy/input/string_input.hpp&gt;</span><span class=cp>
</span>
<span class=k>auto</span> <span class=n>literal</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>zstring_input</span><span class=p>(</span><span class=s>&#34;#FF00FF&#34;</span><span class=p>);</span>
<span class=k>auto</span> <span class=n>str</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>string_input</span><span class=p>(</span><span class=n>some_string</span><span class=p>);</span></code></pre></div></div><div class=dlist><dl><dt class=hdlist1>Files (<a href=/reference/input/file/#read_file><code>lexy::read_file</code> </a>)</dt></dl></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;lexy/input/file.hpp&gt;</span><span class=cp>
</span>
<span class=k>auto</span> <span class=n>file</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>read_file</span><span class=o>&lt;</span><span class=n>lexy</span><span class=o>::</span><span class=n>utf8_encoding</span><span class=o>&gt;</span><span class=p>(</span><span class=n>path</span><span class=p>);</span>
<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>file</span><span class=p>)</span> <span class=p>{</span> <span class=err>…</span> <span class=p>}</span>
<span class=k>auto</span> <span class=n>input</span> <span class=o>=</span> <span class=n>file</span><span class=p>.</span><span class=n>buffer</span><span class=p>();</span></code></pre></div></div><div class=dlist><dl><dt class=hdlist1>Command-line arguments (<a href=/reference/input/argv_input/#argv_input><code>lexy::argv_input</code> </a>)</dt></dl></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;lexy/input/argv_input.hpp&gt;</span><span class=cp>
</span>
<span class=k>auto</span> <span class=n>input</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>argv_input</span><span class=p>(</span><span class=n>argc</span><span class=p>,</span> <span class=n>argv</span><span class=p>);</span></code></pre></div></div><div class=dlist><dl><dt class=hdlist1>Iterator ranges (<a href=/reference/input/range_input/#range_input><code>lexy::range_input</code> </a>)</dt></dl></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;lexy/input/range_input.hpp&gt;</span><span class=cp>
</span>
<span class=k>auto</span> <span class=n>input</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>range_input</span><span class=o>&lt;</span><span class=n>lexy</span><span class=o>::</span><span class=n>ascii_encoding</span><span class=o>&gt;</span><span class=p>(</span><span class=n>begin</span><span class=p>,</span> <span class=n>end</span><span class=p>);</span></code></pre></div></div></div></div><div class=sect1><h2 id=_3_call_a_parse_action>3. Call a parse action</h2><div class=sectionbody><div class=paragraph><p>Once you have defined a grammar and an input, you invoke an action that reads the input and processes it according to the grammar.</p></div><div class=paragraph><p>The simplest action is <a href=/reference/action/match/#match><code>lexy::match</code> </a>, which just gives you <code>true</code> if the input matches the grammar and <code>false</code> otherwise:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>auto</span> <span class=n>good</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>zstring_input</span><span class=p>(</span><span class=s>&#34;#FF00FF&#34;</span><span class=p>);</span>
<span class=n>CHECK</span><span class=p>(</span><span class=n>lexy</span><span class=o>::</span><span class=n>match</span><span class=o>&lt;</span><span class=n>grammar</span><span class=o>::</span><span class=n>color</span><span class=o>&gt;</span><span class=p>(</span><span class=n>good</span><span class=p>)</span> <span class=o>==</span> <span class=nb>true</span><span class=p>);</span>

<span class=k>auto</span> <span class=n>bad</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>zstring_input</span><span class=p>(</span><span class=s>&#34;#FFF&#34;</span><span class=p>);</span>
<span class=n>CHECK</span><span class=p>(</span><span class=n>lexy</span><span class=o>::</span><span class=n>match</span><span class=o>&lt;</span><span class=n>grammar</span><span class=o>::</span><span class=n>color</span><span class=o>&gt;</span><span class=p>(</span><span class=n>bad</span><span class=p>)</span> <span class=o>==</span> <span class=nb>false</span><span class=p>);</span></code></pre></div></div><div class=paragraph><p>If you want to figure out <em>why</em> it didn’t match, you can use <a href=/reference/action/validate/#validate><code>lexy::validate</code> </a>.
It takes an additional <a href=/reference/action/validate/#error-callback><code>error callback</code> </a> that is invoked with the error, which you can use to print additional information to the user.
The extension library provides a callback that formats the error message nicely and prints it to stderr:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>auto</span> <span class=n>bad</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>zstring_input</span><span class=p>(</span><span class=s>&#34;#FFF&#34;</span><span class=p>);</span>
<span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>validate</span><span class=o>&lt;</span><span class=n>grammar</span><span class=o>::</span><span class=n>color</span><span class=o>&gt;</span><span class=p>(</span><span class=n>bad</span><span class=p>,</span> <span class=n>lexy_ext</span><span class=o>::</span><span class=n>report_error</span><span class=p>);</span>
<span class=n>CHECK</span><span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>is_error</span><span class=p>());</span></code></pre></div></div><div class=paragraph><p>There are also actions to parse the input into a <a href=/reference/parse_tree/#parse_tree><code>lexy::parse_tree</code> </a> (<a href=/reference/action/parse_as_tree/#parse_as_tree><code>lexy::parse_as_tree</code> </a>) and to trace the parsing algorithm for debugging purposes (<a href=/reference/action/trace/#trace><code>lexy::trace</code> </a>).
Both of those are available to play with in the <a href="/playground?example=color">online playground</a>.</p></div><div class=paragraph><p>What we really want to do though, is parse the input into our <code>Color</code> struct.
For that, we need to use the action <a href=/reference/action/parse/#parse><code>lexy::parse</code> </a>:
it parses the input, reports error to the error callback, and produces a user-defined value.
This values is controlled by adding an additional <code>static constexpr</code> member to each production of the grammar called <code>value</code>.
It specifies a <a href=/reference/callback/#callback><code>callback</code> </a> that is invoked with all values produced during parsing of the rule;
lexy provides common callbacks by including <code>lexy/callback.hpp</code>.</p></div><div class=paragraph><p>So what values are produced by parsing the rules?</p></div><div class=paragraph><p>Well, right now: none.
None of the primitive rules we’ve used produce any values, they just match input.
The exception is <a href=/reference/dsl/production/#p><code>lexy::dsl::p</code> </a> which produces the result of parsing the child production,
but as that doesn’t produce a value currently either, nothing happens.</p></div><div class=paragraph><p>So instead of just blindly matching the digits, we have to convert them into an integer and produce them.
This can be done by wrapping the <a href=/reference/dsl/digit/#n_digits><code>lexy::dsl::n_digits</code> </a> rule into a call to the <a href=/reference/dsl/integer/#integer><code>lexy::dsl::integer</code> </a> rule,
and providing an appropriate callback:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>channel</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>integer</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>n_digits</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hex</span><span class=o>&gt;</span><span class=p>);</span> <b class=conum>(1)</b>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(2)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>We want to convert the matched digits into a <code>std::uint8_t</code>, which is then produced by parsing the rule.</p></li><li><p>The callback uses <a href=/reference/callback/forward/#forward><code>lexy::forward</code> </a>, which just forwards the produced value as the result of parsing the production.</p></li></ol></div><div class=paragraph><p>Now each call to <a href=/reference/dsl/production/#p><code>lexy::dsl::p</code> </a> in the <code>color</code> production will result in a single <code>std::uint8_t</code>, which are then passed to the provided callback:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>color</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hash_sign</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>eof</span><span class=p>;</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>construct</span><span class=o>&lt;</span><span class=n>Color</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(1)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Accept the three integers and construct our <code>Color</code> struct from them using <a href=/reference/callback/object/#construct><code>lexy::construct</code> </a>.</p></li></ol></div></div></div><div class=sect1><h2 id=_putting_it_all_together>Putting it all together</h2><div class=sectionbody><div class=paragraph><p>Combining everything, we have the full example for parsing the HTML color into our struct <code>Color</code>:</p></div><div class=exampleblock><div class=title>Example 2. Parse an HTML color</div><div class=content><div class="listingblock godbolt-example"><div class=title><a href="https://godbolt.org/clientstate/eyJzZXNzaW9ucyI6W3siY29tcGlsZXJzIjpbXSwiZXhlY3V0b3JzIjpbeyJjb21waWxlciI6eyJpZCI6ImNsYW5nX3RydW5rIiwibGlicyI6W3siaWQiOiJsZXh5IiwidmVyc2lvbiI6InRydW5rIn1dLCJvcHRpb25zIjoiLXN0ZD1jKysyMCJ9LCJzdGRpbiI6IiNGRjAwRkYiLCJzdGRpblZpc2libGUiOnRydWV9XSwiaWQiOjEsImxhbmd1YWdlIjoiYysrIiwic291cmNlIjoiI2luY2x1ZGUgXHUwMDNjY3N0ZGlvXHUwMDNlXG4jaW5jbHVkZSBcdTAwM2NsZXh5L2FjdGlvbi9wYXJzZS5ocHBcdTAwM2VcbiNpbmNsdWRlIFx1MDAzY2xleHkvY2FsbGJhY2suaHBwXHUwMDNlXG4jaW5jbHVkZSBcdTAwM2NsZXh5L2RzbC5ocHBcdTAwM2VcbiNpbmNsdWRlIFx1MDAzY2xleHlfZXh0L2NvbXBpbGVyX2V4cGxvcmVyLmhwcFx1MDAzZVxuI2luY2x1ZGUgXHUwMDNjbGV4eV9leHQvcmVwb3J0X2Vycm9yLmhwcFx1MDAzZVxuXG5uYW1lc3BhY2VcbntcbnN0cnVjdCBDb2xvclxue1xuICAgIHN0ZDo6dWludDhfdCByLCBnLCBiO1xufTtcblxubmFtZXNwYWNlIGdyYW1tYXJcbntcbiAgICBuYW1lc3BhY2UgZHNsID0gbGV4eTo6ZHNsO1xuXG4gICAgc3RydWN0IGNoYW5uZWxcbiAgICB7XG4gICAgICAgIHN0YXRpYyBjb25zdGV4cHIgYXV0byBydWxlICA9IGRzbDo6aW50ZWdlclx1MDAzY3N0ZDo6dWludDhfdFx1MDAzZShkc2w6Om5fZGlnaXRzXHUwMDNjMiwgZHNsOjpoZXhcdTAwM2UpO1xuICAgICAgICBzdGF0aWMgY29uc3RleHByIGF1dG8gdmFsdWUgPSBsZXh5Ojpmb3J3YXJkXHUwMDNjc3RkOjp1aW50OF90XHUwMDNlO1xuICAgIH07XG5cbiAgICBzdHJ1Y3QgY29sb3JcbiAgICB7XG4gICAgICAgIHN0YXRpYyBjb25zdGV4cHIgYXV0byBydWxlICA9IGRzbDo6aGFzaF9zaWduICsgZHNsOjp0aW1lc1x1MDAzYzNcdTAwM2UoZHNsOjpwXHUwMDNjY2hhbm5lbFx1MDAzZSk7XG4gICAgICAgIHN0YXRpYyBjb25zdGV4cHIgYXV0byB2YWx1ZSA9IGxleHk6OmNvbnN0cnVjdFx1MDAzY0NvbG9yXHUwMDNlO1xuICAgIH07XG59IC8vIG5hbWVzcGFjZSBncmFtbWFyXG59IC8vIG5hbWVzcGFjZVxuXG5pbnQgbWFpbigpXG57XG4gICAgYXV0byBpbnB1dCA9IGxleHlfZXh0Ojpjb21waWxlcl9leHBsb3Jlcl9pbnB1dCgpOyAvLyBzcGVjaWFsIGlucHV0IGZvciBDb21waWxlckV4cGxvcmVyIGV4YW1wbGVzXG4gICAgYXV0byByZXN1bHQgPSBsZXh5OjpwYXJzZVx1MDAzY2dyYW1tYXI6OmNvbG9yXHUwMDNlKGlucHV0LCBsZXh5X2V4dDo6cmVwb3J0X2Vycm9yKTtcbiAgICBpZiAocmVzdWx0Lmhhc192YWx1ZSgpKVxuICAgIHtcbiAgICAgICAgYXV0byBjb2xvciA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgICBzdGQ6OnByaW50ZihcIiMlMDJ4JTAyeCUwMnhcXG5cIiwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCA%2FIDAgOiAxO1xufSJ9XX0=" , title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;cstdio&gt;</span><span class=cp>
#include</span> <span class=cpf>&lt;lexy/action/parse.hpp&gt;</span><span class=cp>
#include</span> <span class=cpf>&lt;lexy/callback.hpp&gt;</span><span class=cp>
#include</span> <span class=cpf>&lt;lexy/dsl.hpp&gt;</span><span class=cp>
#include</span> <span class=cpf>&lt;lexy_ext/compiler_explorer.hpp&gt;</span><span class=cp>
#include</span> <span class=cpf>&lt;lexy_ext/report_error.hpp&gt;</span><span class=cp>
</span>
<span class=k>namespace</span>
<span class=p>{</span>
<span class=k>struct</span> <span class=nc>Color</span>
<span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span> <span class=n>r</span><span class=p>,</span> <span class=n>g</span><span class=p>,</span> <span class=n>b</span><span class=p>;</span>
<span class=p>};</span>

<span class=k>namespace</span> <span class=n>grammar</span>
<span class=p>{</span>
    <span class=k>namespace</span> <span class=n>dsl</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>dsl</span><span class=p>;</span>

    <span class=k>struct</span> <span class=nc>channel</span>
    <span class=p>{</span>
        <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span>  <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>integer</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>n_digits</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hex</span><span class=o>&gt;</span><span class=p>);</span>
        <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span><span class=o>&gt;</span><span class=p>;</span>
    <span class=p>};</span>

    <span class=k>struct</span> <span class=nc>color</span>
    <span class=p>{</span>
        <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span>  <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hash_sign</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel</span><span class=o>&gt;</span><span class=p>);</span>
        <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>construct</span><span class=o>&lt;</span><span class=n>Color</span><span class=o>&gt;</span><span class=p>;</span>
    <span class=p>};</span>
<span class=p>}</span> <span class=c1>// namespace grammar</span>
<span class=p>}</span> <span class=c1>// namespace</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>auto</span> <span class=n>input</span> <span class=o>=</span> <span class=n>lexy_ext</span><span class=o>::</span><span class=n>compiler_explorer_input</span><span class=p>();</span> <span class=c1>// special input for CompilerExplorer examples</span>
    <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>parse</span><span class=o>&lt;</span><span class=n>grammar</span><span class=o>::</span><span class=n>color</span><span class=o>&gt;</span><span class=p>(</span><span class=n>input</span><span class=p>,</span> <span class=n>lexy_ext</span><span class=o>::</span><span class=n>report_error</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>has_value</span><span class=p>())</span>
    <span class=p>{</span>
        <span class=k>auto</span> <span class=n>color</span> <span class=o>=</span> <span class=n>result</span><span class=p>.</span><span class=n>value</span><span class=p>();</span>
        <span class=n>std</span><span class=o>::</span><span class=n>printf</span><span class=p>(</span><span class=s>&#34;#%02x%02x%02x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>color</span><span class=p>.</span><span class=n>r</span><span class=p>,</span> <span class=n>color</span><span class=p>.</span><span class=n>g</span><span class=p>,</span> <span class=n>color</span><span class=p>.</span><span class=n>b</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>result</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=mi>1</span><span class=p>;</span>
<span class=p>}</span></code></pre></div></div></div></div><div class=paragraph><p>Note how we’re checking whether parsing produced a value with <code>.has_value()</code>, and not whether there were any parse errors <code>.is_error()</code>, <code>operator bool()</code>.
This is because lexy implements error recovery: certain errors can be recovered during parsing.</p></div></div></div></article></main><footer id=page-footer><section class=copyright>&copy; <a target=_blank href=https://github.com/foonathan/lexy/blob/main/LICENSE title=License>2020-2025 Jonathan Müller and lexy contributors</a></section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://fontawesome.com/license>Font Awesome</a>.</section></footer></body></html>