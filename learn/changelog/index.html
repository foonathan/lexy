<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Changelog — lexy</title><style>:root{--white:white;--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#202020;--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1250px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px;display:flex;justify-content:center}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a,a svg,button svg{color:var(--link-color);fill:var(--link-color);stroke:var(--link-color);transition:color ease .3s}a:hover,button:hover{color:var(--highlight-color)}a:hover svg,button:hover svg{color:var(--highlight-color);fill:var(--highlight-color);stroke:var(--highlight-color)}a:focus,button:focus{outline:none}br{margin:1em}article{flex:1;min-width:0}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a svg{height:1em}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home .title{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1100px){aside.toc{display:initial;position:sticky;top:0;min-width:200px;max-width:350px;padding-right:1em;align-self:flex-start;hyphens:auto}aside.toc header{margin-top:1em;font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.2em}aside.toc ul li{padding-bottom:.2em}aside.toc a{text-decoration:none}}article form svg,article a svg,article i svg{height:1em;position:relative;top:2px;padding-right:3px}article p svg:not(:first-child){padding-left:.25em}article header{margin-top:1em;margin-bottom:1em}article header nav{display:flex;flex-wrap:wrap}article header nav a{text-decoration:none;padding-right:7px}@media(min-width:700px){article header nav form.search{margin-left:auto}}article header nav form.search input[type=search]{padding:2px;width:250px}article header nav form.search input[type=search]:focus{border-color:var(--highlight-color);outline:solid var(--highlight-color)1px}article header nav form.search button[type=submit]{margin-left:-25px;border:none;background:initial}article .lead p{font-weight:500;font-size:1.1em}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{font-weight:700}article .admonitionblock td.content div:first-child p{margin-top:0}article .admonitionblock td.content div:last-child p{margin-bottom:0}@media(max-width:600px){article .admonitionblock tr{display:block;float:left;padding-left:.5em;padding-right:.5em}article .admonitionblock tr td{display:block}}@media(min-width:600px){article .admonitionblock td.icon{width:75px;text-align:center;border-right:1px solid var(--gray-highlight-color)}article .admonitionblock td.content{padding-left:.5em}}article .exampleblock{margin-top:1em;margin-bottom:1em}article .exampleblock .title{font-style:italic}article a.github-example{text-decoration:none}article a.github-example svg{height:.8em;position:relative;top:2px}article .playground-example .title,article .godbolt-example .title{position:relative}article .playground-example .title a,article .godbolt-example .title a{position:absolute;top:7px;right:7px}article .playground-example .title a svg,article .godbolt-example .title a svg{height:1em}article details{margin-bottom:1em}article details summary{font-style:italic}article ul p,article ol p{margin:.2em}article div ul:not(:first-child),article div ol:not(:first-child){margin-top:0}article dl dt{margin-top:.5em;font-weight:700}article dl dd p,article dl dd div:only-child ul{margin:0;padding:0}article div dl:not(:first-child){margin-top:0}article table.tableblock{background:var(--white);margin:0 auto;border-collapse:collapse}article table.tableblock td,article table.tableblock th{border:1px solid var(--gray-highlight-color);padding:5px;text-align:left}article table.tableblock td p,article table.tableblock th p{margin:0}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article code{font-family:Inconsolata,monospace,sans-serif}article pre{margin-top:0;overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}.highlight .c,.highlight .cm,.highlight .cp,.highlight .c1,.highlight .cs,.ace_editor .c,.ace_editor .cm,.ace_editor .cp,.ace_editor .c1,.ace_editor .cs{color:#998;font-style:italic;font-weight:initial}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kp,.highlight .kr,.highlight .kt,.highlight .ace_storage,.highlight .ace_keyword,.ace_editor .k,.ace_editor .kc,.ace_editor .kd,.ace_editor .kp,.ace_editor .kr,.ace_editor .kt,.ace_editor .ace_storage,.ace_editor .ace_keyword{color:#458;font-style:initial;font-weight:700}.highlight .o,.highlight .p,.highlight .ace_keyword.ace_operator,.highlight .ace_paren,.highlight .ace_punctuation,.ace_editor .o,.ace_editor .p,.ace_editor .ace_keyword.ace_operator,.ace_editor .ace_paren,.ace_editor .ace_punctuation{color:red;font-style:initial;font-weight:initial}.highlight .ace_dsl,.ace_editor .ace_dsl{pointer-events:auto}.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .ace_constant,.ace_editor .m,.ace_editor .mf,.ace_editor .mh,.ace_editor .mi,.ace_editor .mo,.ace_editor .ace_constant{color:#ff8000;font-style:initial;font-weight:initial}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .s3,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss,.highlight .se,.highlight .ace_string,.ace_editor .s,.ace_editor .sb,.ace_editor .sc,.ace_editor .sd,.ace_editor .s2,.ace_editor .s3,.ace_editor .sh,.ace_editor .si,.ace_editor .sx,.ace_editor .sr,.ace_editor .s1,.ace_editor .ss,.ace_editor .se,.ace_editor .ace_string{color:green;font-style:initial;font-weight:initial}.highlight .cp,.highlight .cpf,.ace_editor .cp,.ace_editor .cpf{color:green;font-style:initial;font-weight:700}.highlight .err,.highlight .ace_invalid,.ace_editor .err,.ace_editor .ace_invalid{color:red;font-style:initial;font-weight:initial}.highlight strong,.ace_editor strong{font-weight:initial}.highlight strong:not(:empty)::before,.ace_editor strong:not(:empty)::before{content:"*";color:red}.highlight strong:not(:empty)::after,.ace_editor strong:not(:empty)::after{content:"*";color:red}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/><span class=title>lexy:</span> C++ parsing DSL</a></li></ul><ul id=main><li><a href=/learn/>Learn</a></li><li><a href=/reference/>Reference</a></li><li><a href=/playground/>Playground</a></li><li><a href=/download/>Download</a></li><li><a href=https://github.com/foonathan/lexy title=GitHub><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li></ul></div></nav><main><article><header><h1>Changelog</h1><nav><a href="https://github.com/foonathan/lexy/issues/new?title="><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bug" class="svg-inline--fa fa-bug fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M511.988 288.9c-.478 17.43-15.217 31.1-32.653 31.1H424v16c0 21.864-4.882 42.584-13.6 61.145l60.228 60.228c12.496 12.497 12.496 32.758.0 45.255-12.498 12.497-32.759 12.496-45.256.0l-54.736-54.736C345.886 467.965 314.351 480 280 480V236c0-6.627-5.373-12-12-12h-24c-6.627.0-12 5.373-12 12v244c-34.351.0-65.886-12.035-90.636-32.108l-54.736 54.736c-12.498 12.497-32.759 12.496-45.256.0-12.496-12.497-12.496-32.758.0-45.255l60.228-60.228C92.882 378.584 88 357.864 88 336v-16H32.666C15.23 320 .491 306.33.013 288.9-.484 270.816 14.028 256 32 256h56v-58.745l-46.628-46.628c-12.496-12.497-12.496-32.758.0-45.255 12.498-12.497 32.758-12.497 45.256.0L141.255 160h229.489l54.627-54.627c12.498-12.497 32.758-12.497 45.256.0 12.496 12.497 12.496 32.758.0 45.255L424 197.255V256h56c17.972.0 32.484 14.816 31.988 32.9zM257 0c-61.856.0-112 50.144-112 112h224C369 50.144 318.856.0 257 0z"/></svg> Report an issue
</a><a href=https://github.com/foonathan/lexy/edit/main/docs/content/learn/changelog.adoc><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="edit" class="svg-inline--fa fa-edit fa-w-18" role="img" viewBox="0 0 576 512"><path fill="currentcolor" d="M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8.0zm162-22.9-48.8-48.8c-15.2-15.2-39.9-15.2-55.2.0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8.0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2.0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5.0 112v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"/></svg> Edit this page</a></nav></header><div class=sect1><h2 id=_upcoming>Upcoming</h2><div class=sectionbody><div class=sect2><h3 id=_potential_breaking_changes>Potential breaking changes</h3><div class=ulist><ul><li><p><code>scanner-common::capture_token</code> was renamed to <code>scanner-common::capture</code>, and old <code>scanner-common::capture</code> removed.
Previously, <code>capture_token</code> was a linker error anyway, but if you’re calling <code>scanner-common::capture</code> it will no longer work for arbitrary rules and instead only like <code>dsl::capture</code>.</p></li><li><p><code>lexy::parse_as_tree</code> will add a position token to production nodes that would otherwise be empty.
That way, no production node will be empty, unless the builder API is used directly.</p></li><li><p>Change <code>lexy::dsl::try_()</code> error recovery behavior:
It will now skip whitespace after the (optional) error recovery rule.</p></li><li><p>Deprecate the <code>lexy::parse_tree::builder::finish()</code> overload that does not take a <code>remaining_input</code>.</p></li><li><p>The typo <code>lexy::code_point::spaing_mark</code> was fixed to <code>spacing_mark</code>.</p></li></ul></div></div><div class=sect2><h3 id=_new_features>New Features</h3><div class=ulist><ul><li><p><strong>Experimental</strong>: Add <code>lexy::parse_tree_input</code> and <code>lexy::dsl::tnode</code>/<code>lexy::dsl::pnode</code> to support multi-pass parsing.</p></li><li><p>Add <code>lexy::dsl::byte.if_</code>/<code>set</code>/<code>range</code>/<code>ascii</code> methods to match specific bytes.</p></li><li><p>Add an overload of <code>fatal_error()</code> on scanners that allows construction of type-erased generic errors (#134).</p></li><li><p>Add <code>lexy::buffer::release()</code> and <code>lexy::buffer::adopt()</code> to deconstruct a buffer into its components and re-assemble it later.</p></li><li><p>Add <code>lexy::parse_tree::node::position()</code> and <code>::covering_lexeme()</code>.</p></li><li><p>Add default argument to <code>lexy::dsl::flag()</code>.</p></li><li><p>Add <code>lexy::callback_with_state</code>.</p></li><li><p>Pass the parse state to the tag of <code>lexy::dsl::op</code> if required (#172) and to <code>lexy::dsl::error</code> (#211).</p></li><li><p>Enable CMake install rule for subdirectory builds (#205).</p></li></ul></div></div><div class=sect2><h3 id=_bug_fixes>Bug fixes</h3><div class=ulist><ul><li><p>Add missing <code>constexpr</code> to container callbacks and <code>lexy::as_string</code>.</p></li><li><p>Fix infinite loop in <code>dsl::delimited</code> when dealing with invalid code points (#173).</p></li><li><p>Fix swallowed errors from case-folding rules (#149).</p></li><li><p>Fix <code>lexy::production_name</code> for productions in an anonymous namespace.</p></li><li><p>Fix bugs in <code>dsl::scan</code> (#133, #135, #142, #154, #209).</p></li><li><p>Fix bug with the position passed to the tag constructor of <code>lexy::dsl::op</code> (#170).</p></li><li><p>Fix bug where <code>lexy_ext::report_error</code> unconditionally wrote to <code>stderr</code>, ignoring the output iterator.</p></li><li><p>Fix bug with missing <code>lexy::error_context::position</code> in <code>lexy::parse_as_tree</code> (#184).</p></li><li><p>Fix <code>static_assert</code> in <code>lexy::parse_tree</code> (#190).</p></li><li><p>Add missing <code>&&</code> in <code>lexy::bind_sink</code> (#221).</p></li><li><p>Workaround compiler bugs and improve documentation.</p></li></ul></div></div></div></div><div class=sect1><h2 id=_release_2022_12_1>Release 2022.12.1</h2><div class=sectionbody><div class=ulist><ul><li><p>Add constructor to <code>lexy::input_location</code>.</p></li><li><p><code>lexy::error_context::production</code> will not be a transparent production.</p></li><li><p>Fix <code>lexy::production_info::operator==</code> when the compiler doesn’t merge string literals.</p></li><li><p>Fix SWAR matching of <code>dsl::ascii::print</code> and <code>dsl::ascii::graph</code>.</p></li><li><p>Fix CMake target installation (#108).</p></li></ul></div></div></div><div class=sect1><h2 id=_release_2022_12_0>Release 2022.12.0</h2><div class=sectionbody><div class=sect2><h3 id=_potential_breaking_changes_2>Potential breaking changes</h3><div class=ulist><ul><li><p>Change <code>lexy::dsl::peek_not()</code> error recovery behavior:
it will now consume the input it matched to recover, which is more useful.</p></li><li><p>Remove <code>Production</code> parameter from <code>lexy::error_context</code>.
It is replaced by a type-erased <code>lexy::production_info</code>.</p></li><li><p><code>lexy::validate</code>, <code>lexy::parse</code>, and <code>lexy::parse_as_tree</code> now type-erase generic error tags prior to invoking the callback.</p></li><li><p>Use type-erased <code>lexy::production_info</code> instead of <code>Production</code> type in <code>lexy::parse_tree</code>.
This is technically a breaking change, as it may affect overload resolution.</p></li></ul></div></div><div class=sect2><h3 id=_new_features_2>New features</h3><div class=ulist><ul><li><p>Update Unicode database to Unicode 15.</p></li><li><p>Use SWAR (SIMD within a register) techniques to optimize token parsing.</p></li><li><p>Add <code>lexy::dsl::subgrammar</code> to split a grammar into multiple translation units.</p></li><li><p>Add <code>lexy::dsl::flags</code> and <code>lexy::dsl::flag</code> to parse enum flags.</p></li><li><p>Add overload of <code>lexy::dsl::position</code> that parses a rule.
This allows using it as branch conditions.</p></li><li><p>Add <code>lexy::dsl::effect</code> to trigger side-effects during parsing.</p></li><li><p>Add <code>lexy::subexpression_production</code> to parse a subexpression.</p></li><li><p>Add <code>lexy::utf8_char_encoding</code>.</p></li><li><p>Add <code>lexy::parse_tree::remaining_input()</code> and populate it by <code>lexy::parse_as_tree</code>.</p></li><li><p>Add <code>lexy::make_buffer_from_input</code> function.</p></li><li><p>Add type-erased version of <code>lexy::error</code>.</p></li><li><p>Support non-<code>const</code> parse state.</p></li></ul></div></div><div class=sect2><h3 id=_bugfixes>Bugfixes</h3><div class=ulist><ul><li><p>Fix bug where <code>lexy::bind</code> callback does not forward rvalue arguments; they got turned into lvalues instead.</p></li><li><p>Fix bug where callback composition was not allowed if the final callback returns <code>void</code>.</p></li><li><p>Fix bug where <code>dsl::quoted(cc.error&lt;foo>)</code> did not use <code>foo</code> as the error.</p></li></ul></div></div></div></div><div class=sect1><h2 id=_release_2022_05_1>Release 2022.05.1</h2><div class=sectionbody><div class=ulist><ul><li><p>Change <code>dsl::scan</code>: it will now be invoked with the previously produced values.</p></li><li><p>Add <code>dsl::parse_as</code> to ensure that a rule always produces a value (e.g. when combined with the <code>dsl::scan</code> change above).</p></li><li><p>Add <code>lexy::lexeme_input</code> to support multi-pass parsing.</p></li><li><p>Turn <code>dsl::terminator(term)(branch)</code> into a branch rule, as opposed to being a plain rule (#74).</p></li><li><p>Add <code>dsl::ignore_trailing_sep()</code> separator.</p></li><li><p>Add <code>lexy::bounded&lt;T, Max></code> for bounded integer parsing (#72).</p></li><li><p>Add <code>dsl::code_unit_id</code> rule.</p></li><li><p>Turn <code>lexy::forward&lt;void></code> into a sink.</p></li><li><p>Support references in <code>lexy::parse_result</code> and <code>lexy::scan_result</code></p></li><li><p>Fix bug that prevented <code>lexy::parse</code> with a root production whose value is <code>void</code>.</p></li><li><p>Fix bug that caused infinite template instantiations for recursive scans.</p></li><li><p>Fix bug that didn’t skip whitespace in <code>lexy::scanner</code> for token productions.</p></li></ul></div></div></div><div class=sect1><h2 id=_release_2022_05_0>Release 2022.05.0</h2><div class=sectionbody><div class=paragraph><p>Initial release.</p></div><hr><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The following changelog items track the historic development; only breaking changes are documented.</td></tr></tbody></table></div></div></div><div class=sect1><h2 id=_2022_04_21>2022-04-21</h2><div class=sectionbody><div class=paragraph><p><code>dsl::lit_cp</code> in a char class now requires a Unicode encoding; use <code>dsl::lit_b</code> to support default/byte encoding.</p></div></div></div><div class=sect1><h2 id=_2022_03_21>2022-03-21</h2><div class=sectionbody><div class=ulist><ul><li><p><strong>BEHAVIOR CHANGE</strong>: <code>lexy::token_production</code> that define a <code>::whitespace</code> member now skip whitespace in the direct rule as well.
Previously, it would only apply the whitespace rule to child productions but not the production itself.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: production rules that define a <code>::whitespace</code> member now skip whitespace before parsing.
This also applies to the root production, so whitespace at the beginning of the input is now skipped automatically.</p></li><li><p><code>dsl::p&lt;Production></code> where <code>Production</code> defines a <code>::whitespace</code> member is now longer a branch rule: as it will now skip whitespace first, it can’t be used as a branch condition.</p></li><li><p>Remove <code>dsl::whitespace</code> (no arguments); it’s now unnecessary as initial whitespace is skipped automatically.</p></li></ul></div></div></div><div class=sect1><h2 id=_2022_03_02>2022-03-02</h2><div class=sectionbody><div class=ulist><ul><li><p><strong>BEHAVIOR CHANGE</strong>: <code>dsl::capture_token()</code> is now <code>dsl::capture()</code>, old <code>dsl::capture()</code> is removed.
If you’re using <code>dsl::capture_token()</code> you need to rename it to <code>dsl::capture()</code> (compile error).
If you’re using <code>dsl::capture()</code> on a non-token rule, you need to use <code>dsl::scan</code> instead and manually produce the value (compile error).
If you’re using <code>dsl::capture()</code> on a token, this will no longer capture trailing whitespace (silent behavior change).
I can’t imagine a situation where capturing trailing whitespace was intended.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: if a non-root production defines a <code>::whitespace</code> member, it will now also apply to all children.
Previously, it would only apply to the production that defined the member, and not it’s children (except if it was a token production).</p></li></ul></div></div></div><div class=sect1><h2 id=_2022_02_09>2022-02-09</h2><div class=sectionbody><div class=ulist><ul><li><p><strong>BEHAVIOR CHANGE</strong>: <code>dsl::newline</code> (and <code>dsl::eol</code> in the newline case) generate a token node with the <code>lexy::literal_token_kind</code>;
<code>lexy::newline_token_kind</code> and <code>lexy::eol_token_kind</code> have been removed.</p></li><li><p><code>dsl::eof</code> and <code>dsl::eol</code> are now branch rules: replace <code>dsl::until(dsl::eol)</code> by <code>dsl::until(dsl::newline).or_eof()</code>.</p></li><li><p>Removed generic <code>dsl::operator/</code> (alternative): use <code>dsl::literal_set()</code> or <code>dsl::operator|</code> instead.</p></li><li><p>Require a char class rule in <code>.limit()</code> of <code>dsl::delimited()</code>: instead of <code>dsl::eol</code> or <code>dsl::newline</code>, use <code>dsl::ascii::newline</code>.</p></li><li><p>Require literal rules in <code>dsl::lookahead()</code>, <code>dsl::find()</code>, and <code>.limit()</code> of error recovery rules.</p></li><li><p>Require literal rules in <code>.reserve()</code> and variants of <code>dsl::identifier</code>.</p></li><li><p><code>dsl::bom</code> now generates a <code>lexy::expected_literal</code> error instead of <code>lexy::expected_char_class</code>.</p></li></ul></div></div></div><div class=sect1><h2 id=_2022_01_30>2022-01-30</h2><div class=sectionbody><div class=ulist><ul><li><p><strong>BEHAVIOR CHANGE</strong>: the introduction of char class rules changes error messages and token kinds in some situations.</p></li><li><p>Renamed <code>dsl::code_point.lit&lt;Cp>()</code> to <code>dsl::lit_cp&lt;Cp></code> and moved to <code>dsl/literal.hpp</code>.</p></li><li><p>Require char classes in <code>operator-</code> for tokens; removed <code>dsl::contains()</code> and <code>dsl::prefix()</code>.</p></li><li><p>Require char classes in <code>dsl::delimited()</code> and <code>dsl::identifier()</code>.</p></li><li><p>Renamed <code>.character_class()</code> of <code>dsl::error</code> to <code>.name()</code>.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_12_08>2021-12-08</h2><div class=sectionbody><div class=paragraph><p><code>dsl::integer</code> now uses <code>lexy::digits_token_kind</code> instead of <code>lexy::error_token_kind</code> during recovery.</p></div></div></div><div class=sect1><h2 id=_2021_12_01>2021-12-01</h2><div class=sectionbody><div class=paragraph><p><code>dsl::bom</code> and <code>dsl::lit_b</code> now require <code>lexy::byte_encoding</code>.</p></div></div></div><div class=sect1><h2 id=_2021_11_30>2021-11-30</h2><div class=sectionbody><div class=paragraph><p>Remove <code>lexy_ext/input_location.hpp</code>: use <code>lexy/input_location.hpp</code> instead, which has a different interface but more functionality.</p></div></div></div><div class=sect1><h2 id=_2021_11_23>2021-11-23</h2><div class=sectionbody><div class=ulist><ul><li><p>Added more pre-defined token kinds: for example, tokens created by <code>LEXY_LIT()</code> now have their own literal token kind.
This breaks code that does not use user-defined token kinds and does matching on <code>lexy::parse_tree</code>.</p></li><li><p><code>dsl::delimited()</code> now merges adjacent characters into a single <code>lexy::lexeme</code> that is passed to the sink.</p></li><li><p><code>lexy::token_production</code> now longer merges adjacent tokens, but <code>dsl::delimited()</code> merges character tokens.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_10_13>2021-10-13</h2><div class=sectionbody><div class=ulist><ul><li><p>Terminator rules are no longer branch rules; this behavior was somewhat confusing.
If you need branch rules, you can manually write the equivalent rules.</p></li><li><p><code>dsl::integer()</code> now requires a token rule. This ensures the correct behavior in combination with whitespace skipping.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: branch parsing an identifier will now backtrack without raising an error if it can match an identifier,
but it is reserved. Previously, this would not backtrack and then raise an error (but trivially recover).
This behavior is consistent with <code>dsl::symbol()</code>.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_10_07>2021-10-07</h2><div class=sectionbody><div class=ulist><ul><li><p>Removed branch functionality of token sequence (again).
It was already removed once as it was unimplementable due to automatic whitespace skipping, but then re-implemented later on.
But as it turns out, it is in fact unimplementable and the current implementation was completely broken.
Instead of <code>tok1 + tok2 >> rule1 | tok1 + tok3 >> rule2</code> use <code>tok1 >> (tok2 >> rule1 | tok3 >> rule2)</code>.</p></li><li><p>Removed <code>dsl::encode()</code>. The rule was completely broken in combination with <code>dsl::capture()</code> and rules built on top like <code>dsl::identifier()</code>.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: error recovery now produces a new error token in the parse tree.
This ensures that the parse tree stays lossless even in the presence of errors.</p></li><li><p><strong>Potential pitfall</strong>: <code>dsl::recover()</code> and <code>dsl::find()</code> now always raise the recovery events.
If you’re using them outside of <code>dsl::try_()</code>, this is not what you want, so don’t do them - they’re not meant for it.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_08_22>2021-08-22</h2><div class=sectionbody><div class=paragraph><p><code>lexy::read_file_result</code> is no longer an input; you need to call <code>.buffer()</code> when passing it to a parse action.</p></div></div></div><div class=sect1><h2 id=_2021_08_17>2021-08-17</h2><div class=sectionbody><div class=paragraph><p>Replaced <code>lexy_ext::dump_parse_tree()</code> by <code>lexy::visualize()</code>.</p></div></div></div><div class=sect1><h2 id=_2021_07_15>2021-07-15</h2><div class=sectionbody><div class=ulist><ul><li><p>Moved <code>lexy/match.hpp</code>, <code>lexy/parse.hpp</code>, and <code>lexy/validate.hpp</code> to <code>lexy/action/match.hpp</code>, <code>lexy/action/parse.hpp</code> and <code>lexy/action/validate.hpp</code>.</p></li><li><p>Moved <code>lexy::parse_as_tree()</code> to new header <code>lexy/action/parse_as_tree.hpp</code>; <code>lexy::parse_tree</code> stayed in <code>lexy/parse_tree.hpp</code>.</p></li><li><p>Renamed <code>lexy::parse_tree::builder::backtrack_production</code> to <code>cancel_production</code>,
and its <code>production_state</code> to <code>marker</code>.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_07_01>2021-07-01</h2><div class=sectionbody><div class=ulist><ul><li><p>Moved callback adapters and composition into new header files, but still implicitly included by <code>callback.hpp</code>.</p></li><li><p>Removed overload of <code>lexy::bind</code> that takes a sink; bind individual items in a separate production instead.</p></li><li><p>Removed unneeded overloads of <code>lexy::as_sink</code> and changed the transcoding behavior:
It will now only use the pointer + size constructor if the character types match and no longer <code>reinterpret_cast</code>.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_06_27>2021-06-27</h2><div class=sectionbody><div class=ulist><ul><li><p>Simplified and minimized interface of the input classes, removing e.g. iterators from them.</p></li><li><p>Moved definition of <code>lexy::code_point</code> from <code>encoding.hpp</code> to new header <code>code_point.hpp</code>.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_06_20>2021-06-20</h2><div class=sectionbody><div class=ulist><ul><li><p>Turned <code>dsl::else_</code> into a tag object that can only be used with <code>operator>></code>, instead of a stand-alone rule.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: <code>dsl::peek[_not]()</code> and <code>dsl::lookahead()</code> are no longer no-ops when used outside a branch condition.
Instead, they will perform lookahead and raise an error if that fails.</p></li><li><p>Removed <code>dsl::require/prevent(rule).error&lt;tag></code>; use <code>dsl::peek[_not](rule).error&lt;tag></code> instead.</p></li><li><p>Improved and simplified interface for <code>dsl::context_flag</code> and <code>dsl::context_counter</code>:
instead of <code>.select()</code>/<code>.compare()</code>, you now use <code>.is_set()</code>/<code>.is()</code> as a branch condition,
and instead of <code>.require()</code>, you now use <code>dsl::must()</code> with <code>.is[_set]()</code>.</p></li><li><p>Removed <code>dsl::context_lexeme</code>; use <code>dsl::context_identifier</code> instead.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_06_18>2021-06-18</h2><div class=sectionbody><div class=ulist><ul><li><p><code>lexy::fold[_inplace]</code> is now longer a callback, only a sink;
use <code>lexy::callback(lexy::fold(…​))</code> to turn it into a callback if needed.</p></li><li><p>Removed <code>dsl::opt_list()</code>; use <code>dsl::opt(dsl::list())</code> instead.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: <code>.opt_list()</code> of <code>dsl::terminator</code>/<code>dsl::brackets</code> now produces <code>lexy::nullopt</code> instead of an empty sink result if the list has no items.
If you’re using pre-defined callbacks like <code>lexy::as_list</code>, <code>lexy::as_collection</code>, or <code>lexy::as_string</code>, it continues to work as expected.
If you’re using <code>sink >> callback</code>, <code>callback</code> now requires one overload that takes <code>lexy::nullopt</code>.</p></li><li><p>Removed <code>.while[_one]()</code> from <code>dsl::terminator</code>/<code>dsl::brackets</code>.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_06_14>2021-06-14</h2><div class=sectionbody><div class=paragraph><p>Choice (<code>operator|</code>) is no longer a branch rule if it would be an unconditional branch rule;
using an unconditional choice as a branch is almost surely a bug.</p></div></div></div><div class=sect1><h2 id=_2021_06_13>2021-06-13</h2><div class=sectionbody><div class=ulist><ul><li><p>Removed <code>dsl::label</code> and <code>dsl::id</code>; use a separate production instead.</p></li><li><p>Removed <code>lexy::sink</code>; instead of <code>lexy::sink&lt;T>(fn)</code> use <code>lexy::fold_inplace&lt;T>({}, fn)</code>.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: <code>dsl::times</code>/<code>dsl::twice</code> no longer produce an array, but instead all values individually.
Use <code>lexy::fold</code> instead of a loop.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_06_12>2021-06-12</h2><div class=sectionbody><div class=ulist><ul><li><p>Removed <code>lexy::null_input</code>.</p></li><li><p>Downgraded <code>lexy/input/shell.hpp</code> to <code>lexy_ext/shell.hpp</code>, with the namespace change to <code>lexy_ext</code>.</p></li><li><p>Removed <code>.capture()</code> from <code>dsl::code_point</code>; use <code>dsl::capture()</code> instead.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: Don’t produce a tag value if no sign was present in <code>dsl::[minus/plus_]sign</code>.
If you use <code>lexy::as_integer</code> as callback, this doesn’t affect you.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: Don’t consume input in <code>dsl::prevent</code>.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: Produce only a single whitespace node in parse tree, instead of the individual token nodes.
Prohibited <code>dsl::p</code>/<code>dsl::recurse</code> inside the whitespace rule.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_05_25>2021-05-25</h2><div class=sectionbody><div class=ulist><ul><li><p>Changed <code>dsl::[plus/minus_]sign</code> to produce <code>lexy::plus/minus_sign</code> instead of <code>+1</code>/<code>-1</code>.
Also changed callback <code>lexy::as_integer</code> to adapt.</p></li><li><p>Removed <code>dsl::parse_state</code> and <code>dsl::parse_state_member</code>; use <code>lexy::bind()</code> with <code>lexy::parse_state</code> instead.</p></li><li><p>Removed <code>dsl::value_*</code> rules; use <code>lexy::bind()</code> or <code>dsl::id</code>/<code>dsl::label</code> instead.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_04_24>2021-04-24</h2><div class=sectionbody><div class=ulist><ul><li><p>The alternative rule <code>/</code> now tries to find the longest match instead of the first one.
If it was well-specified before, this doesn’t change anything.</p></li><li><p>Removed <code>dsl::switch_()</code>; use the new <code>dsl::symbol()</code> instead which is more efficient as well.</p></li><li><p>Removed <code>.lit[_c]()</code> from <code>dsl::escape()</code>; use the new <code>.symbol()</code> instead.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_03_29>2021-03-29</h2><div class=sectionbody><div class=ulist><ul><li><p>Restructure callback header files; an <code>#include &lt;lexy/callback.hpp></code> might be necessary now.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_03_29_2>2021-03-29</h2><div class=sectionbody><div class=ulist><ul><li><p>Support empty token nodes in the parse tree if they don’t have an unknown kind.
In particular, the parse tree will now contain an EOF node at the end.</p></li><li><p>Turn <code>lexy::unknown_token_kind</code> into a value (as opposed to the type it was before).</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_03_26>2021-03-26</h2><div class=sectionbody><div class=paragraph><p>Renamed <code>lexy::raw_encoding</code> to <code>lexy::byte_encoding</code>.</p></div></div></div><div class=sect1><h2 id=_2021_03_23>2021-03-23</h2><div class=sectionbody><div class=ulist><ul><li><p>Changed the return type of <code>lexy::read_file()</code> (and <code>lexy_ext::read_file()</code>) to use a new <code>lexy::read_file_result</code> over <code>lexy::result</code>.</p></li><li><p>Changed the return type of <code>lexy::validate()</code> and <code>lexy::parse_as_tree()</code> to a new <code>lexy::validate_result</code> type.</p></li><li><p>Changed the return type of <code>lexy::parse()</code> to a new <code>lexy::parse_result</code> type.</p></li><li><p>Removed <code>lexy::result</code>.</p></li><li><p>An error callback that returns a non-void type must now be a sink. Use <code>lexy::collect&lt;Container>(error_callback)</code> to create a sink that stores all results in the container. If the error callback returns void, no change is required.</p></li><li><p>Removed <code>dsl::no_trailing_sep()</code>; <code>dsl::sep()</code> now has that behavior as well.</p></li><li><p><code>dsl::require()</code> and <code>dsl::prevent()</code> now recover from errors, which might lead to worse error messages in certain situations.
If they’re used as intended — to create a better error message if something didn’t work out — this shouldn’t happen.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_02_25>2021-02-25</h2><div class=sectionbody><div class=ulist><ul><li><p>Removed empty state from <code>lexy::result</code>. It was only added because it was useful internally, but this is no longer the case.</p></li><li><p>Reverted optimization that merged multiple lexemes in the sink/tokens of <code>dsl::delimited()</code>.
Tokens are instead now automatically merged by the parse tree builder if direct children of a <code>lexy::token_production</code>.</p></li><li><p><code>dsl::switch_(rule).case_()</code> now requires a branch of the form <code>token >> rule</code>, previously it could take an arbitrary branch.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_02_21>2021-02-21</h2><div class=sectionbody><div class=ulist><ul><li><p>Unified error interface:</p><div class=ulist><ul><li><p><code>.error&lt;Tag>()</code> has become <code>.error&lt;Tag></code> (e.g. for tokens, <code>dsl::switch()</code>).</p></li><li><p><code>f&lt;Tag>(…​)</code> has become <code>f(…​).error&lt;Tag></code> (e.g. for <code>dsl::require()</code>).</p></li><li><p><code>ctx.require&lt;Tag>()</code> has become <code>ctx.require().error&lt;Tag></code>.</p></li><li><p><code>dsl::[partial_]combination()</code> now have <code>.missing_error&lt;Tag></code> and <code>.duplicate_error&lt;Tag></code> members.</p></li></ul></div></li><li><p><strong>BEHAVIOR CHANGE</strong>: if <code>dsl::code_point_id</code> overflows, the tag is now <code>lexy::invalid_code_point</code> instead of <code>lexy::integer_overflow</code>.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_02_20>2021-02-20</h2><div class=sectionbody><div class=ulist><ul><li><p>Replaced use of <code>lexy::_detail::string_view</code> by <code>const char*</code> in all user facing functions.
As a consequence, automatic type name now requires GCC > 8.</p></li><li><p>Removed <code>lexy::make_error_location()</code>. It has been replaced by <code>lexy_ext::find_input_location()</code>.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_02_17>2021-02-17</h2><div class=sectionbody><div class=paragraph><p>Renamed <code>lexy::make_buffer</code> to <code>lexy::make_buffer_from_raw</code>.</p></div></div></div><div class=sect1><h2 id=_2021_02_04>2021-02-04</h2><div class=sectionbody><div class=paragraph><p>Removed support for arbitrary rules as content of a <code>dsl::delimited()</code> rule, no only tokens are allowed.
Also removed support for an escape choice in the <code>dsl::delimited()</code> rule, it must be a branch now.</p></div><div class=paragraph><p>As a related change, the sink will now be invoked with a <code>lexy::lexeme</code> that can span multiple occurrences of the content token,
not multiple times (one lexeme per token occurrence) as it was previously.
This means that a <code>dsl::quoted(dsl::code_point)</code> rule will now invoke the sink only once giving it a <code>lexy::lexeme</code> that spans the entire content of the string literal.
Previously it was invoked once per <code>dsl::code_point</code>.</p></div></div></div><div class=sect1><h2 id=_2021_01_11>2021-01-11</h2><div class=sectionbody><div class=paragraph><p>Limited implicit conversion of <code>lexy::nullopt</code> to types that are like <code>std::optional</code> or pointers.
Replaced <code>lexy::dsl::nullopt</code> by <code>lexy::dsl::value_t&lt;T></code> and <code>lexy::dsl::opt(rule)</code> by <code>rule | lexy::dsl::value_t&lt;T></code> to keep the previous behavior of getting a default constructed object of type <code>T</code>.</p></div></div></div><div class=sect1><h2 id=_2021_01_10>2021-01-10</h2><div class=sectionbody><div class=ulist><ul><li><p>Replaced <code>operator[]</code> and <code>dsl::whitespaced()</code> by new <code>dsl::whitespace</code> rule.
Whitespace can now be parsed manually or automatically.</p><div class=paragraph><p>To parse whitespace manually, replace <code>rule[ws]</code> by <code>rule + dsl::whitespace(rule)</code>,
or otherwise insert <code>dsl::whitespace(rule)</code> calls where appropriate.
See <code>examples/email.cpp</code> or <code>examples/xml.cpp</code> for an example of manual whitespace skipping.</p></div><div class=paragraph><p>To parse whitespace automatically, define a <code>static constexpr auto whitespace</code> member in the root production of the grammar.
This rule is then skipped <em>after</em> every token.
To temporarily disable automatic whitespace skipping inside one production, inherit from <code>lexy::token_production</code>.
See <code>examples/tutorial.cpp</code> or <code>examples/json.cpp</code> for an example of automatic whitespace skipping.</p></div></li><li><p>Removed support for choices in while, i.e. <code>dsl::while_(a | b | c)</code>.
This can be replaced by <code>dsl::loop(a | b | c | dsl::break_)</code>.</p></li></ul></div></div></div><div class=sect1><h2 id=_2021_01_09>2021-01-09</h2><div class=sectionbody><div class=ulist><ul><li><p>Removed <code>.check()</code> from <code>dsl::context_flag</code> and <code>.check_eq/lt/gt</code> from <code>dsl::context_counter</code> due to implementation problems.
Use <code>.select()</code> and <code>.compare()</code> instead.</p></li><li><p>A sequence rule using <code>operator+</code> is now longer a branch.
Previously, it was a branch if it consisted of only tokens.
However, this was unimplementable in combination with automatic whitespace skipping.</p><div class=paragraph><p>A branch condition that is a sequence is only required if you have something like <code>prefix + a >> rule_a | prefix + b >> rule_b</code>.
Use <code>prefix + (a >> rule_a | b >> rule_b)</code> instead.</p></div></li></ul></div></div></div><div class=sect1><h2 id=_2021_01_08>2021-01-08</h2><div class=sectionbody><div class=paragraph><p>Removed context sensitive parsing mechanism from <code>context.hpp</code> (<code>dsl::context_push()</code>, <code>_pop()</code> etc.).
Use <code>dsl::context_lexeme</code> instead: <code>.capture()</code> replaces <code>dsl::context_push()</code> and <code>.require()</code> replaces <code>dsl::context_pop()</code>.</p></div></div></div><div class=sect1><h2 id=_2021_01_03>2021-01-03</h2><div class=sectionbody><div class=ulist><ul><li><p>Removed callback from <code>lexy::as_list</code> and <code>lexy::as_collection</code>; they’re now only sink.
<code>lexy::construct</code> can be used in most cases instead.</p></li><li><p>Merged <code>::list</code> and <code>::value</code> callbacks from productions.
There are three cases:</p><div class=ulist><ul><li><p>A production has a <code>value</code> member only: this continues to work as before.</p></li><li><p>A production has a <code>list</code> member only: just rename it to <code>value</code>. It is treated as a sink automatically when required.</p></li><li><p>A production has a <code>list</code> and <code>value</code> member:
add a <code>value</code> member that uses <code>sink >> callback</code>, where <code>sink</code> was the previous <code>list</code> value and <code>callback</code> the previous <code>callback</code>.
This will use <code>sink</code> to construct the list then pass everything to <code>callback</code>.</p></li></ul></div></li><li><p><code>lexy::result</code> now has an empty state. It is only used internally and never exposed to the user.
As a related change, the default constructor has been removed due to unclear semantics.
Use <code>lexy::result(lexy::result_error)</code> to restore its behavior of creating a default constructed error.</p></li></ul></div></div></div><div class=sect1><h2 id=_2020_12_26>2020-12-26</h2><div class=sectionbody><div class=ulist><ul><li><p>Replaced <code>Pattern</code> concept with a new <code>Token</code> and <code>Branch</code> concept (See #10).
A <code>Branch</code> is a rule that can make branching decision (it is required by choices and can be used as branch condition).
A <code>Token</code> is an atomic parse unit; it is also a <code>Branch</code>.</p><div class=paragraph><p>Most patterns (e.g. <code>LEXY_LIT</code>) are now tokens, which doesn’t break anything.
Some patterns are now branches (e.g. <code>dsl::peek()</code>), which breaks in rules that now require tokens (e.g. <code>dsl::until()</code>).
The remaining patterns are now plain rules (e.g. <code>dsl::while_(condition >> then)</code>), which makes them unusable as branch conditions.</p></div><div class=paragraph><p>The patterns that are now branches:</p></div><div class=openblock><div class=content><div class=ulist><ul><li><p><code>dsl::error</code></p></li><li><p><code>dsl::peek()</code> and <code>dsl::peek_not()</code></p></li><li><p><code>condition >> then</code> was a pattern if <code>then</code> is a pattern, now it is always a branch</p></li></ul></div></div></div><div class=paragraph><p>The patterns that are now plain rules:</p></div><div class=openblock><div class=content><div class=ulist><ul><li><p>a sequence using <code>operator+</code> (it is still a token if all arguments are tokens, so it can be used as condition)</p></li><li><p>a choice using <code>operator|</code>, even if all arguments are tokens (use <code>operator/</code> instead which is a token)</p></li><li><p><code>dsl::while_[one]()</code>, even if the argument is a token</p></li><li><p><code>dsl::times()</code></p></li><li><p><code>dsl::if_()</code></p></li></ul></div></div></div><div class=paragraph><p>The following rules previously required only patterns but now require tokens:</p></div><div class=openblock><div class=content><div class=ulist><ul><li><p>a minus using <code>operator-</code> (both arguments)</p></li><li><p><code>dsl::until()</code></p></li><li><p><code>dsl::lookahead()</code></p></li><li><p><code>dsl::escape()</code> (the escape character itself) and its <code>.capture()</code></p></li><li><p>digit separators</p></li><li><p>automatic capturing of <code>dsl::delimited()</code></p></li><li><p><code>lexy::make_error_location()</code></p></li></ul></div></div></div><div class=paragraph><p>If you have a breaking change because you now use a non-token rule where a token was expected, use <code>dsl::token()</code>,
which turns an arbitrary rule into a token (just like <code>dsl::match()</code> turned a rule into a pattern).</p></div></li><li><p>Removed <code>dsl::match()</code>; use <code>dsl::token()</code> instead.
If you previously had <code>dsl::peek(dsl::match(rule)) >> then</code> you can now even use <code>dsl::peek(rule) >> then</code>,
as <code>dsl::peek[_not]()</code> have learned to support arbitrary rules.</p></li><li><p>Removed <code>dsl::try_&lt;Tag>(pattern)</code>.
If <code>pattern</code> is now a token, you can use <code>rule.error&lt;Tag>()</code> instead.
Otherwise, use <code>dsl::token(pattern).error&lt;Tag>()</code>.</p></li><li><p>Removed <code>.capture()</code> on <code>dsl::sep(pattern)</code> and <code>dsl::trailing_sep(pattern)</code>.
You can now use <code>dsl::sep(dsl::capture(pattern))</code>,
as <code>dsl::capture()</code> is now a branch and the separators have learned to support branches.</p></li><li><p>Removed <code>.zero()</code> and <code>.non_zero()</code> from <code>dsl::digit&lt;Base></code>.
Use <code>dsl::zero</code> instead of <code>dsl::digit&lt;Base>.zero()</code>.
Use <code>dsl::digit&lt;Base> - dsl::zero</code> (potentially with a nice error specified using <code>.error()</code>) instead of <code>dsl::digit&lt;Base>.non_zero()</code>.</p></li><li><p>Removed <code>dsl::success</code>, as it is now longer needed internally.
It can be added back if needed.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: As part of the branch changes, <code>dsl::peek()</code>, <code>dsl::peek_not()</code> and <code>dsl::lookahead()</code> are now no-ops if not used as branch condition.
For example, <code>prefix + dsl::peek(rule) + suffix</code> is equivalent to <code>prefix + suffix</code>.
In most cases, this is only a change in the error message as they don’t consume characters.
Use <code>dsl::require()</code> and <code>dsl::prevent()</code> if the lookahead was intended.</p></li><li><p><strong>BEHAVIOR CHANGE</strong>: Errors in whitespace are currently not reported.
For example, if you have <code>/* unterminated C comment int i;</code> and support space and C comments as whitespace,
this would previously raise an error about the unterminated C comment.
Right now, it will try to skip the C comment, fail, and then just be done with whitespace skipping.
The error for the unterminated C comment then manifests as <code>expected 'int', got '/*'</code>.</p><div class=paragraph><p>This behavior is only temporary until a better solution for whitespace is implemented (see #10).</p></div></li></ul></div></div></div><div class=sect1><h2 id=_2020_12_22>2020-12-22</h2><div class=sectionbody><div class=ulist><ul><li><p>Removed <code>dsl::build_list()</code> and <code>dsl::item()</code>.
They were mainly used to implement <code>dsl::list()</code>, and became unnecessary after an internal restructuring.</p></li><li><p>Removed support for choices in lists, i.e. <code>dsl::list(a | b | c)</code>.
This can be added back if needed.</p></li><li><p>Removed <code>dsl::operator!</code> due to implementation problems.
Existing uses of <code>dsl::peek(!rule)</code> can be replaced by <code>dsl::peek_not(rule)</code>;
existing uses of <code>!rule >> do_sth</code> can be replaced using <code>dsl::terminator()</code>.</p></li></ul></div></div></div></article></main><footer id=page-footer><section class=copyright>&copy; <a target=_blank href=https://github.com/foonathan/lexy/blob/main/LICENSE title=License>2020-2025 Jonathan Müller and lexy contributors</a></section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://fontawesome.com/license>Font Awesome</a>.</section></footer></body></html>