<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Walkthrough — parser for custom package format — lexy</title><style>:root{--white:white;--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#202020;--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1250px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px;display:flex;justify-content:center}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a,a svg,button svg{color:var(--link-color);fill:var(--link-color);stroke:var(--link-color);transition:color ease .3s}a:hover,button:hover{color:var(--highlight-color)}a:hover svg,button:hover svg{color:var(--highlight-color);fill:var(--highlight-color);stroke:var(--highlight-color)}a:focus,button:focus{outline:none}br{margin:1em}article{flex:1;min-width:0}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a svg{height:1em}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home .title{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1100px){aside.toc{display:initial;position:sticky;top:0;min-width:200px;max-width:350px;padding-right:1em;align-self:flex-start;hyphens:auto}aside.toc header{margin-top:1em;font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.2em}aside.toc ul li{padding-bottom:.2em}aside.toc a{text-decoration:none}}article form svg,article a svg,article i svg{height:1em;position:relative;top:2px;padding-right:3px}article p svg:not(:first-child){padding-left:.25em}article header{margin-top:1em;margin-bottom:1em}article header nav{display:flex;flex-wrap:wrap}article header nav a{text-decoration:none;padding-right:7px}@media(min-width:700px){article header nav form.search{margin-left:auto}}article header nav form.search input[type=search]{padding:2px;width:250px}article header nav form.search input[type=search]:focus{border-color:var(--highlight-color);outline:solid var(--highlight-color)1px}article header nav form.search button[type=submit]{margin-left:-25px;border:none;background:initial}article .lead p{font-weight:500;font-size:1.1em}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{font-weight:700}article .admonitionblock td.content div:first-child p{margin-top:0}article .admonitionblock td.content div:last-child p{margin-bottom:0}@media(max-width:600px){article .admonitionblock tr{display:block;float:left;padding-left:.5em;padding-right:.5em}article .admonitionblock tr td{display:block}}@media(min-width:600px){article .admonitionblock td.icon{width:75px;text-align:center;border-right:1px solid var(--gray-highlight-color)}article .admonitionblock td.content{padding-left:.5em}}article .exampleblock{margin-top:1em;margin-bottom:1em}article .exampleblock .title{font-style:italic}article a.github-example{text-decoration:none}article a.github-example svg{height:.8em;position:relative;top:2px}article .playground-example .title,article .godbolt-example .title{position:relative}article .playground-example .title a,article .godbolt-example .title a{position:absolute;top:7px;right:7px}article .playground-example .title a svg,article .godbolt-example .title a svg{height:1em}article details{margin-bottom:1em}article details summary{font-style:italic}article ul p,article ol p{margin:.2em}article div ul:not(:first-child),article div ol:not(:first-child){margin-top:0}article dl dt{margin-top:.5em;font-weight:700}article dl dd p,article dl dd div:only-child ul{margin:0;padding:0}article div dl:not(:first-child){margin-top:0}article table.tableblock{background:var(--white);margin:0 auto;border-collapse:collapse}article table.tableblock td,article table.tableblock th{border:1px solid var(--gray-highlight-color);padding:5px;text-align:left}article table.tableblock td p,article table.tableblock th p{margin:0}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article code{font-family:Inconsolata,monospace,sans-serif}article pre{margin-top:0;overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}.highlight .c,.highlight .cm,.highlight .cp,.highlight .c1,.highlight .cs,.ace_editor .c,.ace_editor .cm,.ace_editor .cp,.ace_editor .c1,.ace_editor .cs{color:#998;font-style:italic;font-weight:initial}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kp,.highlight .kr,.highlight .kt,.highlight .ace_storage,.highlight .ace_keyword,.ace_editor .k,.ace_editor .kc,.ace_editor .kd,.ace_editor .kp,.ace_editor .kr,.ace_editor .kt,.ace_editor .ace_storage,.ace_editor .ace_keyword{color:#458;font-style:initial;font-weight:700}.highlight .o,.highlight .p,.highlight .ace_keyword.ace_operator,.highlight .ace_paren,.highlight .ace_punctuation,.ace_editor .o,.ace_editor .p,.ace_editor .ace_keyword.ace_operator,.ace_editor .ace_paren,.ace_editor .ace_punctuation{color:red;font-style:initial;font-weight:initial}.highlight .ace_dsl,.ace_editor .ace_dsl{pointer-events:auto}.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .ace_constant,.ace_editor .m,.ace_editor .mf,.ace_editor .mh,.ace_editor .mi,.ace_editor .mo,.ace_editor .ace_constant{color:#ff8000;font-style:initial;font-weight:initial}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .s3,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss,.highlight .se,.highlight .ace_string,.ace_editor .s,.ace_editor .sb,.ace_editor .sc,.ace_editor .sd,.ace_editor .s2,.ace_editor .s3,.ace_editor .sh,.ace_editor .si,.ace_editor .sx,.ace_editor .sr,.ace_editor .s1,.ace_editor .ss,.ace_editor .se,.ace_editor .ace_string{color:green;font-style:initial;font-weight:initial}.highlight .cp,.highlight .cpf,.ace_editor .cp,.ace_editor .cpf{color:green;font-style:initial;font-weight:700}.highlight .err,.highlight .ace_invalid,.ace_editor .err,.ace_editor .ace_invalid{color:red;font-style:initial;font-weight:initial}.highlight strong,.ace_editor strong{font-weight:initial}.highlight strong:not(:empty)::before,.ace_editor strong:not(:empty)::before{content:"*";color:red}.highlight strong:not(:empty)::after,.ace_editor strong:not(:empty)::after{content:"*";color:red}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/><span class=title>lexy:</span> C++ parsing DSL</a></li></ul><ul id=main><li><a href=/learn/>Learn</a></li><li><a href=/reference/>Reference</a></li><li><a href=/playground/>Playground</a></li><li><a href=/download/>Download</a></li><li><a href=https://github.com/foonathan/lexy title=GitHub><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li></ul></div></nav><main><aside class=toc><header><a href=#>Table of Contents</a></header><nav id=TableOfContents><ul><li><a href=#_parsing_the_package_name>Parsing the package name</a></li><li><a href=#_parsing_the_package_version>Parsing the package version</a></li><li><a href=#_parsing_the_package_author>Parsing the package author</a></li><li><a href=#_putting_it_together>Putting it together</a></li><li><a href=#_polish_arbitrary_ordering_of_fields>Polish: Arbitrary ordering of fields</a></li><li><a href=#_polish_better_error_messages>Polish: Better error messages</a></li><li><a href=#_polish_better_error_recovery>Polish: Better error recovery</a></li></ul></nav></aside><article><header><h1>Walkthrough — parser for custom package format</h1><nav><a href="https://github.com/foonathan/lexy/issues/new?title="><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bug" class="svg-inline--fa fa-bug fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M511.988 288.9c-.478 17.43-15.217 31.1-32.653 31.1H424v16c0 21.864-4.882 42.584-13.6 61.145l60.228 60.228c12.496 12.497 12.496 32.758.0 45.255-12.498 12.497-32.759 12.496-45.256.0l-54.736-54.736C345.886 467.965 314.351 480 280 480V236c0-6.627-5.373-12-12-12h-24c-6.627.0-12 5.373-12 12v244c-34.351.0-65.886-12.035-90.636-32.108l-54.736 54.736c-12.498 12.497-32.759 12.496-45.256.0-12.496-12.497-12.496-32.758.0-45.255l60.228-60.228C92.882 378.584 88 357.864 88 336v-16H32.666C15.23 320 .491 306.33.013 288.9-.484 270.816 14.028 256 32 256h56v-58.745l-46.628-46.628c-12.496-12.497-12.496-32.758.0-45.255 12.498-12.497 32.758-12.497 45.256.0L141.255 160h229.489l54.627-54.627c12.498-12.497 32.758-12.497 45.256.0 12.496 12.497 12.496 32.758.0 45.255L424 197.255V256h56c17.972.0 32.484 14.816 31.988 32.9zM257 0c-61.856.0-112 50.144-112 112h224C369 50.144 318.856.0 257 0z"/></svg> Report an issue
</a><a href=https://github.com/foonathan/lexy/edit/main/docs/content/learn/walkthrough.adoc><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="edit" class="svg-inline--fa fa-edit fa-w-18" role="img" viewBox="0 0 576 512"><path fill="currentcolor" d="M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8.0zm162-22.9-48.8-48.8c-15.2-15.2-39.9-15.2-55.2.0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8.0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2.0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5.0 112v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"/></svg> Edit this page</a></nav></header><div class=paragraph><p>Let’s apply everything to a more complex example.
Our goal is to parse some simple configuration file of a software package.</p></div><div class=paragraph><p>A sample input file can look like this:</p></div><div class=listingblock><div class=title><code>package.config</code></div><div class=content><pre>name    = lexy
version = 0.0.0
authors = [&#34;Jonathan Müller&#34;]</pre></div></div><div class=paragraph><p>And we want to parse it into the following C++ data structure using <code>lexy</code>:</p></div><div class=listingblock><div class=title><code>PackageConfig</code></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>PackageVersion</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>major</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>minor</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>patch</span><span class=p>;</span>
<span class=p>};</span>

<span class=k>struct</span> <span class=nc>PackageConfig</span>
<span class=p>{</span>
    <span class=n>std</span><span class=o>::</span><span class=n>string</span>              <span class=n>name</span><span class=p>;</span>
    <span class=n>PackageVersion</span>           <span class=n>version</span><span class=p>;</span>
    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>authors</span><span class=p>;</span>
<span class=p>};</span></code></pre></div></div><div class=paragraph><p>The full source code can be found at <a class=github-example href=https://github.com/foonathan/lexy/blob/main/examples/config.cpp><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><code>config.cpp</code>
</a>.</p></div><div class=paragraph><p>Following the three steps outlined in the /learn/warmup/[warmup], our program has the following structure:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span>
<b class=conum>(1)</b>
<span class=k>struct</span> <span class=nc>PackageVersion</span> <span class=p>{</span> <span class=err>…</span> <span class=p>};</span>
<span class=k>struct</span> <span class=nc>PackageConfig</span> <span class=p>{</span> <span class=err>…</span> <span class=p>};</span>

<span class=c1>//=== grammar ===//</span>
<span class=cp>#include</span> <span class=cpf>&lt;lexy/callback.hpp&gt;</span><span class=cp>
#include</span> <span class=cpf>&lt;lexy/dsl.hpp&gt;</span><span class=cp>
</span>
<span class=k>namespace</span> <span class=n>grammar</span> <b class=conum>(2)</b>
<span class=p>{</span>
    <span class=k>namespace</span> <span class=n>dsl</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>dsl</span><span class=p>;</span>

    <span class=err>…</span>

    <span class=k>struct</span> <span class=nc>config</span> <span class=p>{</span> <span class=err>…</span> <span class=p>};</span>
<span class=p>}</span>

<span class=c1>//=== parsing ===//</span>
<span class=cp>#include</span> <span class=cpf>&lt;lexy/input/file.hpp&gt;</span><span class=cp>
#include</span> <span class=cpf>&lt;lexy/action/parse.hpp&gt;</span><span class=cp>
#include</span> <span class=cpf>&lt;lexy_ext/report_error.hpp&gt;</span><span class=cp>
</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>auto</span> <span class=n>file</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>read_file</span><span class=o>&lt;</span><span class=n>lexy</span><span class=o>::</span><span class=n>utf8_encoding</span><span class=o>&gt;</span><span class=p>(</span><span class=n>filename</span><span class=p>);</span> <b class=conum>(3)</b>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>file</span><span class=p>)</span>
    <span class=p>{</span> <span class=err>…</span> <span class=p>}</span>

    <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>parse</span><span class=o>&lt;</span><span class=n>grammar</span><span class=o>::</span><span class=n>config</span><span class=o>&gt;</span><span class=p>(</span><span class=n>file</span><span class=p>.</span><span class=n>buffer</span><span class=p>(),</span> <span class=n>lexy_ext</span><span class=o>::</span><span class=n>report_error</span><span class=p>.</span><span class=n>path</span><span class=p>(</span><span class=n>filename</span><span class=p>));</span> <b class=conum>(4)</b>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>result</span><span class=p>)</span> <b class=conum>(5)</b>
    <span class=p>{</span> <span class=err>…</span> <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>has_value</span><span class=p>())</span> <b class=conum>(6)</b>
    <span class=p>{</span>
        <span class=n>PackageConfig</span> <span class=n>config</span> <span class=o>=</span> <span class=n>result</span><span class=p>.</span><span class=n>value</span><span class=p>();</span>
        <span class=err>…</span>
    <span class=p>}</span>
<span class=p>}</span></code></pre></div></div><div class="colist arabic"><ol><li><p>The user code that defines the C++ data structures.
It does not need to know anything about <code>lexy</code>.</p></li><li><p>The grammar. It contains multiple productions, but the entry production is <code>grammar::config</code>.
This is the production we’re parsing.</p></li><li><p>We want to read the config from a file, so we use <a href=/reference/input/file/#read_file><code>lexy::read_file</code> </a>.
We specify that the file uses UTF-8 as the input encoding.
Reading a file can fail, so we need to handle that (not shown here).</p></li><li><p>Then we can parse our entry production using the action <a href=/reference/action/parse/#parse><code>lexy::parse</code> </a>.
We give it the buffer of our file and a callback to invoke on errors.</p></li><li><p>If parsing produced any errors, handle them somehow.</p></li><li><p>If parsing was able to give as a value (i.e. the input was either well-formed or lexy could recover from all errors that happened),
use that value.
If you don’t care about error recovery, you just need the <code>!result</code> check.</p></li></ol></div><div class=sect1><h2 id=_parsing_the_package_name>Parsing the package name</h2><div class=sectionbody><div class=paragraph><p>We will create a separate production for each of the fields (name, version, authors).
Let’s start with the production for the name, as that is the simplest one.</p></div><div class=listingblock><div class=title>Package name</div><div class=content><pre>name = lexy</pre></div></div><div class=paragraph><p>Here, we’re only concerned with the part after the equal sign, so the <code>lexy</code> in the example above.
A package name follows the same rules as a C++ identifier, except that leading underscores are not allowed.
As a regex, a name is described by <code>[a-zA-Z][a-zA-Z_0-9]*</code>, so one alpha character, followed by zero or more alphanumeric characters or underscores.</p></div><div class=paragraph><p>In lexy, we can use the pre-defined <a href=/reference/dsl/char_class/#doc>char class rule</a>s <a href=/reference/dsl/ascii/#class><code>lexy::dsl::ascii::alpha</code> </a> and <a href=/reference/dsl/ascii/#class><code>lexy::dsl::ascii::word</code> </a>.
We can then combine them in <a href=/reference/dsl/sequence/#sequence><code>sequence</code> </a> with a <a href=/reference/dsl/loop/#while_><code>lexy::dsl::while_</code> </a> rule:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>name</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>while_</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>word</span><span class=p>);</span>
<span class=p>};</span></code></pre></div></div><div class=paragraph><p>However, this doesn’t produce a value; we need to wrap everything in the <a href=/reference/dsl/capture/#capture><code>lexy::dsl::capture</code> </a> rule,
which matches something and produces a <a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code> </a> (think string view) over the part of the input that was consumed by it.
But this specific pattern is so common that lexy provides a built-in rule for it <a href=/reference/dsl/identifier/#identifier><code>lexy::dsl::identifier</code> </a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>name</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=k>auto</span> <span class=n>lead_char</span>     <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alpha</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>trailing_char</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>word</span><span class=p>;</span>
        <span class=k>return</span> <span class=n>dsl</span><span class=o>::</span><span class=n>identifier</span><span class=p>(</span><span class=n>lead_char</span><span class=p>,</span> <span class=n>trailing_char</span><span class=p>);</span> <b class=conum>(1)</b>
    <span class=p>}();</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>as_string</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(2)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Match an identifier whose leading char is <code>dsl::ascii::alpha</code> and all trailing chars are <code>dsl::ascii::word</code>.
Everything consumed is captured.</p></li><li><p>Convert the captured lexeme into a <code>std::string</code> using the callback <a href=/reference/callback/string/#as_string><code>lexy::as_string</code> </a>.</p></li></ol></div><div class=paragraph><p>First field done, let’s move on to the next one.</p></div></div></div><div class=sect1><h2 id=_parsing_the_package_version>Parsing the package version</h2><div class=sectionbody><div class=paragraph><p>The next field is the version.</p></div><div class=listingblock><div class=title>Package version</div><div class=content><pre>version = 0.0.0</pre></div></div><div class=paragraph><p>Again, we’re only concerned with the value after the equal sign for now.
It consists of three numbers separated by dots, where a number is a non-empty sequence of digits.</p></div><div class=paragraph><p>We can parse decimal numbers using <a href=/reference/dsl/integer/#integer><code>lexy::dsl::integer</code> </a>, and as we’ve seen <a href=/reference/dsl/times/#times><code>lexy::dsl::times</code> </a> can parse something <code>N</code> times with an optional separator:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>version</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]{</span>
        <span class=k>auto</span> <span class=n>number</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>integer</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>dot</span>    <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>period</span><span class=p>;</span>
        <span class=k>return</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>number</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>sep</span><span class=p>(</span><span class=n>dot</span><span class=p>));</span>
    <span class=p>}();</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>construct</span><span class=o>&lt;</span><span class=n>PackageVersion</span><span class=o>&gt;</span><span class=p>;</span>
<span class=p>};</span></code></pre></div></div><div class=paragraph><p>Let’s also allow the special value <code>unreleased</code> as an alternate spelling for <code>0.0.0</code>.
For that, we need to use a <a href=/reference/dsl/choice/#choice><code>choice</code> </a> between the previous <code>dsl::times</code> rule and <a href=/reference/dsl/literal/#lit><code>LEXY_LIT</code> </a><code>("unreleased")</code>.
As discussed in the /learn/branching/[branching tutorial], we need to use <a href=/reference/dsl/branch/#doc>branch rule</a>s to let lexy know how to make a decision.
Luckily, <code>LEXY_LIT</code> is already a branch rule, so we can turn the number part into one by using <a href=/reference/dsl/branch/#else_><code>lexy::dsl::else_</code> </a>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>version</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]{</span>
        <span class=k>auto</span> <span class=n>number</span>      <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>integer</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>dot</span>         <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>period</span><span class=p>;</span>
        <span class=k>auto</span> <span class=n>dot_version</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>number</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>sep</span><span class=p>(</span><span class=n>dot</span><span class=p>));</span>

        <span class=k>auto</span> <span class=n>unreleased</span> <span class=o>=</span> <span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;unreleased&#34;</span><span class=p>);</span>

        <span class=k>return</span> <span class=n>unreleased</span> <span class=o>|</span> <span class=n>dsl</span><span class=o>::</span><span class=n>else_</span> <span class=o>&gt;&gt;</span> <span class=n>dot_version</span><span class=p>;</span> <b class=conum>(1)</b>
    <span class=p>}();</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>construct</span><span class=o>&lt;</span><span class=n>PackageVersion</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(2)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>We’re trying to match the literal <code>unreleased</code>, if that doesn’t work, we unconditionally parse a dotted version.</p></li><li><p>If we’re matching <code>unreleased</code>, no value is produced.
However, in that case <a href=/reference/callback/object/#construct><code>lexy::construct</code> </a> will value construct a <code>PackageVersion</code>, which produces <code>{0, 0, 0}</code> anyway,
which is actually what we want.
To get a different value, we either need to write our own overloaded callback using <a href=/reference/callback/adapter/#callback><code>lexy::callback</code> </a>,
or by using <a href=/reference/callback/bind/#bind><code>lexy::bind</code> </a>.</p></li></ol></div><div class=paragraph><p>Alternatively, we could have turned <code>dot_version</code> into a branch by adding a condition that checks for a digit using <a href=/reference/dsl/digit/#digit><code>lexy::dsl::digit</code> </a>,
and wrapping it in <a href=/reference/dsl/peek/#peek><code>lexy::dsl::peek</code> </a> to ensure the digit is not consumed.</p></div></div></div><div class=sect1><h2 id=_parsing_the_package_author>Parsing the package author</h2><div class=sectionbody><div class=paragraph><p>Continuing on, we want to parse the author of the package:</p></div><div class=listingblock><div class=title>Package author</div><div class=content><pre>authors = [&#34;Jonathan Müller&#34;]</pre></div></div><div class=paragraph><p>It is a comma-separated list of strings surrounded by square brackets.</p></div><div class=paragraph><p>We could manually build something that parses a string by using <a href=/reference/dsl/loop/#while_><code>lexy::dsl::while_</code> </a> and <a href=/reference/dsl/capture/#capture><code>lexy::dsl::capture</code> </a> again;
we just need to be careful to match string characters that are not quotes.
However, again lexy provides built-in support in the form of <a href=/reference/dsl/delimited/#delimited><code>lexy::dsl::delimited</code> </a>, which parses zero or more occurrences of a char class surrounded by a specified delimiter.
As we want quotation marks, we can use <a href=/reference/dsl/delimited/#delimited-predefined><code>lexy::dsl::quoted</code> </a> directly:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>author</span> <b class=conum>(1)</b>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>quoted</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>code_point</span><span class=p>);</span> <b class=conum>(2)</b>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>as_string</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(3)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>The production that parses a single author.</p></li><li><p>Parse a string literal that contains arbitrary characters using <a href=/reference/dsl/code_point/#code_point><code>lexy::dsl::code_point</code> </a>.</p></li><li><p>Convert it into a <code>std::string</code> using <a href=/reference/callback/string/#as_string><code>lexy::as_string</code> </a>.
Note that the callback is used as a <a href=/reference/callback/#sink><code>sink</code> </a> here:
it will be repeatedly invoked to accumulate each character of the string.</p></li></ol></div><div class=paragraph><p>This works, but we need to make two improvements.
First, we don’t want control characters such as newline in our string.
For that, we can subtract the char class <a href=/reference/dsl/ascii/#class><code>lexy::dsl::ascii::control</code> </a> from <code>dsl::code_point</code>,
or, as that is the default, just use <a href=/reference/dsl/char_class/#complement><code>lexy::dsl::operator- (unary)</code> </a>.
Second, we have no way to embed quotes in the author’s name, as they terminate the string.
This can be solved by adding escape sequences, which <a href=/reference/dsl/delimited/#delimited><code>lexy::dsl::delimited</code> </a> supports out-of-the box:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>author</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=k>auto</span> <span class=n>cp</span>     <span class=o>=</span> <span class=o>-</span><span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>control</span><span class=p>;</span> <b class=conum>(1)</b>
        <span class=k>auto</span> <span class=n>escape</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>backslash_escape</span>                                <b class=conum>(2)</b>
                          <span class=p>.</span><span class=n>rule</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;u&#39;</span><span class=o>&gt;</span> <span class=o>&gt;&gt;</span> <span class=n>dsl</span><span class=o>::</span><span class=n>code_point_id</span><span class=o>&lt;</span><span class=mi>4</span><span class=o>&gt;</span><span class=p>)</span>  <b class=conum>(3)</b>
                          <span class=p>.</span><span class=n>rule</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;U&#39;</span><span class=o>&gt;</span> <span class=o>&gt;&gt;</span> <span class=n>dsl</span><span class=o>::</span><span class=n>code_point_id</span><span class=o>&lt;</span><span class=mi>8</span><span class=o>&gt;</span><span class=p>);</span>

        <span class=k>return</span> <span class=n>dsl</span><span class=o>::</span><span class=n>quoted</span><span class=p>(</span><span class=n>cp</span><span class=p>,</span> <span class=n>escape</span><span class=p>);</span> <b class=conum>(4)</b>
    <span class=p>}();</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>as_string</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=n>lexy</span><span class=o>::</span><span class=n>utf8_encoding</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(5)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Allow anything that is not a control character.</p></li><li><p>We use <code>\</code> as the escape character using <a href=/reference/dsl/delimited/#escape-predefined><code>lexy::dsl::backslash_escape</code> </a>,
which is just an alias for <a href=/reference/dsl/delimited/#escape><code>lexy::dsl::escape</code> </a> using a backslah.</p></li><li><p>These two lines define <code>\uXXXX</code> and <code>\uXXXXXXXX</code> to specify character codes.
<a href=/reference/dsl/integer/#code_point_id><code>lexy::dsl::code_point_id</code> </a> is a convenience alias for <a href=/reference/dsl/integer/#integer><code>lexy::dsl::integer</code> </a>
which parses a code point using <code>N</code> hex digits.</p></li><li><p>The <code>\u</code> and <code>\U</code> rules all produce a <a href=/reference/code_point/#code_point><code>lexy::code_point</code> </a>.
<code>lexy::as_string</code> can only convert it back into a string, if we tell it the encoding we want.
So we add <code>lexy::utf8_encoding</code> as the second optional argument to enable that.</p></li></ol></div><div class=paragraph><p>The traditional escape sequences such as <code>\"</code>, <code>\n</code>, and so on, can be implemented by providing a <a href=/reference/dsl/symbol/#symbol_table><code>lexy::symbol_table</code> </a> that defines a mapping for escape characters to their replacement value.
See <a class=github-example href=https://github.com/foonathan/lexy/blob/main/examples/json.cpp><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><code>json.cpp</code>
</a>for an example.</p></div><div class=paragraph><p>Now we just need to parse a list of authors.
<a href=/reference/dsl/list/#list><code>lexy::dsl::list</code> </a> can be used like that:
it parses the item once and then as often as it matches.
But unlike <a href=/reference/dsl/loop/#while_><code>lexy::dsl::while_</code> </a> it allows the item to produce a value and will collect them all in a <a href=/reference/callback/#sink><code>sink</code> </a> like <a href=/reference/callback/container/#as_list><code>lexy::as_list</code> </a>.
Like <a href=/reference/dsl/times/#times><code>lexy::dsl::times</code> </a>, we can also specify a separator, in which case item does not need to be <a href=/reference/dsl/branch/#doc>branch rule</a> as lexy can make a decision just based on the existence of a separator.</p></div><div class=paragraph><p>However, as the list here is surrounded by square brackets, we can use <code>.list()</code> of <a href=/reference/dsl/brackets/#brackets-predefined><code>lexy::dsl::square_bracketed</code> </a> instead.
It is a special case of the generic <a href=/reference/dsl/brackets/#brackets><code>lexy::dsl::brackets</code> </a>, which in turn is a wrapper over <a href=/reference/dsl/terminator/#terminator><code>lexy::dsl::terminator</code> </a>.
As discussed in the /learn/branching/[tutorial about branching], they allow parsing things without requiring a branch condition.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>author_list</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span>
        <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>square_bracketed</span><span class=p>.</span><span class=n>list</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>author</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>sep</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>comma</span><span class=p>));</span> <b class=conum>(1)</b>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>as_list</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&gt;</span><span class=p>;</span> <b class=conum>(2)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Parse the comma-separated list of authors surrounded by square brackets.</p></li><li><p>Each call to <a href=/reference/dsl/production/#p><code>lexy::dsl::p</code> </a> produces a <code>std::string</code>, the sink <a href=/reference/callback/container/#as_list><code>lexy::as_list</code> </a> collects them all into the specified container.</p></li></ol></div></div></div><div class=sect1><h2 id=_putting_it_together>Putting it together</h2><div class=sectionbody><div class=paragraph><p>Parsing the entire config is now very straightforward:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>config</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]{</span>
        <span class=k>auto</span> <span class=n>make_field</span> <span class=o>=</span> <span class=p>[](</span><span class=k>auto</span> <span class=n>name</span><span class=p>,</span> <span class=k>auto</span> <span class=n>rule</span><span class=p>)</span> <span class=p>{</span>              <b class=conum>(1)</b>
            <span class=k>return</span> <span class=n>name</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;=&#39;</span><span class=o>&gt;</span> <span class=o>+</span> <span class=n>rule</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>newline</span><span class=p>;</span>  <b class=conum>(2)</b>
        <span class=p>};</span>

        <span class=k>auto</span> <span class=n>name_field</span>    <span class=o>=</span> <span class=n>make_field</span><span class=p>(</span><span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;name&#34;</span><span class=p>),</span> <span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>name</span><span class=o>&gt;</span><span class=p>);</span> <b class=conum>(3)</b>
        <span class=k>auto</span> <span class=n>version_field</span> <span class=o>=</span> <span class=n>make_field</span><span class=p>(</span><span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;version&#34;</span><span class=p>),</span> <span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>version</span><span class=o>&gt;</span><span class=p>);</span>
        <span class=k>auto</span> <span class=n>authors_field</span>
            <span class=o>=</span> <span class=n>make_field</span><span class=p>(</span><span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;authors&#34;</span><span class=p>),</span> <span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>author_list</span><span class=o>&gt;</span><span class=p>);</span>

        <span class=k>return</span> <span class=n>name_field</span> <span class=o>+</span> <span class=n>version_field</span> <span class=o>+</span> <span class=n>authors_field</span><span class=p>;</span> <b class=conum>(4)</b>
    <span class=p>}();</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>construct</span><span class=o>&lt;</span><span class=n>PackageConfig</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(5)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>We define a little helper function that builds a rule that parses a field given its name and value.</p></li><li><p>Each field consists of the name, an equal sign, the value rule, and a newline matched by the <a href=/reference/dsl/newline/#newline><code>lexy::dsl::newline</code> </a> token.</p></li><li><p>Define each field using the productions we’ve built above.</p></li><li><p>Match them all in order.</p></li><li><p>Construct the package config from the resulting <code>std::string</code>, <code>PackageVersion</code> and <code>std::vector&lt;std::string></code>.</p></li></ol></div><div class=paragraph><p>This works!</p></div><div class=paragraph><p>We can now almost parse the sample input I’ve given above:</p></div><div class=listingblock><div class=title><code>package.config</code></div><div class=content><pre>name=lexy
version=0.0.0
authors=[&#34;Jonathan Müller&#34;]</pre></div></div><div class=paragraph><p>We don’t support whitespace between the elements.
We want to support ASCII blank characters (space and tab) surrounding the equal sign and the brackets and comma of the author list.
This can be done either manually or automatically.</p></div><div class=paragraph><p>To parse whitespace manually, we can use <a href=/reference/dsl/whitespace/#whitespace><code>lexy::dsl::whitespace</code> </a>.
It behaves like <a href=/reference/dsl/loop/#while_><code>lexy::dsl::while_</code> </a> and parses a specified rule zero or more times, but treats the matched content as whitespace.
We then need to insert it everywhere we want to skip whitespace:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>constexpr</span> <span class=k>auto</span> <span class=n>ws</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>whitespace</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>blank</span><span class=p>).</span> <b class=conum>(1)</b>

<span class=k>struct</span> <span class=nc>config</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]{</span>
        <span class=k>auto</span> <span class=n>make_field</span> <span class=o>=</span> <span class=p>[](</span><span class=k>auto</span> <span class=n>name</span><span class=p>,</span> <span class=k>auto</span> <span class=n>rule</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=n>name</span> <span class=o>+</span> <span class=n>ws</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;=&#39;</span><span class=o>&gt;</span> <span class=o>+</span> <span class=n>ws</span> <span class=o>+</span> <span class=n>rule</span> <span class=o>+</span> <span class=n>ws</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>newline</span><span class=p>;</span> <b class=conum>(2)</b>
        <span class=p>};</span>

        <span class=err>…</span>
    <span class=p>}();</span>
<span class=p>};</span>

<span class=err>…</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Define the whitespace globally. <a href=/reference/dsl/ascii/#class><code>lexy::dsl::ascii::blank</code> </a> is a char class that matches space or tab.</p></li><li><p>Insert it everywhere we want to allow whitespace.</p></li></ol></div><div class=paragraph><p>However, this is a lot of work.
In this particular case, it is easier to use <a href=/reference/dsl/whitespace/#doc>automatic whitespace skipping </a>.
This is done by adding a <code>static constexpr</code> member called <code>whitespace</code> to the <strong>root</strong> production (and only the root production):</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>config</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>whitespace</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>blank</span><span class=p>;</span> <b class=conum>(1)</b>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span> <span class=err>…</span> <span class=p>}</span> <span class=p>();</span> <b class=conum>(2)</b>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>construct</span><span class=o>&lt;</span><span class=n>PackageConfig</span><span class=o>&gt;</span><span class=p>;</span>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Define what whitespace is for our grammar.</p></li><li><p>Nothing needs to change in any of the rules here!</p></li></ol></div><div class=paragraph><p>That is all! Now lexy will automatically skip whitespace after every <a href=/reference/dsl/token/#doc>token rule</a> in the grammar.</p></div><div class=paragraph><p>However, that can be a bit much.
For example, it will now skip whitespace after each component of the version number, so something like <code>version = 0 . 0 . 0</code> is fine.
There are to ways to prevent that.
The first is to use <a href=/reference/dsl/whitespace/#no_whitespace><code>lexy::dsl::no_whitespace</code> </a> which parses a rule but disables whitespace skipping.
This is used internally by <a href=/reference/dsl/identifier/#identifier><code>lexy::dsl::identifier</code> </a> and <a href=/reference/dsl/delimited/#delimited><code>lexy::dsl::delimited</code> </a>, so those cases are fine.
The second is to have the <code>version</code> production inherit <a href=/reference/grammar/#token_production><code>lexy::token_production</code> </a>.
This instructs lexy to treat the entire production as a token for the purposes of whitespace skipping:
it will not skip whitespace while parsing the production and all child productions, but instead only once when it’s done:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>version</span> <span class=o>:</span> <span class=n>lexy</span><span class=o>::</span><span class=n>token_production</span> <b class=conum>(1)</b>
<span class=p>{</span>
    <span class=err>…</span>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Disable automatic whitespace skipping inside the <code>version</code>.</p></li></ol></div><div class=paragraph><p>Now we can parse the input shown in the beginning!</p></div></div></div><div class=sect1><h2 id=_polish_arbitrary_ordering_of_fields>Polish: Arbitrary ordering of fields</h2><div class=sectionbody><div class=paragraph><p>To make usability nicer, let’s support arbitrary ordering of the fields in our config file.
This can be done using <a href=/reference/dsl/combination/#combination><code>lexy::dsl::combination</code> </a>, which parses each rule specified once, but in arbitrary order.
The values produced during parsing are not passed to a callback, as that will require <code>N!</code> overloads, but instead it uses a sink.
That’s a problem though: how can we know which value should be assigned to which field?</p></div><div class=paragraph><p>The solution is to use the <a href=/reference/callback/aggregate/#as_aggregate><code>lexy::as_aggregate</code> </a> callback together with <a href=/reference/dsl/member/#member><code>LEXY_MEM</code> </a>.
Using <code>LEXY_MEM(name) = rule</code> in the DSL assigns the value of <code>rule</code> to the member <code>name</code>,
<code>lexy::as_aggregate&lt;T></code> then constructs <code>T</code> by collecting the values of all members:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>config</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>whitespace</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>blank</span><span class=p>;</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=k>auto</span> <span class=n>make_field</span> <span class=o>=</span> <span class=p>[](</span><span class=k>auto</span> <span class=n>name</span><span class=p>,</span> <span class=k>auto</span> <span class=n>rule</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=n>name</span> <span class=o>&gt;&gt;</span> <span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;=&#39;</span><span class=o>&gt;</span> <span class=o>+</span> <span class=n>rule</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>newline</span><span class=p>;</span> <b class=conum>(1)</b>
        <span class=p>};</span>

        <span class=k>auto</span> <span class=n>name_field</span>    <span class=o>=</span> <span class=n>make_field</span><span class=p>(</span><span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;name&#34;</span><span class=p>),</span> <span class=n>LEXY_MEM</span><span class=p>(</span><span class=n>name</span><span class=p>)</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>name</span><span class=o>&gt;</span><span class=p>);</span> <b class=conum>(2)</b>
        <span class=k>auto</span> <span class=n>version_field</span>
            <span class=o>=</span> <span class=n>make_field</span><span class=p>(</span><span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;version&#34;</span><span class=p>),</span> <span class=n>LEXY_MEM</span><span class=p>(</span><span class=n>version</span><span class=p>)</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>version</span><span class=o>&gt;</span><span class=p>);</span>
        <span class=k>auto</span> <span class=n>authors_field</span>
            <span class=o>=</span> <span class=n>make_field</span><span class=p>(</span><span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;authors&#34;</span><span class=p>),</span> <span class=n>LEXY_MEM</span><span class=p>(</span><span class=n>authors</span><span class=p>)</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>author_list</span><span class=o>&gt;</span><span class=p>);</span>

        <span class=k>return</span> <span class=n>dsl</span><span class=o>::</span><span class=n>combination</span><span class=p>(</span><span class=n>name_field</span><span class=p>,</span> <span class=n>version_field</span><span class=p>,</span> <span class=n>authors_field</span><span class=p>)</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>eof</span><span class=p>;</span> <b class=conum>(3)</b>
    <span class=p>}();</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span> <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>as_aggregate</span><span class=o>&lt;</span><span class=n>PackageConfig</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(4)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p><a href=/reference/dsl/combination/#combination><code>lexy::dsl::combination</code> </a> requires a <a href=/reference/dsl/branch/#doc>branch rule</a> to know which rule to parse.
Luckily, we can use the name of the field for that.</p></li><li><p>Each rule now contains the assignment to the appropriate member using <a href=/reference/dsl/member/#member><code>LEXY_MEM</code> </a>.</p></li><li><p>Instead of a sequence, we now have <code>dsl::combination()</code>.
We also added <a href=/reference/dsl/eof/#eof><code>lexy::dsl::eof</code> </a> to ensure that there are no trailing fields at the end.</p></li><li><p>We use <a href=/reference/callback/aggregate/#as_aggregate><code>lexy::as_aggregate</code> </a> as our sink.</p></li></ol></div><div class=paragraph><p>This will match each field exactly once, but in any order.</p></div></div></div><div class=sect1><h2 id=_polish_better_error_messages>Polish: Better error messages</h2><div class=sectionbody><div class=paragraph><p>Out of the box, lexy already gives pretty good error messages.
The <a href=/reference/action/validate/#error-callback><code>error callback</code> </a> passed to <a href=/reference/action/parse/#parse><code>lexy::parse</code> </a> is invoked with some context information like the current production stored in <a href=/reference/error/#error_context><code>lexy::error_context</code> </a> as well the actual <a href=/reference/error/#error><code>lexy::error</code> </a>.
Using <code>lexy_ext::report_error</code>, they are then nicely formatted:</p></div><div class=listingblock><div class=title>Name that starts with an underscore.</div><div class=content><pre>error: while parsing name
     |
 1: 8| name = _lexy
     |        ^ expected &#39;ASCII.alpha&#39; character</pre></div></div><div class=listingblock><div class=title>Missing version number</div><div class=content><pre>error: while parsing version
     |
 2:11| version = 0.0
     |           ~~~^ expected &#39;.&#39;</pre></div></div><div class=listingblock><div class=title>Author name not quoted.</div><div class=content><pre>error: while parsing author_list
     |
 3:12| authors = [Jonathan Müller]
     |            ^ expected &#39;&#34;&#39;</pre></div></div><div class=sect2><h3 id=_more_specific_error_messages>More specific error messages</h3><div class=paragraph><p>However, some of the generic errors are a bit confusing for end users.
For example, if we have control characters in a string we just get a cryptic "expected complement char" error message,
as that’s the error given by <code>-char</code>.
We can change the error of a <a href=/reference/dsl/token/#doc>token rule</a> using its <a href=/reference/dsl/token/#error><code>.error</code> </a> member:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>author</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>invalid_character</span> <b class=conum>(1)</b>
    <span class=p>{</span>
        <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;invalid string character&#34;</span><span class=p>;</span> <b class=conum>(2)</b>
    <span class=p>};</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=k>auto</span> <span class=n>cp</span> <span class=o>=</span> <span class=p>(</span><span class=o>-</span><span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>control</span><span class=p>).</span><span class=n>error</span><span class=o>&lt;</span><span class=n>invalid_character</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(3)</b>

        <span class=err>…</span>
    <span class=p>}();</span>

    <span class=err>…</span>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>The tag that will be associated with the error.</p></li><li><p>We override the default message (which would be <code>author::invalid_character</code>) to the more friendly <code>invalid string character</code>.</p></li><li><p>We specify that on token failure, we want an error with the given tag.</p></li></ol></div><div class=paragraph><p>Likewise, if we specify the same field twice we get the generic "combination duplicate" error message.
Additionally, if we add an unknown field we get the generic "exhausted choice" error.
Both issues can be improved by specifying custom tags in our <a href=/reference/dsl/combination/#combination><code>lexy::dsl::combination</code> </a> call.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>config</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>unknown_field</span> <b class=conum>(1)</b>
    <span class=p>{</span>
        <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;unknown config field&#34;</span><span class=p>;</span> <b class=conum>(2)</b>
    <span class=p>};</span>
    <span class=k>struct</span> <span class=nc>duplicate_field</span> <b class=conum>(1)</b>
    <span class=p>{</span>
        <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;duplicate config field&#34;</span><span class=p>;</span> <b class=conum>(2)</b>
    <span class=p>};</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=err>…</span>

        <span class=k>auto</span> <span class=n>combination</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>combination</span><span class=p>(</span><span class=n>name_field</span><span class=p>,</span> <span class=n>version_field</span><span class=p>,</span> <span class=n>authors_field</span><span class=p>)</span>
                               <span class=p>.</span><span class=n>missing_error</span><span class=o>&lt;</span><span class=n>unknown_field</span><span class=o>&gt;</span><span class=p>.</span><span class=n>duplicate_error</span><span class=o>&lt;</span><span class=n>duplicate_field</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(3)</b>
        <span class=k>return</span> <span class=n>combination</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>eof</span><span class=p>;</span>
    <span class=p>}();</span>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Define the tags.</p></li><li><p>Override the default message, which is the type name.</p></li><li><p>Specify the error on failure.
The missing error is the one triggered when no field condition matched, the duplicate one if we had a field twice.</p></li></ol></div><div class=paragraph><p>Now an invalid string character is reported as <code>invalid string character</code> and a duplicated config field as <code>duplicate config field</code>:</p></div><div class=listingblock><div class=title>Missing closing string delimiter</div><div class=content><pre>error: while parsing author
     |
 3:28| authors = [&#34;Jonathan Müller]
     |              ~~~~~~~~~~~~~~~^ invalid string character</pre></div></div><div class=listingblock><div class=title>Duplicate config field error</div><div class=content><pre>error: while parsing config
     |
 1: 1| name = lexy
     | ^ beginning here
     |
 3: 1| version = 0.0.0
     | ^^^^^^^^^^^^^^^ duplicate config field</pre></div></div></div><div class=sect2><h3 id=_expecting_common_mistakes>Expecting common mistakes</h3><div class=paragraph><p>The package name must not contain hyphens as in <code>my-package</code>.
If a user attempts to use such a name, <a href=/reference/dsl/identifier/#identifier><code>lexy::dsl::identifier</code> </a> stops parsing at the first hyphen, and the error is about an expected newline.
We can improve that by requiring that there is whitespace following the identifier.
If that is not the case, the identifier contains invalid characters.</p></div><div class=paragraph><p>For that, we can use <a href=/reference/dsl/peek/#peek><code>lexy::dsl::peek</code> </a>, which checks whether a rule would match at the current position, without consuming anything.
It also has a <code>.error</code> member that can be used to specify a custom tag:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>name</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>invalid_character</span> <b class=conum>(1)</b>
    <span class=p>{</span>
        <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;invalid name character&#34;</span><span class=p>;</span> <b class=conum>(2)</b>
    <span class=p>};</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=err>…</span>

        <span class=k>return</span> <span class=n>dsl</span><span class=o>::</span><span class=n>identifier</span><span class=p>(</span><span class=n>lead_char</span><span class=p>,</span> <span class=n>trailing_char</span><span class=p>)</span>
               <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>peek</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>space</span><span class=p>).</span><span class=n>error</span><span class=o>&lt;</span><span class=n>invalid_character</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(3)</b>
    <span class=p>}();</span>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Define a tag.</p></li><li><p>Give it a custom message.</p></li><li><p>Issue the error unless the name is followed by the required space character (either trailing whitespace or the newline).</p></li></ol></div><div class=paragraph><p>Now the error message tells exactly what is going on:</p></div><div class=listingblock><div class=title>Invalid name character error</div><div class=content><pre>error: while parsing name
     |
 1:10| name = my-package
     |        ~~^ invalid name character</pre></div></div><div class=paragraph><p>Likewise, we can use <a href=/reference/dsl/peek/#peek_not><code>lexy::dsl::peek_not</code> </a>, which fails if a rule would match, if we were to specify a build string in our version:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>version</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>forbidden_build_string</span> <b class=conum>(1)</b>
    <span class=p>{</span>
        <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>name</span> <span class=o>=</span> <span class=s>&#34;build string not supported&#34;</span><span class=p>;</span> <b class=conum>(2)</b>
    <span class=p>};</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=err>…</span>

        <span class=k>auto</span> <span class=n>dot_version</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>number</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>sep</span><span class=p>(</span><span class=n>dot</span><span class=p>))</span>
                           <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>peek_not</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;-&#39;</span><span class=o>&gt;</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>while_</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>ascii</span><span class=o>::</span><span class=n>alnum</span><span class=p>))</span>
                                 <span class=p>.</span><span class=n>error</span><span class=o>&lt;</span><span class=n>forbidden_build_string</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(3)</b>

        <span class=err>…</span>
    <span class=p>}();</span>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Define a tag.</p></li><li><p>Give it a custom message.</p></li><li><p>Raise the error when we encounter a build string.
We then consume it and recover.</p></li></ol></div><div class=listingblock><div class=title>Forbidden build string</div><div class=content><pre>error: while parsing version
     |
 2:16| version = 0.0.0-alpha
     |           ~~~~~^^^^^^ build string not supported</pre></div></div></div></div></div><div class=sect1><h2 id=_polish_better_error_recovery>Polish: Better error recovery</h2><div class=sectionbody><div class=paragraph><p>lexy also provides error recovery out of the box.
For example, if we’re missing a comma in our author list <code>["author 1" "author 2"]</code>, lexy will correctly report an error yet recovers and produces a list containing the two authors.
This is possible since we’re using <a href=/reference/dsl/brackets/#brackets><code>lexy::dsl::brackets</code> </a>, so it knows when the list is supposed to end.</p></div><div class=paragraph><p>Yet there are more cases where we can recover, we just need to teach lexy about it.
This can be done using <a href=/reference/dsl/recover/#try_><code>lexy::dsl::try_</code> </a>.
This rule parses a rule and on failure, attempts to recover by parsing an optional recovery rule.
Parsing can then continue.</p></div><div class=paragraph><p>For example, consider the rule that parses a config field:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>auto</span> <span class=n>make_field</span> <span class=o>=</span> <span class=p>[](</span><span class=k>auto</span> <span class=n>name</span><span class=p>,</span> <span class=k>auto</span> <span class=n>rule</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>name</span> <span class=o>&gt;&gt;</span> <span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;=&#39;</span><span class=o>&gt;</span> <span class=o>+</span> <span class=n>rule</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>newline</span><span class=p>;</span>
<span class=p>};</span></code></pre></div></div><div class=paragraph><p>Note that the <code>=</code> sign between the name and the value is not required to be able to parse it; something like <code>version 1.0.0</code> is not ambiguous.
So instead of specifying <code>dsl::lit_c&lt;'='></code>, we can use <code>dsl::try_(dsl::lit_c&lt;'='>)</code>:
this tries to parse an <code>=</code> sign and issues an error if there isn’t one, but then it just continues as if nothing happens.
So <code>version 1.0.0</code> will lead to an error message complaining about the missing <code>=</code>, but still give you the appropriate config object.
Note that this is unlike <a href=/reference/dsl/if/#if_><code>lexy::dsl::if_</code> </a><code>(dsl::lit_c&lt;'='>)</code> which would not raise an error if there is no <code>=</code>, as there the <code>=</code> is optional.</p></div><div class=paragraph><p>Also consider the case of <code>name = my-package</code> again.
We’re correctly getting an error about the invalid character in the package name.
But as a failure on <a href=/reference/dsl/peek/#peek><code>lexy::dsl::peek</code> </a> doesn’t affect subsequent rules (it wouldn’t have consumed anything anyway),
parsing continues and tries to parse <a href=/reference/dsl/newline/#newline><code>lexy::dsl::newline</code> </a>, which then fails.
A recovery strategy would be to discard anything until you’ve reached the end of line:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>auto</span> <span class=n>make_field</span> <span class=o>=</span> <span class=p>[](</span><span class=k>auto</span> <span class=n>name</span><span class=p>,</span> <span class=k>auto</span> <span class=n>rule</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>auto</span> <span class=n>end</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>try_</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>newline</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>until</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>newline</span><span class=p>));</span> <b class=conum>(1)</b>
    <span class=k>return</span> <span class=n>name</span> <span class=o>&gt;&gt;</span> <span class=n>dsl</span><span class=o>::</span><span class=n>try_</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;=&#39;</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>+</span> <span class=n>rule</span> <span class=o>+</span> <span class=n>end</span><span class=p>;</span>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>If we don’t have a newline immediately, we discard everything until we have consumed one to recover.
When parsing continues, we’re at the next line.</p></li></ol></div><div class=paragraph><p>Now parsing <code>name = my-package</code> will complain about the <code>-</code> in the name, a missing newline, but then recovers to produce a package called <code>my</code>.</p></div><div class=paragraph><p>Another place were we can use recovery is a missing version number like <code>version = 1.0</code>.
For that, we wrap every number and period in <code>dsl::try_</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>version</span> <span class=o>:</span> <span class=n>lexy</span><span class=o>::</span><span class=n>token_production</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=k>auto</span> <span class=n>number</span>      <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>try_</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>integer</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>nullopt</span><span class=p>);</span> <b class=conum>(1)</b>
        <span class=k>auto</span> <span class=n>dot</span>         <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>try_</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>period</span><span class=p>);</span> <b class=conum>(2)</b>
        <span class=k>auto</span> <span class=n>dot_version</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>number</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>sep</span><span class=p>(</span><span class=n>dot</span><span class=p>))</span>
                           <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>peek_not</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;-&#39;</span><span class=o>&gt;</span><span class=p>).</span><span class=n>error</span><span class=o>&lt;</span><span class=n>forbidden_build_string</span><span class=o>&gt;</span><span class=p>;</span>

        <span class=err>…</span>
    <span class=p>}();</span>

    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>value</span>
        <span class=o>=</span> <span class=n>lexy</span><span class=o>::</span><span class=n>bind</span><span class=p>(</span><span class=n>lexy</span><span class=o>::</span><span class=n>construct</span><span class=o>&lt;</span><span class=n>PackageVersion</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>lexy</span><span class=o>::</span><span class=n>_1</span> <span class=n>or</span> <span class=mi>0</span><span class=p>,</span> <span class=n>lexy</span><span class=o>::</span><span class=n>_2</span> <span class=n>or</span> <span class=mi>0</span><span class=p>,</span> <span class=n>lexy</span><span class=o>::</span><span class=n>_3</span> <span class=n>or</span> <span class=mi>0</span><span class=p>);</span> <b class=conum>(3)</b>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>If we don’t have an integer, we recover by parsing <a href=/reference/dsl/option/#nullopt><code>lexy::dsl::nullopt</code> </a> which just produces the tag value <a href=/reference/dsl/option/#nullopt><code>lexy::nullopt</code> </a>.</p></li><li><p>If we don’t have a dot, we do nothing.</p></li><li><p>As we now recover from input like <code>1.0</code> by producing the values <code>1, 0, lexy::nullopt{}</code>, we need to ensure we’re still producing a correct <code>PackageVersion</code>.
For that we use the <a href=/reference/callback/bind/#bind><code>lexy::bind</code> </a> callback, and specify that if any arguments are <code>lexy::nullopt</code>, we want <code>0</code> instead.</p></li></ol></div><div class=paragraph><p>Now we recover from version strings like <code>1.0</code> or <code>1..0</code>, where missing fields are treated as zeroes.</p></div></div></div></article></main><footer id=page-footer><section class=copyright>&copy; <a target=_blank href=https://github.com/foonathan/lexy/blob/main/LICENSE title=License>2020-2025 Jonathan Müller and lexy contributors</a></section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://fontawesome.com/license>Font Awesome</a>.</section></footer></body></html>