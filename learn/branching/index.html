<!doctype html><html lang=en-US><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Branching, backtracking and making decisions — lexy is not declarative — lexy</title><style>:root{--white:white;--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#202020;--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1250px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px;display:flex;justify-content:center}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a,a svg,button svg{color:var(--link-color);fill:var(--link-color);stroke:var(--link-color);transition:color ease .3s}a:hover,button:hover{color:var(--highlight-color)}a:hover svg,button:hover svg{color:var(--highlight-color);fill:var(--highlight-color);stroke:var(--highlight-color)}a:focus,button:focus{outline:none}br{margin:1em}article{flex:1;min-width:0}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a svg{height:1em}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home .title{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1100px){aside.toc{display:initial;position:sticky;top:0;min-width:200px;max-width:350px;padding-right:1em;align-self:flex-start;hyphens:auto}aside.toc header{margin-top:1em;font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.2em}aside.toc ul li{padding-bottom:.2em}aside.toc a{text-decoration:none}}article form svg,article a svg,article i svg{height:1em;position:relative;top:2px;padding-right:3px}article p svg:not(:first-child){padding-left:.25em}article header{margin-top:1em;margin-bottom:1em}article header nav{display:flex;flex-wrap:wrap}article header nav a{text-decoration:none;padding-right:7px}@media(min-width:700px){article header nav form.search{margin-left:auto}}article header nav form.search input[type=search]{padding:2px;width:250px}article header nav form.search input[type=search]:focus{border-color:var(--highlight-color);outline:solid var(--highlight-color)1px}article header nav form.search button[type=submit]{margin-left:-25px;border:none;background:initial}article .lead p{font-weight:500;font-size:1.1em}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{font-weight:700}article .admonitionblock td.content div:first-child p{margin-top:0}article .admonitionblock td.content div:last-child p{margin-bottom:0}@media(max-width:600px){article .admonitionblock tr{display:block;float:left;padding-left:.5em;padding-right:.5em}article .admonitionblock tr td{display:block}}@media(min-width:600px){article .admonitionblock td.icon{width:75px;text-align:center;border-right:1px solid var(--gray-highlight-color)}article .admonitionblock td.content{padding-left:.5em}}article .exampleblock{margin-top:1em;margin-bottom:1em}article .exampleblock .title{font-style:italic}article a.github-example{text-decoration:none}article a.github-example svg{height:.8em;position:relative;top:2px}article .playground-example .title,article .godbolt-example .title{position:relative}article .playground-example .title a,article .godbolt-example .title a{position:absolute;top:7px;right:7px}article .playground-example .title a svg,article .godbolt-example .title a svg{height:1em}article details{margin-bottom:1em}article details summary{font-style:italic}article ul p,article ol p{margin:.2em}article div ul:not(:first-child),article div ol:not(:first-child){margin-top:0}article dl dt{margin-top:.5em;font-weight:700}article dl dd p,article dl dd div:only-child ul{margin:0;padding:0}article div dl:not(:first-child){margin-top:0}article table.tableblock{background:var(--white);margin:0 auto;border-collapse:collapse}article table.tableblock td,article table.tableblock th{border:1px solid var(--gray-highlight-color);padding:5px;text-align:left}article table.tableblock td p,article table.tableblock th p{margin:0}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article code{font-family:Inconsolata,monospace,sans-serif}article pre{margin-top:0;overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}.highlight .c,.highlight .cm,.highlight .cp,.highlight .c1,.highlight .cs,.ace_editor .c,.ace_editor .cm,.ace_editor .cp,.ace_editor .c1,.ace_editor .cs{color:#998;font-style:italic;font-weight:initial}.highlight .k,.highlight .kc,.highlight .kd,.highlight .kp,.highlight .kr,.highlight .kt,.highlight .ace_storage,.highlight .ace_keyword,.ace_editor .k,.ace_editor .kc,.ace_editor .kd,.ace_editor .kp,.ace_editor .kr,.ace_editor .kt,.ace_editor .ace_storage,.ace_editor .ace_keyword{color:#458;font-style:initial;font-weight:700}.highlight .o,.highlight .p,.highlight .ace_keyword.ace_operator,.highlight .ace_paren,.highlight .ace_punctuation,.ace_editor .o,.ace_editor .p,.ace_editor .ace_keyword.ace_operator,.ace_editor .ace_paren,.ace_editor .ace_punctuation{color:red;font-style:initial;font-weight:initial}.highlight .ace_dsl,.ace_editor .ace_dsl{pointer-events:auto}.highlight .m,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .ace_constant,.ace_editor .m,.ace_editor .mf,.ace_editor .mh,.ace_editor .mi,.ace_editor .mo,.ace_editor .ace_constant{color:#ff8000;font-style:initial;font-weight:initial}.highlight .s,.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .s3,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss,.highlight .se,.highlight .ace_string,.ace_editor .s,.ace_editor .sb,.ace_editor .sc,.ace_editor .sd,.ace_editor .s2,.ace_editor .s3,.ace_editor .sh,.ace_editor .si,.ace_editor .sx,.ace_editor .sr,.ace_editor .s1,.ace_editor .ss,.ace_editor .se,.ace_editor .ace_string{color:green;font-style:initial;font-weight:initial}.highlight .cp,.highlight .cpf,.ace_editor .cp,.ace_editor .cpf{color:green;font-style:initial;font-weight:700}.highlight .err,.highlight .ace_invalid,.ace_editor .err,.ace_editor .ace_invalid{color:red;font-style:initial;font-weight:initial}.highlight strong,.ace_editor strong{font-weight:initial}.highlight strong:not(:empty)::before,.ace_editor strong:not(:empty)::before{content:"*";color:red}.highlight strong:not(:empty)::after,.ace_editor strong:not(:empty)::after{content:"*";color:red}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/><span class=title>lexy:</span> C++ parsing DSL</a></li></ul><ul id=main><li><a href=/learn/>Learn</a></li><li><a href=/reference/>Reference</a></li><li><a href=/playground/>Playground</a></li><li><a href=/download/>Download</a></li><li><a href=https://github.com/foonathan/lexy title=GitHub><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li></ul></div></nav><main><aside class=toc><header><a href=#>Table of Contents</a></header><nav id=TableOfContents><ul><li><a href=#_lexy_is_not_declarative>lexy is not declarative</a></li><li><a href=#_decisions_are_made_using_branches>Decisions are made using branches</a></li><li><a href=#_convenience_rules_to_get_automatic_branch_conditions>Convenience rules to get automatic branch conditions</a></li></ul></nav></aside><article><header><h1>Branching, backtracking and making decisions — lexy is not declarative</h1><nav><a href="https://github.com/foonathan/lexy/issues/new?title="><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bug" class="svg-inline--fa fa-bug fa-w-16" role="img" viewBox="0 0 512 512"><path fill="currentcolor" d="M511.988 288.9c-.478 17.43-15.217 31.1-32.653 31.1H424v16c0 21.864-4.882 42.584-13.6 61.145l60.228 60.228c12.496 12.497 12.496 32.758.0 45.255-12.498 12.497-32.759 12.496-45.256.0l-54.736-54.736C345.886 467.965 314.351 480 280 480V236c0-6.627-5.373-12-12-12h-24c-6.627.0-12 5.373-12 12v244c-34.351.0-65.886-12.035-90.636-32.108l-54.736 54.736c-12.498 12.497-32.759 12.496-45.256.0-12.496-12.497-12.496-32.758.0-45.255l60.228-60.228C92.882 378.584 88 357.864 88 336v-16H32.666C15.23 320 .491 306.33.013 288.9-.484 270.816 14.028 256 32 256h56v-58.745l-46.628-46.628c-12.496-12.497-12.496-32.758.0-45.255 12.498-12.497 32.758-12.497 45.256.0L141.255 160h229.489l54.627-54.627c12.498-12.497 32.758-12.497 45.256.0 12.496 12.497 12.496 32.758.0 45.255L424 197.255V256h56c17.972.0 32.484 14.816 31.988 32.9zM257 0c-61.856.0-112 50.144-112 112h224C369 50.144 318.856.0 257 0z"/></svg> Report an issue
</a><a href=https://github.com/foonathan/lexy/edit/main/docs/content/learn/branching.adoc><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="edit" class="svg-inline--fa fa-edit fa-w-18" role="img" viewBox="0 0 576 512"><path fill="currentcolor" d="M402.6 83.2l90.2 90.2c3.8 3.8 3.8 10 0 13.8L274.4 405.6l-92.8 10.3c-12.4 1.4-22.9-9.1-21.5-21.5l10.3-92.8L388.8 83.2c3.8-3.8 10-3.8 13.8.0zm162-22.9-48.8-48.8c-15.2-15.2-39.9-15.2-55.2.0l-35.4 35.4c-3.8 3.8-3.8 10 0 13.8l90.2 90.2c3.8 3.8 10 3.8 13.8.0l35.4-35.4c15.2-15.3 15.2-40 0-55.2zM384 346.2V448H64V128h229.8c3.2.0 6.2-1.3 8.5-3.5l40-40c7.6-7.6 2.2-20.5-8.5-20.5H48C21.5 64 0 85.5.0 112v352c0 26.5 21.5 48 48 48h352c26.5.0 48-21.5 48-48V306.2c0-10.7-12.9-16-20.5-8.5l-40 40c-2.2 2.3-3.5 5.3-3.5 8.5z"/></svg> Edit this page</a></nav></header><div class=paragraph><p>While lexy’s DSL can look similar to formal grammars such as EBNF or regex, it is not actually comparable.
Traditional grammars describe <em>what</em> valid input looks like, lexy’s DSL describes <em>how</em> input is parsed.
That way, you have full control over all backtracking that happens during parsing.</p></div><div class=sect1><h2 id=_lexy_is_not_declarative>lexy is not declarative</h2><div class=sectionbody><div class=paragraph><p>To illustrate the difference, consider the regex <code>a|ab</code>, which matches <code>a</code> or <code>ab</code>.
Writing the same rule in lexy using the <a href=/reference/dsl/literal/#lit><code>LEXY_LIT</code> </a> primitive rule and the <a href=/reference/dsl/choice/#choice><code>choice</code> </a> combinator, results in this:</p></div><div class=exampleblock><div class=title>Example 1. Attempt to match <code>a</code> or <code>ab</code></div><div class=content><div class="listingblock playground-example"><div class=title><a href="/playground?example=choice_bad&amp;mode=tree" title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>production</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;a&#34;</span><span class=p>)</span> <span class=o>|</span> <span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;ab&#34;</span><span class=p>);</span>
<span class=p>};</span></code></pre></div></div></div></div><div class=paragraph><p>However, as you will see when you try the example on the playground, it never actually matches <code>ab</code>, only <code>a</code>!</p></div><div class=paragraph><p>The reason for this is simple: in lexy, choice <code>lhs | rhs</code> is essentially syntax sugar for code like this:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>if</span> <span class=p>(</span><span class=n>match</span><span class=p>(</span><span class=n>lhs</span><span class=p>))</span>
    <span class=n>consume</span><span class=p>(</span><span class=n>lhs</span><span class=p>);</span>
<span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>match</span><span class=p>(</span><span class=n>rhs</span><span class=p>))</span>
    <span class=n>consume</span><span class=p>(</span><span class=n>rhs</span><span class=p>);</span>
<span class=k>else</span>
    <span class=nf>error</span><span class=p>();</span></code></pre></div></div><div class=paragraph><p>In other words, choice attempts to match each rule in the order they were specified in.
As <code>a</code> matches on <code>ab</code>, it will always take the first branch without considering <code>ab</code>.
The correct way to write it would thus be <code>LEXY_LIT("ab") | LEXY_LIT("a")</code>.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>Alternatively, in this particular case of matching one of multiple literals,
you can also use <a href=/reference/dsl/literal/#literal_set><code>lexy::dsl::literal_set</code> </a>.
This rule tries to find the longest literal that matches.</p></div></div></div><div class=paragraph><p>Likewise, translating the regex <code>a*a</code>, which matches arbitrary many <code>a`s and then one additional one (i.e. `a</code>, <code>aa</code>, <code>aaa</code>, …​), using <a href=/reference/dsl/loop/#while_><code>lexy::dsl::while_</code> </a> directly, doesn’t work either:</p></div><div class=exampleblock><div class=title>Example 2. Attempt to match <code>a*a</code></div><div class=content><div class="listingblock playground-example"><div class=title><a href="/playground?example=while_bad&amp;mode=tree" title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>production</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>while_</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;a&#39;</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;a&#39;</span><span class=o>&gt;</span><span class=p>;</span>
<span class=p>};</span></code></pre></div></div></div></div><div class=paragraph><p>Again, <code>while_()</code> does what it says in the name: it attempts to match the rule as often as possible and only stops matching when that isn’t possible anymore.
However, this means the last <code>dsl::lit_c&lt;'a'></code> can never succeed.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>while</span> <span class=p>(</span><span class=n>match</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>))</span>
  <span class=n>consume</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>);</span>
<span class=n>match_and_consume</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>);</span> <span class=c1>// can never succeed</span></code></pre></div></div><div class=paragraph><p>This behavior is a good thing, as it gives you full control over the parsing algorithm.
While a naive regex engine might need to resort to backtracking to match <code>a*a</code>, lexy will only backtrack if you’ve instructed it to.</p></div><div class=paragraph><p>The DSL is just syntax sugar for a hand-written parser.</p></div></div></div><div class=sect1><h2 id=_decisions_are_made_using_branches>Decisions are made using branches</h2><div class=sectionbody><div class=paragraph><p>Both <a href=/reference/dsl/choice/#choice><code>choice</code> </a> and <a href=/reference/dsl/loop/#while_><code>lexy::dsl::while_</code> </a> need to make a decision during parsing (which alternative to parse/should I parse another iteration?).
A simple way to make a decision is to just guess one, see what happens, and backtrack when it didn’t work out.
However, lexy does not do implicit backtracking.</p></div><div class=paragraph><p>Instead, all rules that make decision require <a href=/reference/dsl/branch/#doc>branch rule</a>s:
special rules where it can be easily checked whether or not they match at an input.
Those include:</p></div><div class=ulist><ul><li><p><a href=/reference/dsl/token/#doc>token rule</a>s such as <a href=/reference/dsl/literal/#lit><code>lexy::dsl::lit</code> </a>, <a href=/reference/dsl/ascii/#class><code>lexy::dsl::ascii::alpha</code> </a>, <a href=/reference/dsl/digit/#digits><code>lexy::dsl::digits</code> </a> (i.e. one token lookahead)</p></li><li><p>branch conditions such as <a href=/reference/dsl/peek/#peek><code>lexy::dsl::peek</code> </a>, <a href=/reference/dsl/branch/#else_><code>lexy::dsl::else_</code> </a></p></li><li><p>the branch combinator <a href=/reference/dsl/branch/#branch><code>lexy::dsl::operator>></code> </a></p></li></ul></div><div class=paragraph><p>So the choice above <code>LEXY_LIT("ab") | LEXY_LIT("a")</code> compiled because both alternatives are literal rules, which can be efficiently checked.
However, if we were to match between more complex alternatives, we need to manually specify how lexy should make a decision.</p></div><div class=paragraph><p>Let’s extend our previous color parser to also allow the function call syntax <code>rgb(255,0,255)</code>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>channel_hex</span> <span class=p>{</span> <span class=err>…</span> <span class=p>};</span> <b class=conum>(1)</b>

<span class=k>struct</span> <span class=nc>channel_dec</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>integer</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span><span class=o>&gt;</span><span class=p>;</span> <b class=conum>(2)</b>
<span class=p>};</span>

<span class=k>struct</span> <span class=nc>color</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]{</span>
        <span class=k>auto</span> <span class=n>hex_color</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hash_sign</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel_hex</span><span class=o>&gt;</span><span class=p>);</span> <b class=conum>(3)</b>

        <span class=k>auto</span> <span class=n>dec_channels</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel_dec</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>sep</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>comma</span><span class=p>));</span> <b class=conum>(4)</b>
        <span class=k>auto</span> <span class=n>fnc_color</span> <span class=o>=</span> <span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;rgb&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>parenthesized</span><span class=p>(</span><span class=n>dec_channels</span><span class=p>);</span> <b class=conum>(5)</b>

        <span class=k>return</span> <span class=n>hex_color</span> <span class=o>|</span> <span class=n>fnc_color</span><span class=p>;</span> <b class=conum>(6)</b>
    <span class=p>}();</span>
<span class=p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>We’ve renamed the old <code>channel</code> to <code>channel_hex</code>.</p></li><li><p>A decimal channel just parses an integer, the default matcher for <a href=/reference/dsl/integer/#integer><code>lexy::dsl::integer</code> </a> is <a href=/reference/dsl/digit/#digits><code>lexy::dsl::digits</code> </a>, which defaults to decimal.</p></li><li><p>The hex rule, as before.</p></li><li><p>We want three decimal channels, but separated by comma, which is specified in the second argument to <a href=/reference/dsl/times/#times><code>lexy::dsl::times</code> </a>.</p></li><li><p>We want to parse <code>rgb</code> followed by the parenthesized decimal channels, which can be easily done using <a href=/reference/dsl/brackets/#brackets-predefined><code>lexy::dsl::parenthesized</code> </a>.</p></li><li><p>We want to match either a hex color or a function call color, but this doesn’t compile.</p></li></ol></div><div class=paragraph><p>This code doesn’t compile, because the specified alternatives of the choice aren’t branch rules:
lexy has no idea how it should make a decision between them.
As such, we need to manually tell it by using the branch combinator <a href=/reference/dsl/branch/#branch><code>lexy::dsl::operator>></code> </a>:
its left-hand side is an existing branch rule, and the right-hand side an arbitrary rule.
The result is a branch rule that will use the LHS to make a decision about whether the branch is taken.</p></div><div class=paragraph><p>In our case, we want to match a hex color when we see a hash sign, and a function call color when we see the literal <code>rgb</code>:</p></div><div class=exampleblock><div class=title>Example 3. Parse a hex color or function call color</div><div class=content><div class="listingblock playground-example"><div class=title><a href="/playground?example=color_function&amp;mode=tree" title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>channel_hex</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>integer</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>n_digits</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hex</span><span class=o>&gt;</span><span class=p>);</span>
<span class=p>};</span>

<span class=k>struct</span> <span class=nc>channel_dec</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>integer</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=kt>uint8_t</span><span class=o>&gt;</span><span class=p>;</span>
<span class=p>};</span>

<span class=k>struct</span> <span class=nc>color</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=k>auto</span> <span class=n>hex_color</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>hash_sign</span> <span class=o>&gt;&gt;</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel_hex</span><span class=o>&gt;</span><span class=p>);</span>

        <span class=k>auto</span> <span class=n>dec_channels</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>times</span><span class=o>&lt;</span><span class=mi>3</span><span class=o>&gt;</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>p</span><span class=o>&lt;</span><span class=n>channel_dec</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>dsl</span><span class=o>::</span><span class=n>sep</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>comma</span><span class=p>));</span>
        <span class=k>auto</span> <span class=n>fnc_color</span>    <span class=o>=</span> <span class=n>LEXY_LIT</span><span class=p>(</span><span class=s>&#34;rgb&#34;</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=n>dsl</span><span class=o>::</span><span class=n>parenthesized</span><span class=p>(</span><span class=n>dec_channels</span><span class=p>);</span>

        <span class=k>return</span> <span class=n>hex_color</span> <span class=o>|</span> <span class=n>fnc_color</span><span class=p>;</span>
    <span class=p>}();</span>
<span class=p>};</span>

<span class=k>using</span> <span class=n>production</span> <span class=o>=</span> <span class=n>color</span><span class=p>;</span></code></pre></div></div></div></div><div class=paragraph><p>Note that in a lucky coincidence of operator precedence, the syntax <code>condition1 >> rule1a + rule 1b | condition2 >> rule2a + rule2b | …​</code> has exactly the semantics we want here.</p></div><div class=paragraph><p>Also note that once a decision to take a branch has been made using the branch condition, lexy will never backtrack again — even if the branch later fails.
For example, consider a call to <code>dsl::while_(LEXY_LIT("a") >> LEXY_LIT("b") + LEXY_LIT("c"))</code>.
We’ve instructed lexy to try another iteration when it sees an <code>a</code>: it doesn’t matter what comes after it.</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code>abcabcabd
^ start, try to match the condition

abcabcabd
-^ condition matched, we take the branch

abcabcabd
---^ branch matched, try to match condition of the next iteration

abcabcabd
----^ condition matched, we take the branch

abcabcabd
------^ branch matched, try to match condition of the next iteration

abcabcabd
-------^ condition matched, we take the branch

abcabcabd
--------^ error: expected `c` not `d`, however we no longer bracktrack!</code></pre></div></div></div></div><div class=sect1><h2 id=_convenience_rules_to_get_automatic_branch_conditions>Convenience rules to get automatic branch conditions</h2><div class=sectionbody><div class=paragraph><p>Specifying a branch condition every time lexy needs to make a decision, can be pretty annoying.
Luckily, there are many situations where that isn’t necessary:</p></div><div class=ulist><ul><li><p><a href=/reference/dsl/production/#p><code>lexy::dsl::p</code> </a> is a branch condition if the rule of the production is a branch (and the production does not specify custom <a href=/reference/dsl/whitespace/#doc><code>whitespace</code> </a>).
In that case, it is convenient to specify a condition in the rule of a production.
<a href="/playground?example=choice_production">Try it online</a>.</p></li><li><p><a href=/reference/dsl/branch/#else_><code>lexy::dsl::else_</code> </a> is a branch condition that is always taken.
As such, if you have a choice between <code>N</code> alternatives, you only need to provide conditions for <code>N - 1</code>, and can use <code>else_ >></code> for the last one.
However, it needs to be the last alternative listed in the choice, as branches are tried in order!</p></li><li><p><a href=/reference/dsl/list/#list><code>lexy::dsl::list</code> </a> parses a list of things and just like <a href=/reference/dsl/loop/#while_><code>lexy::dsl::while_</code> </a> requires a branch condition.
However, when you’re parsing a list of things with a mandatory separator like a comma between them, it doesn’t actually require one:
after parsing the mandatory first item, if the next thing is a separator, lexy knows that it needs to parse another item.</p></li><li><p>Often, a list of things is surrounded and/or terminated by some specific token.
For example, arguments in a function call are surrounded by parenthesis, so we can decide whether we want another argument by checking whether we’ve reached the closing parenthesis.
In lexy, this can be accomplished by specifying your own <a href=/reference/dsl/brackets/#brackets><code>lexy::dsl::brackets</code> </a> or <a href=/reference/dsl/terminator/#terminator><code>lexy::dsl::terminator</code> </a>,
or using existing one like <a href=/reference/dsl/brackets/#brackets-predefined><code>lexy::dsl::parenthesized</code> </a>.
As a bonus, you get really sophisticated error recovery for free.
<a href="/playground?example=parenthesized">Try it online</a>.</p></li><li><p><a href=/reference/dsl/delimited/#delimited><code>lexy::dsl::delimited</code> </a> parses a string literal surrounded by the given delimiters.
It automatically takes care of checking the closing delimiter for you.</p></li></ul></div><div class=paragraph><p>Of course, sometimes you need to specify your own branch condition and there isn’t a single token you can use to make a decision.
Then you can use backtracking using <a href=/reference/dsl/peek/#peek><code>lexy::dsl::peek</code> </a> or <a href=/reference/dsl/lookahead/#lookahead><code>lexy::dsl::lookahead</code> </a>,
which look at the next input and decide about taking a branch without consuming anything.</p></div><div class=exampleblock><div class=title>Example 4. Peek ahead to see whether we have a number</div><div class=content><div class="listingblock playground-example"><div class=title><a href="/playground?example=peek&amp;mode=tree" title="Try it online"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="play" class="svg-inline--fa fa-play fa-w-14" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a></div><div class=content><pre class="rouge highlight"><code data-lang=cpp><span class=k>struct</span> <span class=nc>production</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>constexpr</span> <span class=k>auto</span> <span class=n>rule</span> <span class=o>=</span> <span class=p>[]</span> <span class=p>{</span>
        <span class=c1>// Number with optional minus sign.</span>
        <span class=k>auto</span> <span class=n>number</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>minus_sign</span> <span class=o>+</span> <span class=n>dsl</span><span class=o>::</span><span class=n>digits</span><span class=o>&lt;&gt;</span><span class=p>;</span>

        <span class=c1>// Only parse a number if we have a minus or digit.</span>
        <span class=k>auto</span> <span class=n>condition</span> <span class=o>=</span> <span class=n>dsl</span><span class=o>::</span><span class=n>peek</span><span class=p>(</span><span class=n>dsl</span><span class=o>::</span><span class=n>lit_c</span><span class=o>&lt;</span><span class=sc>&#39;-&#39;</span><span class=o>&gt;</span> <span class=o>/</span> <span class=n>dsl</span><span class=o>::</span><span class=n>digit</span><span class=o>&lt;&gt;</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>dsl</span><span class=o>::</span><span class=n>if_</span><span class=p>(</span><span class=n>condition</span> <span class=o>&gt;&gt;</span> <span class=n>number</span><span class=p>);</span>
    <span class=p>}();</span>
<span class=p>};</span></code></pre></div></div></div></div></div></div></article></main><footer id=page-footer><section class=copyright>&copy; <a target=_blank href=https://github.com/foonathan/lexy/blob/main/LICENSE title=License>2020-2025 Jonathan Müller and lexy contributors</a></section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://fontawesome.com/license>Font Awesome</a>.</section></footer></body></html>